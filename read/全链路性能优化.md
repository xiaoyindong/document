## 1. 概述

通常来讲前端性能优化是指从用户开始访问我们的网站到整个页面完整的展现出来的过程中，通过各种优化策略和优化方法让页面加载的更快，让用户的操作响应更及时，给用户更好的使用体验。

这里我们介绍的是前端性能优化知识的解决方案，从静态资源优化开始入手，从表象深入体系化的讲解页面渲染架构，掌握搞笑的技术方案。

本文并非细节的讲述如何实现性能优化，而是从各个方面介绍性能优化的方式方法，并且不仅限于```H5```，因为当今的前端也不仅仅只有```H5```。

## 2. 图片资源优化

### 1. 图片格式介绍

jpeg:一种针对彩色照片而广泛使用的有损压缩图形格式。是一种栅格图形，常用文件扩展名为```jpg```，```jpeg```，```jpe```。在互联网上常被应用于存储和传输照片。不适合线条图形和文字，图标图形，因为他的压缩算法不支持这些类型的图形，并且不支持透明度。常用于色彩丰富的照片，彩色图大焦点图```banner```等结构不规则的图形。

png:便携式网络图形，是一种无损压缩的位图图形格式，支持索引、灰度、```RGB```三种颜色，以及```Alpha```通道等特性。他最初的设计是为了代替```GIF```,能够支持半透明和透明特性，最高支持```24```位彩色图形和```8```位灰度图像。不过由于是无损压缩所以文件体积太大。比较适合纯色，透明，线条绘图，图标以及颜色较少的需要半透明的图片。

GIF:位图图形文件格式，```8```位色重现真彩色的图像，采用```LZW```压缩算法进行编码。支持```256```色，仅支持完全透明和完全不透明，可以支持动图，不过每个像素只有```8```比特，不适合存储彩色图片。常用与动画和图标。

webp:是一种现代图像格式，可以提供无损压缩和有损压缩两种。可以同时办证一定程序上的图像质量和较小的体积，可以插入多帧，实现动画效果。支持透明度。采用```8```位压缩算法，无损的```webp```比```png```小```26%```，有损的```webp```比```jpeg```小```25-34%```，比```gif```有更好的动画。不过最多可以处理```256```色，不适合彩色图片。常用于图形和半透明图像。

### 2. 图片优化

对于```png```图片来说，可以使用```jdf-png-native```进行压缩, 他是```node-pngquant-native```工具的封装包，这个工具跨平台，压缩比高，而且压缩```png24```也非常的好。

```js
const pngquant = require('jdf-png-native');
const fs = require('fs');

fs.readFile('./in.png', (err, buffer) => {
    if (err) {
        throw err;
    }
    const resBuffer = pngquant.option({}).compress(buffer);
    fs.writeFile('./out.png', resBuffer), {
        flags:'wb'
    }, () => {})
})
```

压缩```jpg```可以使用```jpegtran```这个工具，他也是一个```node```工具。使用方法比较简单，直接使用命令即可。大概压缩```10%```的占比。

```s
jpegtran -copy node -optimize-outfile out.jpg in.jpg
```

对于```gif```文件来说可以使用```gifsicle```工具，他是通过改变每帧比例，减小```gif```文件大小，同时可以使用透明来达到更小的文件体积。是一个公认的解决方案。可以去```http://www.lcdf.org/gifsicle/```中去安装。使用方式同样也是命令行方式。

```s
gifsicle --optimize=3 --crop-transparency -o out.gif in.gif
```

这里的优化级别不要小于```2```，```1```的话代表不压缩。压缩后基本不失帧。

还有一种压缩方式是图片可以根据网络环境来展示不同尺寸和像素的图片，通过在```url```后缀加不同参数来实现。比如下面的地址,```430```可以修改为```800```来获得不同体积的图片。

```https://img.alicdn.com/imgextra/i1/2616970884/O1CN01x6HnoK1IOuj5IosXO_!!2616970884.jpg_430x430q90.jpg```

### 3. 响应式图片

响应式图片是我们可以在用户不同的窗口大小还有设备像素的情况下来展示不同大小的图片，可以用以下三种方式来实现, 第一种是可以使用```js```来绑定事件检测窗口大小，以此来设置图片的大小。第二种方式就是```css```的媒体查询。

```css
@media screen and (max-width:640) {
    my_image { width:640px; }
}
```

第三种可以使用```html5```的```srcset```来设置，他会根据设备的像素比来自动选择需要的图片。而且不支持```srcset```的浏览器也可以正常展示```src```的属性。

```html
<img srcset="img-320w.jpg, img-640w.jpg 2x, img-960w.jpg 3x" src="img-960w.jpg" alt="img" />
```

### 4. 逐步加载图片的方式

其实就是延迟加载，在真实的图片加载出来之前，可以使用一张公共的图片，一般是公司的```logo```，先将布局撑起来，然后再换成真实的图片。

```lqip```这个工具可以将真实的图片虚化，转换为很小的```base64```编码。这样我们可以先使用```base64```加载虚化的图片。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba1073480c554b94877a7aa48397f221~tplv-k3u1fbpfcp-watermark.image)

```s
npm install lqip
```

```js
const lqip = require('lqip');
const file = './in.png';
// image
lqip,base64(file).then(res => {
    console.log(res); // 输出base64
})
// color
lqip.paletter(file).then(res => {
    console.log(res); // 图片颜色值
})
```

也可以使用低质量图片占位符, 他是基于SVG的图像占位符实现的。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba1073480c554b94877a7aa48397f221~tplv-k3u1fbpfcp-watermark.image)

```s
npm install sqip
```

```js
const sqip = require('sqip');

const result = sqip({
    filename:'./in.png',
    numberOfPrimitives:10 // 效果值
});

console.log(result.final_svg); // 输出svg格式
```

相比```lqip```来说```sqip```效果会好很多，而且可以设置不同的大小。

### 5. 其他方式

可以使用```web font```来代替图片，比如说小图标等业务小图片。

也可以用```dataurl```的方式，也就是前面的```base64```的方式来代替图片，这样用户就不需要发送```http```请求了。

也可以采用雪碧图将多个小图片合成一个大图，这样也会节省很多的图片请求。

### 6. 图片服务器自动优化

图片服务器优化是指可以在图片```url```连接上增加不同特殊参数，让服务器自动生成不同格式，大小，质量的图片。

比如说可以对图片做一些裁剪，裁剪成我们需要的图片，也可以支持不同格式的转换，比如说```jpg```，```gif```，```png```，```webp```等也可以设置图片的压缩比。

也可以对图片添加一些水印，高斯模糊，重心处理等还可以增加一些AI的能力，比如说用户上传的图片是否涉黄。还可以通过智能抠图，智能排版，智能配色智能合成等功能完善图片。

## 3. HTML的优化方法

### 1. 精简html代码

可以减少```html```的嵌套也就是层级关系尽量减小，也可以减小```DOM```节点数也就是尽量压缩优化```DOM```的节点数, 让浏览器渲染的```DOM```节点数最少。

减少一些无语义的代码，比如说空标签清浮动那种代码```<div class="clear"></div>```能不用最好不要用。

建议连接中删除```http```或者```https```，因为一般链接的协议头和页面的协议头都是一致的，写他们多了```4-5```个字符其实是没有什么意义的。而且可以减少代码体积。

也可以删除多余的空格，换行符，缩进和不必要的注释，一般会用压缩工具来处理这个过程。可以省略一些标签和属性。使用相对路径的```url```，最大范围的减少字节数。

### 2. 文件位置

```css```文件链接尽量放在页面头部，```css```加载不会阻塞```DOM Tree```解析，但是会阻塞```DOM Tree```渲染，也会阻塞后面```js```执行。也就是说```DOM Tree```在渲染前就要解析好```CSS```，从而减少浏览器重排文档的次数。而且```css```放在页面底部会导致页面白屏时间变长。

```js```文件一般放在页面底部，这是防止```js```的加载和解析阻塞页面元素的正常渲染。

### 3. 用户体验

设置```favicon.ico```, 如果不设置控制台会报错，而且用户访问的时候地址栏也是空的，不利于品牌记忆。

增加首屏必要的```css```和```js```，一般页面需要在等待所有的依赖加载完成才会展示，这样就会导致页面存在空白。永祥用户体验，可以增加背景图或者```loading```或者骨架屏，比空白页好很多。

## 4. CSS优化细则

### 1. 提升css渲染性能

谨慎使用一些```expensive```的属性，比如```nth-child```伪类或者```position:fixed```定位，因为这些比较消耗浏览器的渲染性能。

尽量减少一些样式层级的级数，比如，```div ul li span i { color:red}```, 其实我们可以给i标签设置```class```，直接书写样式。

避免使用占用过多```cpu```和内存的属性，比如```text-indent```不要设置太大的值。

尽量避免使用耗电量大的属性，比较占用```GPU```, 比如```transfrom```是，```transitions, opacity```。

合适的使用```css```选择器, 尽量避免使用通配符，避免使用```css```表达式。```color:expression((new Date()).getHours() % 2 ? "#fff" :"#000")```。

避免类正则的属性选择器。```*=```，```|=```，```^=```，```$=```，使用外链的```css```，可以单独形成文件放在```cdn```，使用缓存形式加载。避免使用```@import```因为他的加载会阻塞进程，需要加载完毕才会向下执行。

精简```css```代码，使用缩写的语句，比如```margin-top```可以写在```margin```中，再者如果值为```0```能删除就删除，删除不必要的单位值，删除过多的分号，删除空格和注释。尽量减小样式表的体积。其实这些都可以使用压缩工具来处理，会方便很多。

### 2. 合理使用web fonts

可以将字体文件部署到```cdn```上，加快用户端的加载速度，也可以将字体以```base64```的形式保存在```css```中，并通过```localStorage```进行缓存。一些谷歌字体库应该使用国内托管服务不要直接使用源地址。

### 3. css动画优化

避免同时动画，也就是说用户访问的屏幕区间里面不要有过多的动画，动画太多会干扰用户正常浏览网站，而且动画多也影响浏览器的性能。

延迟动画的初始化，可以让其它```css```先渲染，让动画延迟，比如说```0.5```或```1```。

可以借助```svg```去展示动画，样式放在```css```里面控制。

## 5. JavaScript优化

首先我们是当需要的时候才去优化，不是为了优化而优化，一般的优化是在某一个时间点进行的，而且优化也需要考虑可维护性这是要结合团队的研发水平和代码的规范。

### 1. 提升js文件的加载性能

这个基本每个人都知道，就是```css```文件放在head标签中，```js```文件放在```body```结尾的地方。这个是```js```的加载不要影响```html```的渲染。

### 2. 变量和函数方面的优化

尽量使用```id```选择器，因为```id```选择器在查询效果上效率最快。

避免使用```eval```，这个方法比较消耗能行。

```js```函数尽可能保持简洁，不要把太多内容写在一个函数中。也建议使用事件的节流函数。事件委托等等。

### 3. js动画

尽量避免添加大量的```js```动画，```css3```动画和```canvas```动画都比```js```动画性能好。

使用```requestAnimationFrame```来代替```setTimeout```和```setInterval```，因为```requestAnimationFrame```可以在正确的时间进行渲染，```setTimout```和```setInterval```无法保证渲染时机。不要在定时器里面绑定事件。

### 4. 使用逻辑缓存

缓存```dom```对象，也就是用一个变量来存储```do```m对象，不要每次使用都查询。

缓存列表长度，也就是说用变量存储```dom```元素的个数，而不是每次都重新计算。

比如百度```M```站，会把页面的```css```和```js```放在本地存储里面，这样后面再加载的时候就直接从本地存储里面取，实现秒考的效果。不过本地存储空间有限，要谨慎使用。

## 6. 减少页面回流和重绘

### 1. css

避免过多的样式嵌套，最好可以快速的定位到元素。

避免使用```css```表达式，```css```表达式会在```css```绘制的过程中都会执行，会增加重排和回流的次数。

可以使用绝对定位让动画元素脱离文档流。

避免使用```table```布局他会引起浏览器的多次重绘，也不要使用```float```布局。

图片最好设置好设置```width```和```height```，这样图片在加载之后布局就可以确定了。

简化浏览器不必要额任务，使用```viewport```设置屏幕缩放级别。

避免频繁设置样式，将多个样式操作合并修改,一次性的更新。

### 2. js

为了减少回流发生次数，应该避免频繁操作``DOM``，可以合并多次对```DOM```的修改，一次性批量处理。

控制绘制过程和绘制区域，绘制过程开销比较大的属性设置应当避免使用。

## 7. 简化DOM操作

众所周知，页面交互卡顿和流畅度很大一部分原因就是页面有大量```DOM```元素，想想一下，从一个上万节点的```DOM```树上，使用```querySelectorAll```或```getElementByTagName```方法查找某一个节点，是非常耗时的，另外元素绑定事件时，事件冒泡和事件捕获的执行也会相对耗时。所以一般我们应该合理的不熟业务逻辑，```DOM```节点过多时应该延迟即将呈现的```DOM```内容。

对```DOM```的操作最好统一处理后再统一插入到```DOM Tree```中。可以使用```fragment```对```DOM```和样式设置好再统一放到页面中去。

目前比较流行的框架，比如```Angular```，```React```和```Vue```都是使用```虚拟DOM```技术，通过```diff```算法简化和减少```DOM```操作。

## 8. 静态文件压缩工具

html-minifier:压缩```html```
clean-css:```css```的压缩工具
uglify-js:```js```文件的压缩工具

## 9. 浏览器渲染过程

首先浏览器会解析```HTML```生成```DOM Tree```，然后解析```CSS```生成```CSSOM Tree```。接着```JS```会通过```DOM Api```和```CSSOM Api```来操作```DOM Tree```和```CSS Rule Tree```将```DOM Tree```和```CSSOM Tree```合成一颗渲染树```Render Tree```。

根据生成的渲染树进行回流，以计算每个节点的几何信息，包括位置，大小，样式等等。然后根据渲染树和回流得到的几何信息，得到每个节点上的绝对像素。

最后将像素发送给图片处理器也就是```GPU```进行页面展示。

前端页面渲染可以分为服务端渲染和客户端渲染。服务端渲染有传统的后端同步渲染，同构直出比如```php```，```java```,```.net```或者大家熟悉的```node```。

客户端渲染也就是```js```渲染，前后端分离，单页面应用。```react```,```vue```,```ios```,```安卓```，```hybird app```，```flutter```等。

## 10. 懒加载，预加载，预渲染

懒加载也叫延迟加载，指的是长网页中延迟加载特定元素，可以是图片也可以是```js```和```css```。懒加载的好处是可以减少当前屏无效资源的加载。

一般我们会把```img```标签的```src```属性设置为空字符串，真实的图片地址放在```data-lazy```中，当页面```scroll```到对应的位置时再通过```DOM```操作将```src```的值替换为```data-lazy```的值。

预加载是让浏览器预先加载某些资源，同样也是图片，```js```或者```css```，这些资源是在将来才会被使用的。

简单来说就是讲所需要的资源提前加载到浏览器本地，后面在需要的时候可以直接从浏览器的缓存中获取，而不用再重新开始加载。好处是减少用户后续加载资源等待的时间。

可以使用```new Image```的方式也可以使用标签的方式```preload```，```prefetch```，```preconnect```

```html
<link rel="preload" href="src/style.css" />
<link rel="prefetc" href="src/image.png" />
<link rel="dns-prefetch" href="https://zhiqianduan.com" /> <!-- 提前将dns缓存-->
<link rel="preconnect" href="https://zhiqianduan.com" /> <!-- 提前加载需要的资源 -->
```

另一种预加载组件的方式就是提前渲染它，在页面中渲染组件，但是并不在页面中展示，也就是渲染好后先隐藏起来，用的时候再直接展示。可以使用```prerender```将```https://zhiqianduan.com```页面先提前渲染好。

```html
<link rel="prerender" href="https://zhiqianduan.com" />
```

## 11. 接口服务调用优化

1. 接口合并，指一个页面的众多的业务接口和依赖的第三方接口统一使用一个部署在集群的接口统一调用，以减少页面接口请求数。

2. 接口上CDN，主要基于接口性能考虑，我们可以把不需要实时更新的接口同步至CDN，接口内容变更自动同步CDN。

3. 接口域名上CDN可以增强可用性和稳定性。

4. 接口降级，这个基于大促备战考虑，核心进行降级用基础接口进行业务实现，比如千人千面的推荐接口，在大促时间点可以直接运营编辑的数据，另外接口万一无法访问，使用预设好的垫底备份数据。

5. 接口监控，监控接口的成功率不是常说的服务器TP99，而是和用户实际情况一直的成功和失败监控，比如弱网，超时，网络异常，网络切换等情况。排查出来问题需要联合后端，运维，网络岗位人员一并解决。

## 12. 接口缓存优化

1. ajax/fetch缓存，前端请求的时候带上cache，依赖浏览器本身的机制来请求接口，这个比较适用于不会经常变更的数据。

2. 本地缓存，异步接口数据优先使用本地localStorage中缓存的数据。可以让服务端返回数据的时候再给一个md5值，然后将md5值和数据绑定存在本地，再次请求的时候对比这个md5值，如果相同就不要再请求获取数据的接口了，如果不同就请求更新。

## 13. webview

原生的```webview```对于```IOS```来说有两种，一种是```UIWebView```，他从```IOS2```开始就作为```App```内展示```web```内容的容易，而且排版布局能力比较强。

不过```UIWebView```也有很多的问题，比如说内存泄漏，运行期间会有极高的内存峰值，```Touch Delay```延迟300毫秒。```js```运行性能不高，在```2018```年的```ios12```以后就不再维护了。

```WKWebView```是苹果在```WWDC 2014```上推出的新一代```WebView```组件，```WKWebView```的内存开销比```UIWebView```要小很多，而且在性能，稳定性，内存占用方面都有很大提升。可以实现```60fps```的滚动刷新率，自身就支持了右滑返回手势，支持更多的```HTML```属性。内存占用是```UIWebView```的```1/4 ~ 1/3```, 加载速度比```UIWebView```提升了一倍左右。大幅度提升了```js```执行速度。允许```js```的```Nitro```库的使用，```UIWebView```是不允许的。可以和```js```直接互调函数，不需要使用```jsbridge```来协助。

当然```WKWebView```不支持页面缓存，需要自己注入```cookie```，而```UIWebView```是自动注入```cookie```的。他也无法发送```POST```参数。

对于安卓来说存在```webkit for webview```和```chromium for webview```。

```webkit```是一个开源项目，前身是```khtml```和```kjs```，专注于网页内容的展示，做了一流的页面渲染引擎，他不是浏览器而且也不想成为浏览器，这个项目包含两个部分，第一个部分是```WebCore```, 其中包括对```html```，```css```很多```w3c```规范的实现，第二部分就是狭义上的```webkit```主要是各个平台的移植并提供相应的接口。也就是```webview```和类似于```webview```，这样的接口提供操作和显示网页的能力。

目前使用```WK```的主流浏览器或者```webview```包括```chrome```，```safari```, 安卓平台以及众多的移动浏览器。

```chromium```是基于```webkit```之上的一个浏览器项目，由谷歌来发起，这个项目发展的还是比较迅速的，他对新特性的支持还是比较好的，比如```webgl```，```css3```，```h5```等等，在性能方向也非常不错``