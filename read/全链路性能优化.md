## 1. 概述

通常来讲前端性能优化是指从用户开始访问我们的网站到整个页面完整的展现出来的过程中，通过各种优化策略和优化方法让页面加载的更快，让用户的操作响应更及时，给用户更好的使用体验。

这里我们介绍的是前端性能优化知识的解决方案，从静态资源优化开始入手，从表象深入体系化的讲解页面渲染架构，掌握搞笑的技术方案。

本文并非细节的讲述如何实现性能优化，而是从各个方面介绍性能优化的方式方法，并且不仅限于```H5```，因为当今的前端也不仅仅只有```H5```。

## 2. 图片资源优化

### 1. 图片格式介绍

jpeg:一种针对彩色照片而广泛使用的有损压缩图形格式。是一种栅格图形，常用文件扩展名为```jpg```，```jpeg```，```jpe```。在互联网上常被应用于存储和传输照片。不适合线条图形和文字，图标图形，因为他的压缩算法不支持这些类型的图形，并且不支持透明度。常用于色彩丰富的照片，彩色图大焦点图```banner```等结构不规则的图形。

png:便携式网络图形，是一种无损压缩的位图图形格式，支持索引、灰度、```RGB```三种颜色，以及```Alpha```通道等特性。他最初的设计是为了代替```GIF```,能够支持半透明和透明特性，最高支持```24```位彩色图形和```8```位灰度图像。不过由于是无损压缩所以文件体积太大。比较适合纯色，透明，线条绘图，图标以及颜色较少的需要半透明的图片。

GIF:位图图形文件格式，```8```位色重现真彩色的图像，采用```LZW```压缩算法进行编码。支持```256```色，仅支持完全透明和完全不透明，可以支持动图，不过每个像素只有```8```比特，不适合存储彩色图片。常用与动画和图标。

webp:是一种现代图像格式，可以提供无损压缩和有损压缩两种。可以同时办证一定程序上的图像质量和较小的体积，可以插入多帧，实现动画效果。支持透明度。采用```8```位压缩算法，无损的```webp```比```png```小```26%```，有损的```webp```比```jpeg```小```25-34%```，比```gif```有更好的动画。不过最多可以处理```256```色，不适合彩色图片。常用于图形和半透明图像。

### 2. 图片优化

对于```png```图片来说，可以使用```jdf-png-native```进行压缩, 他是```node-pngquant-native```工具的封装包，这个工具跨平台，压缩比高，而且压缩```png24```也非常的好。

```js
const pngquant = require('jdf-png-native');
const fs = require('fs');

fs.readFile('./in.png', (err, buffer) => {
    if (err) {
        throw err;
    }
    const resBuffer = pngquant.option({}).compress(buffer);
    fs.writeFile('./out.png', resBuffer), {
        flags:'wb'
    }, () => {})
})
```

压缩```jpg```可以使用```jpegtran```这个工具，他也是一个```node```工具。使用方法比较简单，直接使用命令即可。大概压缩```10%```的占比。

```s
jpegtran -copy node -optimize-outfile out.jpg in.jpg
```

对于```gif```文件来说可以使用```gifsicle```工具，他是通过改变每帧比例，减小```gif```文件大小，同时可以使用透明来达到更小的文件体积。是一个公认的解决方案。可以去```http://www.lcdf.org/gifsicle/```中去安装。使用方式同样也是命令行方式。

```s
gifsicle --optimize=3 --crop-transparency -o out.gif in.gif
```

这里的优化级别不要小于```2```，```1```的话代表不压缩。压缩后基本不失帧。

还有一种压缩方式是图片可以根据网络环境来展示不同尺寸和像素的图片，通过在```url```后缀加不同参数来实现。比如下面的地址,```430```可以修改为```800```来获得不同体积的图片。

```https://img.alicdn.com/imgextra/i1/2616970884/O1CN01x6HnoK1IOuj5IosXO_!!2616970884.jpg_430x430q90.jpg```

### 3. 响应式图片

响应式图片是我们可以在用户不同的窗口大小还有设备像素的情况下来展示不同大小的图片，可以用以下三种方式来实现, 第一种是可以使用```js```来绑定事件检测窗口大小，以此来设置图片的大小。第二种方式就是```css```的媒体查询。

```css
@media screen and (max-width:640) {
    my_image { width:640px; }
}
```

第三种可以使用```html5```的```srcset```来设置，他会根据设备的像素比来自动选择需要的图片。而且不支持```srcset```的浏览器也可以正常展示```src```的属性。

```html
<img srcset="img-320w.jpg, img-640w.jpg 2x, img-960w.jpg 3x" src="img-960w.jpg" alt="img" />
```

### 4. 逐步加载图片的方式

其实就是延迟加载，在真实的图片加载出来之前，可以使用一张公共的图片，一般是公司的```logo```，先将布局撑起来，然后再换成真实的图片。

```lqip```这个工具可以将真实的图片虚化，转换为很小的```base64```编码。这样我们可以先使用```base64```加载虚化的图片。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba1073480c554b94877a7aa48397f221~tplv-k3u1fbpfcp-watermark.image)

```s
npm install lqip
```

```js
const lqip = require('lqip');
const file = './in.png';
// image
lqip,base64(file).then(res => {
    console.log(res); // 输出base64
})
// color
lqip.paletter(file).then(res => {
    console.log(res); // 图片颜色值
})
```

也可以使用低质量图片占位符, 他是基于SVG的图像占位符实现的。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba1073480c554b94877a7aa48397f221~tplv-k3u1fbpfcp-watermark.image)

```s
npm install sqip
```

```js
const sqip = require('sqip');

const result = sqip({
    filename:'./in.png',
    numberOfPrimitives:10 // 效果值
});

console.log(result.final_svg); // 输出svg格式
```

相比```lqip```来说```sqip```效果会好很多，而且可以设置不同的大小。

### 5. 其他方式

可以使用```web font```来代替图片，比如说小图标等业务小图片。

也可以用```dataurl```的方式，也就是前面的```base64```的方式来代替图片，这样用户就不需要发送```http```请求了。

也可以采用雪碧图将多个小图片合成一个大图，这样也会节省很多的图片请求。

### 6. 图片服务器自动优化

图片服务器优化是指可以在图片```url```连接上增加不同特殊参数，让服务器自动生成不同格式，大小，质量的图片。

比如说可以对图片做一些裁剪，裁剪成我们需要的图片，也可以支持不同格式的转换，比如说```jpg```，```gif```，```png```，```webp```等也可以设置图片的压缩比。

也可以对图片添加一些水印，高斯模糊，重心处理等还可以增加一些AI的能力，比如说用户上传的图片是否涉黄。还可以通过智能抠图，智能排版，智能配色智能合成等功能完善图片。

## 3. HTML的优化方法

### 1. 精简html代码

可以减少```html```的嵌套也就是层级关系尽量减小，也可以减小```DOM```节点数也就是尽量压缩优化```DOM```的节点数, 让浏览器渲染的```DOM```节点数最少。

减少一些无语义的代码，比如说空标签清浮动那种代码```<div class="clear"></div>```能不用最好不要用。

建议连接中删除```http```或者```https```，因为一般链接的协议头和页面的协议头都是一致的，写他们多了```4-5```个字符其实是没有什么意义的。而且可以减少代码体积。

也可以删除多余的空格，换行符，缩进和不必要的注释，一般会用压缩工具来处理这个过程。可以省略一些标签和属性。使用相对路径的```url```，最大范围的减少字节数。

### 2. 文件位置

```css```文件链接尽量放在页面头部，```css```加载不会阻塞```DOM Tree```解析，但是会阻塞```DOM Tree```渲染，也会阻塞后面```js```执行。也就是说```DOM Tree```在渲染前就要解析好```CSS```，从而减少浏览器重排文档的次数。而且```css```放在页面底部会导致页面白屏时间变长。

```js```文件一般放在页面底部，这是防止```js```的加载和解析阻塞页面元素的正常渲染。

### 3. 用户体验

设置```favicon.ico```, 如果不设置控制台会报错，而且用户访问的时候地址栏也是空的，不利于品牌记忆。

增加首屏必要的```css```和```js```，一般页面需要在等待所有的依赖加载完成才会展示，这样就会导致页面存在空白。永祥用户体验，可以增加背景图或者```loading```或者骨架屏，比空白页好很多。

## 4. CSS优化细则

### 1. 提升css渲染性能

谨慎使用一些```expensive```的属性，比如```nth-child```伪类或者```position:fixed```定位，因为这些比较消耗浏览器的渲染性能。

尽量减少一些样式层级的级数，比如，```div ul li span i { color:red}```, 其实我们可以给i标签设置```class```，直接书写样式。

避免使用占用过多```cpu```和内存的属性，比如```text-indent```不要设置太大的值。

尽量避免使用耗电量大的属性，比较占用```GPU```, 比如```transfrom```是，```transitions, opacity```。

合适的使用```css```选择器, 尽量避免使用通配符，避免使用```css```表达式。```color:expression((new Date()).getHours() % 2 ? "#fff" :"#000")```。

避免类正则的属性选择器。```*=```，```|=```，```^=```，```$=```，使用外链的```css```，可以单独形成文件放在```cdn```，使用缓存形式加载。避免使用```@import```因为他的加载会阻塞进程，需要加载完毕才会向下执行。

精简```css```代码，使用缩写的语句，比如```margin-top```可以写在```margin```中，再者如果值为```0```能删除就删除，删除不必要的单位值，删除过多的分号，删除空格和注释。尽量减小样式表的体积。其实这些都可以使用压缩工具来处理，会方便很多。

### 2. 合理使用web fonts

可以将字体文件部署到```cdn```上，加快用户端的加载速度，也可以将字体以```base64```的形式保存在```css```中，并通过```localStorage```进行缓存。一些谷歌字体库应该使用国内托管服务不要直接使用源地址。

### 3. css动画优化

避免同时动画，也就是说用户访问的屏幕区间里面不要有过多的动画，动画太多会干扰用户正常浏览网站，而且动画多也影响浏览器的性能。

延迟动画的初始化，可以让其它```css```先渲染，让动画延迟，比如说```0.5```或```1```。

可以借助```svg```去展示动画，样式放在```css```里面控制。

## 5. JavaScript优化

首先我们是当需要的时候才去优化，不是为了优化而优化，一般的优化是在某一个时间点进行的，而且优化也需要考虑可维护性这是要结合团队的研发水平和代码的规范。

### 1. 提升js文件的加载性能

这个基本每个人都知道，就是```css```文件放在head标签中，```js```文件放在```body```结尾的地方。这个是```js```的加载不要影响```html```的渲染。

### 2. 变量和函数方面的优化

尽量使用```id```选择器，因为```id```选择器在查询效果上效率最快。

避免使用```eval```，这个方法比较消耗能行。

```js```函数尽可能保持简洁，不要把太多内容写在一个函数中。也建议使用事件的节流函数。事件委托等等。

### 3. js动画

尽量避免添加大量的```js```动画，```css3```动画和```canvas```动画都比```js```动画性能好。

使用```requestAnimationFrame```来代替```setTimeout```和```setInterval```，因为```requestAnimationFrame```可以在正确的时间进行渲染，```setTimout```和```setInterval```无法保证渲染时机。不要在定时器里面绑定事件。

### 4. 使用逻辑缓存

缓存```dom```对象，也就是用一个变量来存储```do```m对象，不要每次使用都查询。

缓存列表长度，也就是说用变量存储```dom```元素的个数，而不是每次都重新计算。

比如百度```M```站，会把页面的```css```和```js```放在本地存储里面，这样后面再加载的时候就直接从本地存储里面取，实现秒考的效果。不过本地存储空间有限，要谨慎使用。

## 6. 减少页面回流和重绘

### 1. css

避免过多的样式嵌套，最好可以快速的定位到元素。

避免使用```css```表达式，```css```表达式会在```css```绘制的过程中都会执行，会增加重排和回流的次数。

可以使用绝对定位让动画元素脱离文档流。

避免使用```table```布局他会引起浏览器的多次重绘，也不要使用```float```布局。

图片最好设置好设置```width```和```height```，这样图片在加载之后布局就可以确定了。

简化浏览器不必要额任务，使用```viewport```设置屏幕缩放级别。

避免频繁设置样式，将多个样式操作合并修改,一次性的更新。

### 2. js

为了减少回流发生次数，应该避免频繁操作``DOM``，可以合并多次对```DOM```的修改，一次性批量处理。

控制绘制过程和绘制区域，绘制过程开销比较大的属性设置应当避免使用。

## 7. 简化DOM操作

众所周知，页面交互卡顿和流畅度很大一部分原因就是页面有大量```DOM```元素，想想一下，从一个上万节点的```DOM```树上，使用```querySelectorAll```或```getElementByTagName```方法查找某一个节点，是非常耗时的，另外元素绑定事件时，事件冒泡和事件捕获的执行也会相对耗时。所以一般我们应该