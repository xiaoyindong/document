## 1. margin

```margin-top```如果为负，元素向上移动

```margin-left```如果为负，元素向左移动

```margin-right```如果为负，布局单元向左，元素自身不动，后面元素向左。

```margin-bottom```如果为负，布局单元上移，自身元素展示不变。下面元素向上。

## 2. 什么是HTML语义化

```html```众多的标签中每一种标签都会代表一种单独的意思，例如```h1-h6```表示标题，```ul```和```ol```表示列表，```p```标签表示段落，```strong```标签表示强调。```a```标签表示超链接，```img```标签表示媒体图片。

每一种标签都有自己的一种意思，```html```是给计算机浏览器看的，在一个页面中每个部分要表示的意思需要通过对应的标签来告诉浏览器。这样更加方便浏览器理解网站的构造方便```SEO```(搜索引擎抓取网站的主要内容)。同时语义化标签也可以让其他人看懂你的布局结构。

## 3. 块级元素和内联元素

块级元素会独占一行，常见的有```display```属性为```block```和```table```的元素，例如```div```,```p```,```table```,```ul```,```ol```。

内联元素一般不会独占一行，如果空间足够会一直向后追加直到外层的宽度包容不下的时候才会换行。常见的有```display```属性为```inline```和```inline-block```的元素，例如```span```,```img```, ```input```, ```button```,```a```等。

## 4.BFC

```BFC```全称是块级格式化上下文，这东西面试的时候很多人也喜欢问，网上解释他的文章一搜一大堆，但就是说不到点子上饶了很大一圈反而更加让人云里雾里的。

其实```BFC```理解起来特别简单，对于```html```的布局来说有```Block```，```inline```，```inline-block```等。```BFC的```全称就是```Block format context```，与之对应的还有```Inline format context```简称IFC，```Inline-Block format contex```t简称```IBFC```。

```BFC```要说明的就是在一个独立的渲染区域内，这块区域内部的元素的渲染不会影响外部的元素。举个例子来说，例如一个```div```元素，假如他触发了```BFC```布局，那么它里面的元素如何布局都不会影响到这个```div```以外的元素布局。如果没有触发```BFC```如果```div```里面的内容太多会将```div```外侧的其他元素推开，如果触发了```BFC```那么```div```里面的元素即使多也不会改变```div```外部元素的布局。就是这个意思。

一般形成```BFC```的条件也很简单，脱离了文档流或者限制了布局大小。例如```float```不为```none```，也就是元素设置了浮动，浮动基本会离开原本的文档流，那么内部的元素无论如何变化都不在这个文档流中，也就影响不到文档中的其他元素。

元素设置了绝对定位和固定定位也会触发BFC，原因也是脱离了文档流。

元素设置了```overflow```不为```visible```会触发```BFC```，因为固定了大小，内部的变化都控制在了内部。元素设置了```dispaly```为```flex```或者```inline-block```也会触发```BFC```。

## 5. flex常用布局

### 1. flex-direction布局方向，横向还是纵向

```s
flex-direction: row|row-reverse|column|column-reverse|initial|inherit;
```
```row```水平显示，```flex-direction```的默认值

```row-reverse```与```row```相同，但是以相反的顺序

```column```垂直显示

```column-reverse```与```column```相同，但是以相反的顺序

### 2. justify-content对齐方向

```s
justify-content: flex-start|flex-end|center|space-between|space-around|initial|inherit;
```

```flex-start```默认值。位于容器的开头

```flex-end```位于容器的结尾

```center```位于容器的中心

```space-between```位于各行之间留有空白的容器内

```space-around```位于各行之前、之间、之后都留有空白

### 3. align-items交叉对齐方式

交叉对齐也就是如果```flex-direction```是横向```align-items```就是纵向，如果```flex-direction```是纵向```align-items```就是横向。

```s
align-items: stretch|center|flex-start|flex-end|baseline|initial|inherit;
```

```stretch```默认值。元素被拉伸以适应容器。如果指定侧轴大小的属性值为```auto```，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照```min/max-width/height```属性的限制


```center```元素位于容器的中心。弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。

```flex-start```元素位于容器的开头。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。

```flex-end```元素位于容器的结尾。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。

```baseline```元素位于容器的基线上。如弹性盒子元素的行内轴与侧轴为同一条，则该值与```flex-start```等效。其它情况下，该值将参与基线对齐。

### 4. flex-wrap换行设置

```s
flex-wrap: nowrap|wrap|wrap-reverse|initial|inherit;
```

```nowrap```默认值。不拆行或不拆列。

```wrap```在必要的时候拆行或拆列。

```wrap-reverse```在必要的时候拆行或拆列，但是以相反的顺序。

### 5. align-self子元素交叉对齐方式

```align-self```与```align-items```的区别是，```align-self```是对子元素进行设置，```align-items```是对父元素进行设置。虽然他俩的效果都是针对子元素，但是```align-self```更加灵活，可以针对每个子元素做不同的设置，```align-items```只能设置所有子元素。

```s
align-self: auto|stretch|center|flex-start|flex-end|baseline|initial|inherit;
```

```auto```默认值。元素继承了它的父容器的 ```align-items``` 属性。如果没有父容器则为 ```stretch```。

```stretch```元素被拉伸以适应容器。如果指定侧轴大小的属性值为```auto```，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照```min/max-width/height```属性的限制。

```center```元素位于容器的中心。弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。

```flex-start```元素位于容器的开头。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。

```flex-end```元素位于容器的结尾。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。

```baseline```元素位于容器的基线上。如弹性盒子元素的行内轴与侧轴为同一条，则该值与```flex-start```等效。其它情况下，该值将参与基线对齐。

## 6. line-height继承问题

当父级的```line-height```设置为具体数值的时候，则子元素集成的就是该数值。

```css
body {
    line-height: 24px;
    font-size: 15px;
}
p {
    font-size: 10px;
}
```

当父级的```line-height```设置的是比例的时候，子元素集成的就是比例。真实的值是比例乘以自己的```font-size```大小。假如自己的```font-size```为```10px```,继承的```line-height```就是```2*10```，```20px```。

```css
body {
    line-height: 2;
    font-size: 15px;
}
p {
    font-size: 10px;
}
```

当父级的```line-height```设置的是百分比的时候，子元素集成的是百分比乘以父级```font-size```的值。假如父级的```font-size```为```15px```,继承的```line-height```就是```200%*15px```，```30px```。

## 7. rem

对于移动端高速发展的今天，```rem```早已经不是一个陌生的概念。和```px```，```em```相同他是```css```布局的一个数值单位。

```em```是当前标签```font-size```的倍数。例如如果高度设置```2em```，```font-size```设置为```10px```。那么实际高度就是```2*10```，```20px```。

```css
p {
    height: 2em;
    font-size: 10px;
}
```

```rem```和```em```类似，不同的是```rem```的值取决于根元素，也就是```html```元素的```font-size```。

```css
html {
    font-size: 10px;
}
p {
    height: 2rem;
    font-size: 1.5rem;
}
```

可以通过```rem```布局来实现页面的响应式布局，做法也很简单，不同的手机根据屏幕大小来设置对应的```html```元素的```font-size```, 页面其他元素的布局都采用```rem```。这样针对于不同的手机屏幕页面内容展示也会进行相应的缩放。以适应整个屏幕。

## 8. vw/vh

```rem```并不是响应式布局的最终解决方案，它本身存在一些问题，上面说了```rem```的值是根据```html```根元素的```font-size```值来决定的，根元素的```font-size```值到底应该设置多少呢？这里并不知道。一般的实现方式有两种，一种是通过```js```获取到页面的宽度进行动态设置，但是```js```的加载一般都是在```css```之后的，这就会导致页面发生重新渲染。另一种方式是借助```media```媒体查询，针对不同的宽度设置不同的```font-size```。但是```media```是需要列举出来的，也就是所有的情况都要列出来，很不方便。

方式1根据屏幕宽度计算。

```js
var windowWidth = document.documentElement.clientWidt