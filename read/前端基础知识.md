## 1. margin

```margin-top```如果为负，元素向上移动

```margin-left```如果为负，元素向左移动

```margin-right```如果为负，布局单元向左，元素自身不动，后面元素向左。

```margin-bottom```如果为负，布局单元上移，自身元素展示不变。下面元素向上。

## 2. 什么是HTML语义化

```html```众多的标签中每一种标签都会代表一种单独的意思，例如```h1-h6```表示标题，```ul```和```ol```表示列表，```p```标签表示段落，```strong```标签表示强调。```a```标签表示超链接，```img```标签表示媒体图片。

每一种标签都有自己的一种意思，```html```是给计算机浏览器看的，在一个页面中每个部分要表示的意思需要通过对应的标签来告诉浏览器。这样更加方便浏览器理解网站的构造方便```SEO```(搜索引擎抓取网站的主要内容)。同时语义化标签也可以让其他人看懂你的布局结构。

## 3. 块级元素和内联元素

块级元素会独占一行，常见的有```display```属性为```block```和```table```的元素，例如```div```,```p```,```table```,```ul```,```ol```。

内联元素一般不会独占一行，如果空间足够会一直向后追加直到外层的宽度包容不下的时候才会换行。常见的有```display```属性为```inline```和```inline-block```的元素，例如```span```,```img```, ```input```, ```button```,```a```等。

## 4.BFC

```BFC```全称是块级格式化上下文，这东西面试的时候很多人也喜欢问，网上解释他的文章一搜一大堆，但就是说不到点子上饶了很大一圈反而更加让人云里雾里的。

其实```BFC```理解起来特别简单，对于```html```的布局来说有```Block```，```inline```，```inline-block```等。```BFC的```全称就是```Block format context```，与之对应的还有```Inline format context```简称IFC，```Inline-Block format contex```t简称```IBFC```。

```BFC```要说明的就是在一个独立的渲染区域内，这块区域内部的元素的渲染不会影响外部的元素。举个例子来说，例如一个```div```元素，假如他触发了```BFC```布局，那么它里面的元素如何布局都不会影响到这个```div```以外的元素布局。如果没有触发```BFC```如果```div```里面的内容太多会将```div```外侧的其他元素推开，如果触发了```BFC```那么```div```里面的元素即使多也不会改变```div```外部元素的布局。就是这个意思。

一般形成```BFC```的条件也很简单，脱离了文档流或者限制了布局大小。例如```float```不为```none```，也就是元素设置了浮动，浮动基本会离开原本的文档流，那么内部的元素无论如何变化都不在这个文档流中，也就影响不到文档中的其他元素。

元素设置了绝对定位和固定定位也会触发BFC，原因也是脱离了文档流。

元素设置了```overflow```不为```visible```会触发```BFC```，因为固定了大小，内部的变化都控制在了内部。元素设置了```dispaly```为```flex```或者```inline-block```也会触发```BFC```。

## 5. flex常用布局

### 1. flex-direction布局方向，横向还是纵向

```s
flex-direction: row|row-reverse|column|column-reverse|initial|inherit;
```
```row```水平显示，```flex-direction```的默认值

```row-reverse```与```row```相同，但是以相反的顺序

```column```垂直显示

```column-reverse```与```column```相同，但是以相反的顺序

### 2. justify-content对齐方向

```s
justify-content: flex-start|flex-end|center|space-between|space-around|initial|inherit;
```

```flex-start```默认值。位于容器的开头

```flex-end```位于容器的结尾

```center```位于容器的中心

```space-between```位于各行之间留有空白的容器内

```space-around```位于各行之前、之间、之后都留有空白

### 3. align-items交叉对齐方式

交叉对齐也就是如果```flex-direction```是横向```align-items```就是纵向，如果```flex-direction```是纵向```align-items```就是横向。

```s
align-items: stretch|center|flex-start|flex-end|baseline|initial|inherit;
```

```stretch```默认值。元素被拉伸以适应容器。如果指定侧轴大小的属性值为```auto```，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照```min/max-width/height```属性的限制


```center```元素位于容器的中心。弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。

```flex-start```元素位于容器的开头。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。

```flex-end```元素位于容器的结尾。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。

```baseline```元素位于容器的基线上。如弹性盒子元素的行内轴与侧轴为同一条，则该值与```flex-start```等效。其它情况下，该值将参与基线对齐。

### 4. flex-wrap换行设置

```s
flex-wrap: nowrap|wrap|wrap-reverse|initial|inherit;
```

```nowrap```默认值。不拆行或不拆列。

```wrap```在必要的时候拆行或拆列。

```wrap-reverse```在必要的时候拆行或拆列，但是以相反的顺序。

### 5. align-self子元素交叉对齐方式

```align-self```与```align-items```的区别是，```align-self```是对子元素进行设置，```align-items```是对父元素进行设置。虽然他俩的效果都是针对子元素，但是```align-self```更加灵活，可以针对每个子元素做不同的设置，```align-items```只能设置所有子元素。

```s
align-self: auto|stretch|center|flex-start|flex-end|baseline|initial|inherit;
```

```auto```默认值。元素继承了它的父容器的 ```align-items``` 属性。如果没有父容器则为 ```stretch```。

```stretch```元素被拉伸以适应容器。如果指定侧轴大小的属性值为```auto```，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照```min/max-width/height```属性的限制。

```center```元素位于容器的中心。弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。

```flex-start```元素位于容器的开头。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。

```flex-end```元素位于容器的结尾。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。

```baseline```元素位于容器的基线上。如弹性盒子元素的行内轴与侧轴为同一条，则该值与```flex-start```等效。其它情况下，该值将参与基线对齐。

## 6. line-height继承问题

当父级的```line-height```设置为具体数值的时候，则子元素集成的就是该数值。

```css
body {
    line-height: 24px;
    font-size: 15px;
}
p {
    font-size: 10px;
}
```

当父级的```line-height```设置的是比例的时候，子元素集成的就是比例。真实的值是比例乘以自己的```font-size```大小。假如自己的```font-size```为```10px```,继承的```line-height```就是```2*10```，```20px```。

```css
body {
    line-height: 2;
    font-size: 15px;
}
p {
    font-size: 10px;
}
```

当父级的```line-height```设置的是百分比的时候，子元素集成的是百分比乘以父级```font-size```的值。假如父级的```font-size```为```15px```,继承的```line-height```就是```200%*15px```，```30px```。

## 7. rem

对于移动端高速发展的今天，```rem```早已经不是一个陌生的概念。和```px```，```em```相同他是```css```布局的一个数值单位。

```em```是当前标签```font-size```的倍数。例如如果高度设置```2em```，```font-size```设置为```10px```。那么实际高度就是```2*10```，```20px```。

```css
p {
    height: 2em;
    font-size: 10px;
}
```

```rem```和```em```类似，不同的是```rem```的值取决于根元素，也就是```html```元素的```font-size```。

```css
html {
    font-size: 10px;
}
p {
    height: 2rem;
    font-size: 1.5rem;
}
```

可以通过```rem```布局来实现页面的响应式布局，做法也很简单，不同的手机根据屏幕大小来设置对应的```html```元素的```font-size```, 页面其他元素的布局都采用```rem```。这样针对于不同的手机屏幕页面内容展示也会进行相应的缩放。以适应整个屏幕。

## 8. vw/vh

```rem```并不是响应式布局的最终解决方案，它本身存在一些问题，上面说了```rem```的值是根据```html```根元素的```font-size```值来决定的，根元素的```font-size```值到底应该设置多少呢？这里并不知道。一般的实现方式有两种，一种是通过```js```获取到页面的宽度进行动态设置，但是```js```的加载一般都是在```css```之后的，这就会导致页面发生重新渲染。另一种方式是借助```media```媒体查询，针对不同的宽度设置不同的```font-size```。但是```media```是需要列举出来的，也就是所有的情况都要列出来，很不方便。

方式1根据屏幕宽度计算。

```js
var windowWidth = document.documentElement.clientWidth;
document.documentElement.style.fontSize = windowWidth / 7.5 + 'px';
```

方式2每种方式都需要列出来。

```css
@media screen and (min-width: 320px) {
    html{
        font-size:50px;
    }
}
@media screen and (min-width: 360px) {
    html{
        font-size:56.25px;
    }
}
@media screen and (min-width: 375px) {
    html{
        font-size:58.59375px;
    }
}
@media screen and (min-width: 400px) {
    html{
        font-size:62.5px;
    }
}
@media screen and (min-width: 414px) {
    html{
        font-size:64.6875px;
    }
}
```

可以看出来```rem```实现的响应式布局存在一些问题，但不可否认他是一种很好的响应式方案。

```wh```是将网页视口高度平分```100```份，```vw```是将网页视口宽度平分1```00```份。所以```vh```和```vw```的最大值都是```100```。

```css
p {
    height: 20vh;
    width: 40vw;
}

div {
    height: 20vmin;
    width: 40vmax;
}
```

视口高度就是常说的```innerHeight```，也就是抛开屏幕顶部和底部，显示网页内容的那部分高度。

```js
window.innerHeight
```

屏幕高度是整个屏幕的高度

```js
window.screen.height
```

```client```就是```body```的高度

```js
document.body.clientHeight
```

## 9. typeof

```typeof```可以判断基本数据类型，函数类型，引用类型，```null```类型，```symbol```类型以及```bigint```类型

```js
typeof 123; // number
typeof undefined; // undefined;
typeof true; // boolean;
typeof Symbol(); // symbol;
typeof null; // object;
typeof {}; // object;
typeof function() {}; // function;
typeof 11n // bigint;
```

## 10. 深拷贝代码实现

```js
function deepClone(obj) {
    obj = obj || {};
    // 不是对象也不是数组直接返回
    if (typeof obj !== 'object' || obj === null) {
        return obj;
    }
    var result = {}; // 默认设置为对象
    if (obj instanceof Array) { // 如果是数组
        result = [];
    }
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            // 递归获取值
            result[key] = deepClone(obj[key]);
        }
    }
    return result;
}
```

## 11. 原型和原型链

关于原型和原型链的表述都是我个人的理解，我自己也不知道对不对，但我确实是这么理解的。

很多人对原型和原型链的理解都是起源于```OOP```(面向对象)，出入门的开发者习惯用面向过程的方式编写js，当学习到一定程度的时候就会接触面向对象，以及面向对象中比较复杂的，封装，抽象，接口，继承，多态等概念。

其实面向对象也很好理解，它存在一个类的概念，我一般将类理解为一个模具，例如去超市买的一个蒸蛋器，有小熊的，小兔子的，这个模具刻画成什么样，用它蒸出来的鸡蛋饼就什么样。这里蒸蛋器就是类，蒸出来的鸡蛋饼就是类创建出来的对象。

可以用刀子叉子给这个蒸出来的鸡蛋改变样式，就像可以给类创建出来的对象增减方法属性，可以给这个蒸蛋器改变结构，那么重新蒸出来的鸡蛋饼就会使用新的样子，这种鸡蛋饼使用蒸蛋器样子的功能一般称为继承。就是类创建的对象具备类中的方法，并且每个创建的对象都是独立的，就像蒸了```10```个鸡蛋饼，每个鸡蛋饼都是独立的一样。

面向对象可以提高效率这是毋庸置疑的，因为他可以把一些公共的能力进行封装，使用的时候直接创建实例就可以了，如果没有蒸蛋器想要做```10```个相同的鸡蛋饼，那就复杂了，先做鸡蛋饼再使用刀子叉子整理成想要的样子，这种工作要重复```10```次而且还不一定保证做出来的鸡蛋饼相同。

有了蒸蛋器就不一样了，只需要花费蒸鸡蛋的时间而不需要关心蒸蛋器如何将鸡蛋饼做成想要的样子。

传统的面向对象语言例如```java```是自带类系统的，想要创建模具直接使用```class```关键字就可以了，但是对于```ECMAScript```来说他是一种基于原型对象的设计。习惯了使用面向对象开发的开发者们喜欢用原型对象来模拟面向对象。

面向对象首先会有一个构造函数，也就是使用```new```关键字实例化的时候执行的函数。```js```中通过```function```关键字来创建类对象，例如下面的```A```，由于```function```创建的是一个函数，所以这个函数也就作为了构造函数。在```A```这个类被```new```的时候会执行。

```js
function A () {
    console.log('创建A的实例')
}

var aaa = new A();
```

如果类中存在方法，那么被创建的实例中也会存在这个方法，前面说过```js```是基于原型对象设计的，所以会将类中的方法挂载原型对象上，```prototype```。这样创建出来的实例```aaa```也就具备了```say```这个方法。面向对象中函数称为方法，变量称之为属性。

```js

function A () {
    console.log('创建A的实例')
}

A.prototype.say = function() {
    console.log('say');
}

var aaa = new A();

aaa.say(); // say
```

这里的```prototype```称之为```A```的原型。可以被实例化的对象基本都有原型，数字```1```是```Number```的实例，就可以通过```Numer.prototype```访问```Number```的原型，```String.prototype```访问```String```对象的原型，```Date.prototype```访问```Date```对象的原型。不能实例化的对象例如```Math```就不存在原型。```Math.prototype```是个```undefined```。

可以通过在原型```prototype```的方式追加方法。例如说字符串不具备```say```的方法。可以给```String```追加```say```方法。

```js
String.prototype.say = function() {
    console.log('调用了say方法');
}
'abc'.say(); // 调用了say方法
```

对象中