## 1. 起因

今天被抓差给候选者进行初面。在这里记录一下面试中涉及的几个知识点。

每次面试我都会递给候选者一瓶水，这样可以让候选者没那么紧张，有更好的状态进行面试，毕竟面试是双向选择，公司也需要尽快找到合适的人，没那么多网上说的心理战。

这里我还想吐槽一下面试造火箭工作拧螺丝，尤其是开发行业，很多面试官针对自己擅长的方向大问特问，完全忽略了候选人的优势，从而给候选人带来一个极差的面试体验。面试最好还是要通过候选人身上的优点来判断对方是否适合加入你的团队。

正常的面试应该是按照候选人简历中涉及的技术点发问，不然面试时给你一份简历干嘛，至于简历中未涉及的知识点有没有必要问，我觉得没什么必要的，因为很多人在写简历的时候都是力求全面，恨不得听说过的知识点都写上熟悉。所以按照简历提问就可以了。除此之外再问一些最近流行的技术，主要考察的是候选人对新技术的敏感性和对新事物的接受能力。

如果其中涉及到候选人回答不上的问题也需要给候选人做一番解答，毕竟人家那么远来你这面试，总要有所收获不是。

最后在简历中挑选一个候选人比较擅长的点深入来问，这个环节我一般称为定级，前面的问题如果回答的不错，这个人基本就通过了，到最后就要给人定级。如果前面问题回答的不理想基本也到不了这个环节。

## 2. Proxy

在```2020```年来看```Proxy```早已经不是一个陌生的词了，他能做的是有很多，尤其在```Vue3.0```通过```Proxy```来重构之后，很多面试官喜欢问这个```Proxy```以及和```Object.defineProperty```的对比。

```Proxy```是专门为对象设置访问代理器的，通过```Proxy```可以轻松监视到对象的读写过程，相比于```defineProperty```，```Proxy```他的功能要更为强大甚至使用起来也更为方便。

这里我们定义一个```person```对象，我们通过```new Proxy```的方式来去为我们的```person```来创建一个代理对象。

```Proxy```构造函数的第一个参数就是我们需要代理的对象，这里是```person```，第二个参数也是一个对象，我们可以把这个对象称之为代理的处理对象，这个对象中可以通过```get```方法来去监视属性的访问，通过```set```方法来去介绍对象当中设置属性这样的一个过程。

```js
const person = {
    name: 'yd',
    age: 18
}

const personProxy = new Proxy(person, {
    get() {},
    set() {}
})
```

先来看```get```方法，这个方法最简单可以接收两个参数，第一个就是所代理的目标对象，第二个就是外部所访问的这个属性的属性名。这个方法的返回值将会作为外部去访问这个属性得到的结果。

```js
{
    get(target, property) {
        console.log(target, property);
        return property in target ? target[property] : undefined;
    }
}
```

再来看下```set```方法，这个方法默认接收三个参数, 分别是代理目标对象，以及我们要写入的属性名称还有最后我们要写入的属性值。
我们可以做一些校验，比如说如果设置的是```age```，他的值就必须是整数，否则就抛错。

```js
{
    set(target, property, value) {
        console.log(target, property, value);
        if (property === 'age') {
            if (!Number.isInteger(value)) {
                throw new TypeError(``${value} must be a integer);
            }
        }
        target[property] = value;
    }
}
```

相比于```Object.defineProperty```, ```Proxy```到底有哪些优势。

首先最明显的优势就是在于```Proxy```要更为强大一些，那这个强大具体体现在```Object.defineProperty```只能监听到对象属性的读取或者是写入，而```Proxy```除读写外还可以监听对象中属性的删除，对对象当中方法的调用等等。

第二点优势就是对于数组对象进行监视，通常我们想要监视数组的变化，基本要依靠重写数组方法，这也是Vue的实现方式，```proxy```可以直接监视数组的变化。以往我们想要通过```Object.defineProperty```去监视数组的操作最常见的方式是重写数组的操作方法，这也是```Vue.js```中所使用的方式，大体的方式就是通过自定义的方法去覆盖掉数组原型对象上的```push```，```shift```之类的方法，以此来劫持对应的方法调用的过程。

## 3. 对象的键支持什么类型

这个问题考察的是候选人的基础知识是否扎实。

很多人都会认为对象的键是字符串类型，如果在以前确实没错，但是```ES2015```版本中对象的键类型还可以是```Symbol```。

```js
const person = {
   	name: 'yd',
    [Symbol()]: 18
}
```

这也是引出下面的```Symbol```。

## 4. Symbol

在```ECMAScript2015```之前，对象的属性名都是字符串，而字符串是有可能会重复的。如果重复的话就会产生冲突。

以前解决这种问题最好的方式就是约定，但是约定的方式只是规避了问题并不是彻底解决了这个问题。如果在这个过程中有人不遵守约定那这个问题仍然会存在。

```ES2015```为了解决这个问题提供了一种全新的原始数据类型```Symbol```，翻译过来的意思叫做符号，翻译过来就是表示一个独一无二的值。
通过```Symbol```函数就可以创建一个```Symbol```类型的数据，而且这种类型的数据```typeof```的结果就是```symbol```，那这也