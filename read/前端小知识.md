## 1. JS为什么单线程

一个简单的原因就是，```js```在设计之初只是进行一些简单的表单校验，这完全不需要多线程，单线程完全可以胜任这项工作。即便后来前端发展迅速，承载的能力越来越多，也没有发展到非多线程不可的程度。

而且还有一个主要的原因，设想一下，如果```js```是多线程的，在运行时多个线程同时对```DOM```元素进行操作，那具体以哪个线程为主就是个问题了，线程的调度问题是一个比较复杂的问题。

```HTML5```新的标准中允许使用```new Worker```的方式来开启一个新的线程，去运行一段单独的```js```文件脚本，但是在这个新线程中严格的要求了可以使用的功能，比如说他只能使用```ECMAScript```, 不能访问```DOM```和```BOM```。这也就限制死了多个线程同时操作```DOM```元素的可能。

## 2. 使用css写出一个三角形角标

元素宽高设置为```0```，通过```border```属性来设置，让其它三个方向的```border```颜色为透明或者和背景色保持一致，剩余一条```border```的颜色设置为需要的颜色。

```css
div {
    width: 0;
    height: 0;
    border: 5px solid #transparent;
    border-top-color: red;
}
```

## 3. 水平垂直居中

我一般只使用两种方式```定位```或者```flex```，我觉得够用了。

```css
div {
    width: 100px;
    height: 100px;
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    margin: auto;
}
```

父级控制子集居中

```css
.parent {
    display: flex;
    justify-content: center;
    align-items: center;
}
```

## 4. css一行文本超出...

```css
overflow: hidden;
text-overflow:ellipsis;
white-space: nowrap;
```

## 5. 多行文本超出显示...

```css
display: -webkit-box;
-webkit-box-orient: vertical;
-webkit-line-clamp: 3;
overflow: hidden;
```

## 6. IOS手机容器滚动条滑动不流畅

```css
overflow: auto;
-webkit-overflow-scrolling: touch;
```

## 7. 修改滚动条样式

隐藏```div```元素的滚动条

```css
div::-webkit-scrollbar {
    display: none;
}
```

div::-webkit-scrollbar 滚动条整体部分

div::-webkit-scrollbar-thumb  滚动条里面的小方块，能向上向下移动（或往左往右移动，取决于是垂直滚动条还是水平滚动条）

div::-webkit-scrollbar-track  滚动条的轨道

div::-webkit-scrollbar-button 滚动条的轨道的两端按钮，允许通过点击微调小方块的位置。

div::-webkit-scrollbar-track-piece 内层轨道，滚动条中间部分

div::-webkit-scrollbar-corner 边角，即两个滚动条的交汇处

div::-webkit-resizer 两个滚动条的交汇处上用于通过拖动调整元素大小的小控件

注意此方案有兼容性问题，一般需要隐藏滚动条时我都是用一个色块通过定位盖上去，或者将子级元素调大，父级元素使用overflow-hidden截掉滚动条部分。暴力且直接。



## 8. 解决ios audio无法自动播放、循环播放的问题

```ios```手机在使用```audio```或者```video```播放的时候，个别机型无法实现自动播放，可使用下面的代码```hack```。

```js
// 解决ios audio无法自动播放、循环播放的问题
var music = document.getElementById('video');
var state = 0;

document.addEventListener('touchstart', function(){
    if(state==0){
        music.play();
        state=1;
    }
}, false);

document.addEventListener("WeixinJSBridgeReady", function () {
    music.play();
}, false);

//循环播放
music.onended = function () {
    music.load();
    music.play();
}
```

## 9. 隐藏页面元素

display-none: 元素不会占用空间，在页面中不显示，子元素也不会显示。

opacity-0: 元素透明度将为```0```，但元素仍然存在，绑定的事件仍旧有效仍可触发执行。

visibility-hidden：元素隐藏，但元素仍旧存在，占用空间，页面中无法触发该元素的事件。

## 10. 前端工程化

一提到前端工程化很多人想到的都是```webpack```，这是不对的，```webpack```仅仅是前端工程化中的一环。在整个工程化过程中他帮我们解决了绝大多数的问题，但并没有解决所有问题。

前端工程化是通过工具提升效率，降低成本的一种手段。

近些年