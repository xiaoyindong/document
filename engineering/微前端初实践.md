## 1. 概述

微前端是一种软件架构，可以将前端应用拆解成一些更小的能够独立开发部署的微型应用，然后再将这些微应用进行组合使其成为整体应用的架构模式。微前端架构类似于组件架构，但不同的是，组件不能独立构建和发布，但是微前端中的应用是可以的。微前端架构与框架无关，每个微应用都可以使用不同的框架。

### 1. 微前端的价值

1.增量迁移

迁移是一项非常耗时且艰难的任务，比如有一个管理系统使用```AngularJS```开发维护已经有三年时 间，但是随时间的推移和团队成员的变更，无论从开发成本还是用人需求上，```AngularJS```已经不能 满足要求，于是团队想要更新技术栈，想在其他框架中实现新的需求，但是现有项目怎么办?直接 迁移是不可能的，在新的框架中完全重写也不太现实。

使用微前端架构就可以解决问题，在保留原有项目的同时，可以完全使用新的框架开发新的需求，然后再使用微前端架构将旧的项目和新的项目进行整合。这样既可以使产品得到更好的用户体验，也可以使团队成员在技术上得到进步，产品开发成本也降到的最低。

2.独立发布

在目前的单页应用架构中，使用组件构建用户界面，应用中的每个组件或功能开发完成或者```bug```修复完成后，每次都需要对整个产品重新进行构建和发布，任务耗时操作上也比较繁琐。

在使用了微前端架构后，可以将不能的功能模块拆分成独立的应用，此时功能模块就可以单独构建单独发布了，构建时间也会变得非常快，应用发布后不需要更改其他内容应用就会自动更新，这意味着你可以进行频繁的构建发布操作了。

3.允许单个团队做出技术决策

因为微前端构架与框架无关，当一个应用由多个团队进行开发时，每个团队都可以使用自己擅长的技术栈进行开发，也就是它允许适当的让团队决策使用哪种技术，从而使团队协作变得不再僵硬。

微前端一般的使用场景包括拆分矩形应用，使应用变得更加可维护，兼容历史应用，实现增量开发。

### 2. 如何实现微前端

1.多个微应用如何进行组合

在微前端架构中，除了存在多个微应用以外，还存在一个容器应用，每个微应用都需要被注册到容器应用中。微前端中的每个应用在浏览器中都是一个独立的```JavaScript```模块，通过模块化的方式被容器应用启 动和运行。使用模块化的方式运行应用可以防止不同的微应用在同时运行时发生冲突。

2.在微应用中如何实现路由

在微前端架构中，当路由发生变化时，容器应用首先会拦截路由的变化，根据路由匹配微前端应用，当匹配到微应用以后，再启动微应用路由，匹配具体的页面组件。

3.微应用与微应用之间如何实现状态共享

在微应用中可以通过发布订阅模式实现状态共享，比如使用```RxJS```。

4.微应用与微应用之间如何实现框架和库的共享

通过```import-map```和```webpack```中的```externals```属性。


## 2. Systemjs

```Systemjs```是一个动态模块加载器，在微前端架构中每一个微应用都会被打包成模块，需要在浏览器中加载他并且运行他，但浏览器并不支持模块化，需要使用```systemjs```来实现浏览器中的模块化。```systemjs```是一个用于实现模块化的```js```库，有属于自己的模块化规范，在开发阶段可以使用```ES```模块规范，然后使用```webpack```将其转换为```systemjs```支持的模块。

比如可以通过```webpack```将```react```应用打包为```systemjs```模块，再通过```systemjs```在浏览器中加载模块。

```s
npm install webpack@5.17.0 webpack-cli@4.4.0 webpack-dev-server@3.11.2 html-webpack-
plugin@4.5.1 @babel/core@7.12.10 @babel/cli@7.12.10 @babel/preset-env@7.12.11
@babel/preset-react@7.12.10 babel-loader@8.2.2
```

```json
// package.json
{
	"name": "systemjs-react",
		"scripts": {
		"start": "webpack serve"
	},
	"dependencies": {
		"@babel/cli": "^7.12.10",
		"@babel/core": "^7.12.10",
		"@babel/preset-env": "^7.12.11",
		"@babel/preset-react": "^7.12.10",
		"babel-loader": "^8.2.2",
		"html-webpack-plugin": "^4.5.1",
		"webpack": "^5.17.0",
		"webpack-cli": "^4.4.0",
		"webpack-dev-server": "^3.11.2"
	}
}
```

首先需要在```webpack```配置的输出位置，指定打包使用```system```模块。还要使用```externals```将公共模块排除。因为微前端中公共模块都是公共的比如```react```、```react-dom```。

```js
// webpack.config.js
const path = require("path")
const HtmlWebpackPlugin = require("html-webpack-plugin")
module.exports = {
	mode: "development",
	entry: "./src/index.js",
	output: {
		path: path.join(__dirname, "build"),
		filename: "index.js",
		libraryTarget: "system"
	},
	devtool: "source-map",
	devServer: {
		port: 9000,
		contentBase: path.join(__dirname, "build"),
		historyApiFallback: true
	},
		module: {
		rules: [
			{
				test: /\.js$/,
				exclude: /node_modules/,
				use: {
					loader: "babel-loader",
					options: {
						presets: ["@babel/preset-env", "@babel/react"]
					}
				}
			}
		]
	},
	plugins: [
		new HtmlWebpackPlugin({
			inject: false,
			template: "./src/index.html"
		})
	],
	externals: ["react", "react-dom", "react-router-dom"]
}
```

在页面中通过```script```的方式将```system```引入进来。然后就可以使用system动态引入```react```，```react-dom```以及```react-router-dom```，使用方式就是添加一个```type```值为```systemjs-importmap```的```system```模块，```systemjs-importmap```是```system```提供的，不是浏览器原生的。在```script```中添加的对象就会自动添加到```system```系统中。

还有就是不能通过```webpack```将打包后的```js```注入到页面中，应该使用```system```加载进来。在```body```中添加```script```标签里面写上```System.import```导入模块。

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>systemjs-react</title>
    <script type="systemjs-importmap">
      {
        "imports": {
          "react": "https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",
          "react-dom": "https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js",
          "react-router-dom": "https://cdn.jsdelivr.net/npm/react-router-dom@5.2.0/umd/react-router-dom.min.js"
				}
			}
		</script>
    <script src="https://cdn.jsdelivr.net/npm/systemjs@6.10.3/dist/system.min.js"></script>
	</head>
  <body>
    <div id="root"></div>
    <script>
      System.import("./index.js")
    </script>
  </body>
</html>
```

这就是```system.js```的基本使用。

## 3. Single-Spa

```single-spa```是一个实现微前端架构的框架，在```single-spa```框架中有三种类型的微前端应用。

1.```single-spa-application/parcel```微前端架构中的微应用，可以使用```vue```、```react```、```angular```等框架。```single-spa-application```和路由相关联，```single-spa-parcel```不和路由相关联，主要用于跨应用共享```UI```组件的。

2.```single-spa root config```是微前端架构中的容器应用，主要管理微应用的，用于创建微前端容器应用。

3.```utility modules```是公共模块应用，不是用于渲染组件的，是用于跨应用共享```javascript```逻辑的微应用。

### 1. 创建容器应用

首先需要安装```single-spa```脚手架工具。

```s
npm install create-single-spa@2.0.3 -g

# 创建微前端应用目录
mkdir workspace
# 进入目录
cd workspace
# 创建微前端容器应用
create-single-spa
```

应用文件夹填写```container```，应用选择```single-spa root config```，接着选择```npm```安装依赖，不使用```TS```就输入```N```，同样不适应布局引擎，输入```N```，组织名称填写```yindong```，组织名称可以理解为团队名称，微前端架构允许多团队共同开发应用，组织名称可以标识应用由哪个团队开发。应用名称的命名规则为```@组织名称/应用名称```，比如```@yindong/todos```。初始化之后就可以启动应用了。

```s
# 启动应用
npm run start
```
接着可以看下创建好的容器应用相关代码，```src```是开发的目录默认会有```index.ejs```和```study-root-cofig.js```两个文件，```index.ejs```是模板文件并且再整个应用中只有这一个模板文件，其他微应用是不包含模板文件的，```study-root-config.js```是容器应用的入口文件。

首先可以看下```study-root-config.js```文件，这里引入了```registerApplication```和```start```两个方法，```registerApplication```是用来注册微应用的，``