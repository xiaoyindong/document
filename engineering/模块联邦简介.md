## 1. 概述

模块联邦(```Module Federation```)是```Webpack 5```中新增的一项功能，可以实现跨应用共享模块。比如有```AB```两个应用，```A```应用中提供```fromA```方法，```B```应用提供了```fromB```方法，现在需要在```A```应用中调用```B```应用的方法，```B```应用中调用```A```应用的方法。这就涉及到了跨应用调用方法，就需要用到模块联邦啦。通过这样的方式就可以实现微前端啦。

这里通过一个案例进行演示，创建三个应用，一个容器应用，两个微应用，在容器应用中使用这两个微应用，项目结构如下。三个应用的结构基本相同。

```s
products
    ├── package-lock.json
    ├── package.json
    ├── public
    │   └── index.html
    ├── src
    │   └── index.js
    └── webpack.config.js
```

## 2. 案例演示

```json
{
  "name": "container",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "webpack serve"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "faker": "^5.2.0",
    "html-webpack-plugin": "^4.5.1",
    "webpack": "^5.19.0",
    "webpack-cli": "^4.4.0",
    "webpack-dev-server": "^3.11.2"
  }
}
```

在入口```JavaScript```文件中加入产品列表也就是```src/index.js```文件。首先引入```faker```，他是用来随机生成数据的，不用自己造数据了，然后将生成的数据添加到页面中。

```js
import faker from "faker"
let products = ""
for (let i = 1; i <= 5; i++) {
  products += `<div>${faker.commerce.productName()}</div>`
}
document.querySelector("#dev-products").innerHTML = products
```

在入口```html```文件中加入渲染的```div```。

```html
<div id="dev-products"></div>
```

webpack 配置。

```js
const HtmlWebpackPlugin = require("html-webpack-plugin")
module.exports = {
  mode: "development",
  devServer: {
    port: 8081 
	},
	plugins: [
			new HtmlWebpackPlugin({
				template: "./public/index.html"
			})
	] 
}
```

应用启动之后会运行在```8081```端口。

## 3. 使用模块联邦

要使用模块联邦首先需要导入```ModuleFederationPlugin```模块，他是```webpack```内置的模块，不需要额外安装。

可以通过new实力换模块联邦插件，可以传入一个配置项。```filename```模块文件名称，```name```是模块名称，```exposes```指定导出的文件。

```js
// webpack.config.js
// 导入模块联邦插件
const ModuleFederationPlugin = require("webpack/lib/container/ModuleFederationPlugin")
// 将 products 自身当做模块暴露出去 
new ModuleFederationPlugin({
	// 模块文件名称, 其他应用引入当前模块时需要加载的文件的名字 
	filename: "remoteEntry.js",
	// 模块名称, 具有唯一性, 相当于 single-spa 中的组织名称 
	name: "products",
	// 当前模块具体导出的内容 
	exposes: {
		"./index": "./src/index"
	}
})
```

在容器应用的中导入产品列表微应用，同样实例化```ModuleFederationPlugin```传入参数。```remotes```是要引入的模块。@前面是模块```name```，后面是```remoteEntry.js```就是```filename```。

```js
// webpack.config.js
// 导入模块联邦插件
const ModuleFederationPlugin = require("webpack/lib/container/ModuleFederationPlugin")
new ModuleFederationPlugin({ 
	name: "container",
	// 配置导入模块映射
	remotes: {
		// 字符串 "products" 和被导入模块的 name 属性值对应
		// 属性 products 是映射别名, 是在当前应用中导入该模块时使用的名字 
		products: "products@http://localhost:8081/remoteEntry.js"
	}
})
```

配置之后就可以加载微应用了，通过```import```加载。```products```就是```remotes```中的```remotes```，```index```就是微应用```exposes```中的```index```。

```js
// src/index.js
// 因为是从另一个应用中加载模块, 要发送请求所以使用异步加载方式 
import("products/index").then(products 