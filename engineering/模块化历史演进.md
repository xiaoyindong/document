## 1. 概述

模块化开发是当下最重要的前端开发规范之一，随着项目需求日益复杂，前端代码已经膨胀到需要花费大量时间去管理的程度，模块化是最主流的解决方式，通过将代码按照功能进行拆分，从而降低开发复杂度。

模块化是一种理论思想，并不包含具体的实现，早期的前端技术标准并没有预料到前端会有今天这样的一个规模，所以在设计上的遗留问题导致实现前端模块化存在着很多的问题，虽然这些问题已经被新推出的标准和方法掩埋了，但是这个掩埋的过程还是值得学习和思考的。这有利于更加的了解前端领域。

## 2. 第一阶段

第一阶段是以文件拆分的方式实现模块化，这也是```web```中最原始的模块系统，开发时拆分不同的```js```文件，在```html```中引入所有的```js```依次执行。

```html
<body>
    <script src="module_A.js"></script>
    <script src="module_B.js"></script>
    <script src="module_C.js"></script>
</body>

```

这样方式存在的最大问题就是代码会污染全局作用域，所有的代码都在全局工作，没有一个私有空间，导致模块中的内容都可以在模块外被访问和修改。

由于代码运行在全局作用域也就存在很多的命名冲突问题。模块无法管理各自的依赖关系，早期模块化完全依靠约定，项目到一定体量的时候就无法维持了，所以出现各种各样奇怪的命名或者代码。

## 3. 第二阶段

第二阶段约定每个模块只暴露一个全局对象，所有的模块成员都挂载在这个对象下面。

具体的实现是在第一个阶段的基础上，将每个模块包裹成一个全局对象的方式，类似于在模块内为模块中的成员添加了命名空间的感觉，通过命名空间的方式可以减小命名冲突的问题，但是仍旧没有私有空间，模块成员可以在外部被访问和修改，模块间的依赖关系也没有被解决。

```javascript
var module_A = { // 所有的成员都挂在module_A这个对象上。
    name: 'yd',
    age: 18,
}
```

```html
<script src="module_A.js"></script>
<script>
    module_A.name; // yd 可以被访问
    module_A.name = 'zd'; // 可以被修改
    module_A.name; // zd
</script>
```

## 4. 第三阶段

第三阶段解决了私有空间的问题，具体实现是将每一个模块中所有的内容放到一个函数的私有作用域中，将需要对外暴露的成员，通过挂载全局对象的方式实现。

```js
;(function() {
    var name = 'yd';
    var age = 18;
    window.module_A = {
        name: name,
        age: age
    }
})()
```

这种方式实现了私有成员的概念，私有成员只能在内部通过闭包的方式去访问，而在外部是没办法使用的，这就确保了私有变量的安全。自执行函数的参数可以作为依赖声明去使用，这使得每个模块之间的依赖关系实现十分明显。比如使用```jQuery```就接收```jQuery```参数，这样在后期维护的时候，就可以知道，想要使用该模块就要引入```jQuery```。

```js
;(function($) {
    var name = 'module_A';
    function setBackColor() {
        $('body').css({ backgroundColor: 'yellow'});
    }
    window.module_A = {
        name: name,
        setBackColor, setBackColor
    }
})(jQuery)
```

这种方法是早起在没有工具和规范的情况下，对模块化思想的落地方式，解决了前端领域在模块化遇到的各种各样的问题。

## 5. 模块化规范的出现

以上的方式都是以原始的模块内容为基础，通过约定的方式实现模块化，这些方式在不同的开发者去实施的时候会有一些细微的差别，为了统一不同的开发者和不同项目之间的差异。需要一个标准去规范模块化的实现方式。

在模块化中针对模块化的加载问题以上这几种方式，都是通过```script```标签手动引入的，意味着加载并不受代码控制，一旦时间久了，维护起来就非常麻烦，可能存在使用的模块忘记引入，移除模块忘记移除，这些都会产生很大的问题。

## 6. CommonJS

```CommonJS```是```NodeJS```提出的一套模块化标准，在```NodeJS```中所有模块必须要遵守```CommonJS```规范，这个规范约定了:

1.一个文件就是一个模块

2.每个模块都有独立的作用域

3.通过module.exports 导出成员

4.通过require函数载入模块。

想在浏览器中使用该规范是有问题的，```CommonJS```以同步的模式加载模块的，因为```Node```执行机制是在启动时加载模块，执行过程中不需要加载模块只会使用模块。

这种方式在```Node```中没有问题。但是在浏览器端使用```CommonJS```规范必然导致效率低下，因为每次页面加载都会导致大量同步请求出现，所以说早期前端模块化中，并没有选择```CommonJS```这种规范。而是专门为浏览器端，针对浏览器特点重新设计了一个规范。

```js
// 定义模块math.js
var basicNum = 0;
function add(a, b) {
  return a + b;
}
module.exports = { //在这里写上需要向外暴露的函数、变量
  add: add,
  basicNum: basicNum
}

/** 必须加./路径，不加的话只会去node_modules文件找 **/
// 引用自定义的模块时，参数包含路径，可省略.js
var math = require('./math');
math.add(2, 5);

// 引用核心模块时，不需要带路径
var http = require('http');
http.createService(...).listen(3000);
```

```exports```对于本身来讲是一个变量（对象），它不是```module```的引用，它是```{}```的引用，它指向```module.exports```的```{}```模块。只能使用```.```语法 向外暴露变量。

```js
exports.name = "yd";
```

```module```是一个变量，指向一块内存，```exports```是```module```中的一个属性，存储在内存中，然后```exports```属性指向```{}```模块。既可以使用```.```语法，也可以使用```=```直接赋值。

```js

module.exports.name = "yd";

module.exports = {
    name: 'yd'
}
```

## 7. AMD

```Asynchronous Module Definition```异步的模块定义规范，同期也推出了```requireJS```库实现了```AMD```规范，本身也是一个强大的模块加载器。

在```AMD```规范中，每个模块要通过```define```方式定义，可以传递三个参数，第一个参数是当前模块的名字，供其他模块引入使用，第二个参数是一个数组，声明依赖哪些模块，第三个参数是回调函数，依赖加载完成之后，执行该函数，函数中的参数为对应的模块对象。函数的返回值为当前模块被其他模块引用时的导出内容。

```js
define('module1', ['jQuery', './module2'], function($, module2) {
    return {
        start: function() {
            $('body').css({ backgroundColor: 'yellow'});
            module2();
        }
    }
})
```

模块加载使用```require```，用法和```define```类似，只是接收两个参数，第一个参数是依赖的模块数组，第二个参数为回调函数。