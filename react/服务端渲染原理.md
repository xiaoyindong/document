## 1. 概述

服务端渲染也就是常说的SSR，相信很多同学都听过这个概念，这里还是要简单说一下，为了文章前面的概念对齐。

### 1. 客户端渲染

在近十年的前端开发领域，逐渐向着客户算渲染迁移也就是CSR(Client Side Rendering)，对于新入行的前端同学可能一开始接触的就是客户端渲染。尤其是在React, Vue，Angular大行其道的今天。用户在浏览器输入URL地址，浏览器加载到页面的html，js，css，再通过ajax将数据请求得到绘制页面布局，最后将页面显示出来。可以发现页面整体布局第一次渲染的这个过程是在客户端进行的。假设浏览器禁止了页面js执行你会发现html将是一个没有内容的空body结构。

客户端渲染可以说是前后端分离的产物，也是ajax发展的最佳实践产物，但同时他也存在两个问题，一个是SEO并不友好，搜索引擎在抓取页面的时候是不会去执行js的，会通过拿到的html内容对网站进行分析，显然拿到的空body导致html没有任何内容，也就没办法给网站定位排名。第二个问题是白屏时间，网站最开始给用户显示的是一个空白页面，当数据加载出来之后会重新绘制页面，这个加载的过程需要时间，而且取决于接口的速度和页面渲染速度。如果接口过慢页面白屏时间就会很长。

### 2. 服务端渲染

服务端渲染简称SSR(Server Side Rendering)，也就是服务端进行页面的首屏渲染，数据获取和HTML的构建全都放在服务器中，这样客户端浏览器得到的直接就是一个完整结构的html。SEO可以抓取到更多的信息，浏览器也就渲染也会加快，比较网络请求回来的数据直接进行渲染就可以了，避免了空白的等待时间。

服务端渲染可能是个新概念，但背后的原理其实很古老。在web初代前后端分工不明朗的时期就是这样的开发方式。现如今的一些老系统中肯定也有这样的代码在。

目前主流的服务器端渲染框架有针对于Vue的Nuxt.js和针对React的Next.js这两个。这里并不是介绍这两个框架的使用方式，而是从零开始完整搭建一套SSR框架，来熟悉他的底层原理。让你能更好的了解到底什么是服务端渲染。

## 2. 演示环境搭建

首先初始化一个项目然后安装react，express，webpack，webpack-cli，webpack-node-externals install babel-loader babel-core babel-preset-react babel-preset-stage-0 babel-preset-env等项目依赖。

```s
npm react，express，webpack，webpack-cli，webpack-node-externals install babel-loader babel-core babel-preset-react babel-preset-stage-0 babel-preset-env --save
```

### 1. 配置webpack

安装完成之后配置webpack.server.js文件。

这里的这个webpack是运行在服务端也就是node端的，需要添加一个target为node的键值对。

众所周知在服务器端如果使用path路径是不需要打包到js中的，如果在浏览器端使用了path是需要打包到js中的，所以在服务器端和在浏览器端需要编译出来的js是完全不同的。所以这里在打包的时候要告诉webpack打包的是服务器端的代码还是浏览器端的代码，使用webpack-node-externals模块来标识。

entry入口文件就是node的启动文件，这里写成./src/server/index.js，输出的output文件名称为bundle，目录在跟目录的build文件夹中。

```js
const Path = require('path');
const NodeExternals = require('webpack-node-externals'); // 服务端运行webpack需要运行NodeExternals, 他的作用是将express这类node模块不被打包到js里。

module.exports = {
    target: 'node',
    mode: 'development',
    entry: './src/server/index.js',
    output: {
        filename: 'bundle.js',
        path: Path.resolve(__dirname, 'build')
    },
    externals: [NodeExternals()],
    module: {
        rules: [
            {
                test: /.js?$/,
                loader: 'babel-loader',
                exclude: /node_modules/,
                options: {
                    presets: ['react', 'stage-0', ['env', {
                        targets: {
                            browsers: ['last 2 versions']
                        }
                    }]]
                }
            }
        ]
    }
}
```

### 2. 编写入口文件

接着基于express模块来编写一个简单的服务。./src/server/index.js

创建了一个端口为3000的express服务，并且引入了一个React组件Home，引入这个组件的目的是为了让他参与编译，但是并没有让他参与渲染。

```js
var express = require('express');
var app = express();
const Home = require('../Components/Home');
app.get('*', function(req, res) {
    res.send(`<h1>hello</h1>`);
})
var server = app.listen(3000);
```

### 3. 编写第一个组件

编写.src/components/Home/index.js组件

```js
import React from 'react';

const Home = () => {
    return <div>home</div>
}

export default Home;
```

### 4. 编译运行

通过上面webpack.server.js的入口文件知道，这个js包含了一个React组件，一个端口为3000的express服务器，运行webpack打包的时候，他编译出来的js文件就具备这样的功能。

```s
webpack --config webpack.server.js
```

打包之后在目录下会出现一个bundle.js，这个js就是打包生成的最终可以运行的代码。可以使用node运行这个文件, 这样就启动了一个3000端口的服务器。访问127.0.0.1:3000可以访问这个服务，当你访问的时候会看到浏览器输出Hello了。也就是express服务器send的内容。

```s
node ./build/bundle.js
```

### 5. 渲染React组件

在/src/server/index.js中可以使用Home组件，这里首先需要安装react-dom，借助renderToString方法将Home组件转换为标签字符串，当然这里需要依赖React所以需要引入React。

```js
import express from 'express';
import Home from '../Components/Home';
import React from 'react';
import { renderToString } from 'react-dom/server';

const app = express();
const content = renderToString(<Home />);
app.get('*', function(req, res) {
    res.send(`
        <html>
            <body>${content}</body>
        </html>
    `);
})

var server = app.listen(3000);
```

重新打包运行

```s
# 重新打包
webpack --config webpack.server.js
# 运行服务
node ./build/bundle.js
```

这时候页面就显示出了React组件的代码。

### 6. 配置启动命令

React的服务端渲染是建立在虚拟DOM上的服务器端渲染，而且服务端渲染会让页面的首屏渲染速度大大加快。不过服务端渲染也有弊端，客户端渲染React代码在浏览器端执行，他消耗的是用户浏览器端的性能，但是服务器端渲染消耗的是服务器端的性能，因为React代码在服务器上运行。极大的消耗了服务器的性能，因为React代码是很消耗计算性能的。

如果你的项目完全没有必要使用SEO优化并且你的项目访问速度已经很快了的情况下，建议还是不要使用SSR的技术了，因为他的成本开销还是比较大的。

上面的代码每次修改之后都需要重新执行webpack打包和启动服务器，这样调试起来太过麻烦，为了解决这个问题，需要做一下webpack的自动打包和node的重启。在package.json中加入build命令，并且通过--watch监听文件变化进行自动打包。

```json
{
    ...
    "scripts": {
        "build": "webpack --config webpack.server.js --watch"
    }
    ...
}
```

仅仅重新打包还不够，还需要重启node服务器，这里需要借助nodemon模块，全局安装nodemon, 在package.json文件中添加一个start命令来启动node服务器。使用nodemon监听build文件并且发生改变之后重新exec运行"node ./build/bundle.js", 这里需要保留双引号，转译一下就好了。

```json
{
    ...
    "scripts": {
        "start": "nodemon --watch build --exec node \"./build/bundle.js\"",
        "build": "webpack --config webpack.server.js --watch"
    }
    ...
}
```

启动服务器，这里需要在两个窗口运行下面的命令，因为build后不允许再输入其他命令了。

```s
npm run build
npm run start
```

修改代码之后页面就会自动更新了。

但是上面的流程还是有些麻烦，需要两个窗口来执行命令，想要一个窗口将两个命令执行完毕，需要借助一个第三方模块npm-run-all，可以全局安装这个模块。然后再package.json中来修改一下。

打包和调试应该是在开发环境，这里需要创建一个dev命令, 里面执行npm-run-all, --parallel表示并行执行, 执行dev:开头的所有命令。将start和build前面追加一个dev:，这个时候我想启动服务器同时监听文件改变运行npm run dev就可以了。

```json
{
    ...
    "scripts": {
        "dev": "npm-run-all --parallel dev:**",
        "dev:start": "nodemon --watch build --exec node \"./build/bundle.js\"",
        "dev:build": "webpack --config webpack.server.js --watch"
    }
    ...
}
```

## 3. 项目结构

### 1. SSR同构

同构指的是代码复用. 即实现客户端和服务器端最大程度的代码复用，可以简单的理解同构就是让服务端和客户端执行一套代码，而不是分别针对两端写两套代码。

比如下面的代码，给div绑定一个click事件，希望点击的时候可以弹出click提示。但是运行之后会发现这个事件并没有被绑定上，因为html是在服务器端渲染的，而服务端没办法绑定事件毕竟绑定事件是dom行为。

src/components/Home/index.js

```js
import React from 'react';

const Home = () => {
    return <div onClick={() => { alert('click'); }}>home</div>
}

export default Home;
```

一般的做法是先将页面渲染出来，然后将相同的代码在浏览器端像传统的React项目一样再去运行一遍，这样的话这个点击事件就有了。

这就衍生出一个同构的概念，我的理解是一套React代码在服务器端执行一次，在客户端再执行一次。

同构就可以解决点击事件无效的问题，首先服务器端执行一次能够正常的展示页面，客户端再执行一次就可以绑定上事件。

可以在页面渲染的时候加载一个index.js, 使用app.use创建静态文件的访问路径, 这样访问的index.js就会请求到/public/index.js文件中。

```js

app.use(express.static('public'));

app.get('/', function(req, res) {
    res.send(`
        <html>
            <body>
                <div id="root">${content}</div>
                <script src="/index.js"></script>
            </body>
        </html>
    `);
})
```

public/index.js编写。

```js
console.log('public');
```

基于这种情况可以将React代码在浏览器中执行一次，新建一个/src/client/index.js。将客户端执行的代码帖进去。同构代码使用hydrate代替render。

```js
import React from 'react';
import ReactDOM from 'react-dom';

import Home from '../Components/Home';

ReactDOM.hydrate(<Home />, document.getElementById('root'));
```

### 2. 客户端配置

还需要在根目录创建一个webpack.client.js文件。入口文件为./src/client/index.js，出口文件到public/index.js

```js
const Path = require('path');

module.exports = {
    mode: 'development',
    entry: './src/client/index.js',
    output: {
        filename: 'index.js',
        path: Path.resolve(__dirname, 'public')
    },
    module: {
        rules: [
            {
                test: /.js?$/,
                loader: 'babel-loader',
                exclude: /node_modules/,
                options: {
                    presets: ['react', 'stage-0', ['env', {
                        targets: {
                            browsers: ['last 2 versions']
                        }
                    }]]
                }
            }
        ]
    }
}
```

package.json文件中添加一条打包client目录的命令

```json
{
    ...
    "scripts": {
        "dev": "npm-run-all --parallel dev:**",
        "dev:start": "nodemon --watch build --exec node \"./build/bundle.js\"",
        "dev:build": "webpack --config webpack.server.js --watch",
        "dev:build": "webpack --config webpack.client.js --watch",
    }
    ...
}
```

这样启动的时候会编译client运行的文件。再去访问页面的时候就可以绑定好事件了。

### 3. webpack整理

对上面工程的代码进行整理，上面webpack.server.js和webpack.client.js文件有很多重复的地方，使用webpack-merge插件对内容进行合并。

webpack.base.js

```js
module.exports = {
    module: {
        rules: [
            {
                test: /.js?$/,
                loader: 'babel-loader',
                exclude: /node_modules/,
                options: {
                    presets: ['react', 'stage-0', ['env', {
                        targets: {
                            browsers: ['last 2 versions']
                        }
                    }]]
                }
            }
        ]
    }
}
```

webpack.server.js

```js
const Path = require('path');
const NodeExternals = require('webpack-node-externals'); // 服务端运行webpack需要运行NodeExternals, 他的作用是将express这类node模块不被打包到js里。

const merge = require('webpack-merge');
const config = require('./webpack.base.js');

const serverConfig = {
    target: 'node',
    mode: 'development',
    entry: './src/server/index.js',
    output: {
        filename: 'bundle.js',
        path: Path.resolve(__dirname, 'build')
    },
    externals: [NodeExternals()],
}

module.exports = merge(config, serverConfig);
```

webpack.client.js

```js
const Path = require('path');
const merge = require('webpack-merge');
const config = require('./webpack.base.js');

const clientConfig = {
    mode: 'development',
    entry: './src/client/index.js',
    output: {
        filename: 'index.js',
        path: Path.resolve(__dirname, 'public')
    }
};

module.exports = merge(config, clientConfig);
```

src/server中放置的是服务端运行的代码，src/client放置的是浏览器端运行的js。

### 4. 目录说明

```s
package.json # 项目管理文件
webpack.base.js # webpack 公共部分
webpack.server.js # 服务端webpack配置
webpack.client.js # 客户端webpack配置
src/  # 开发文件夹
    components/ # React 组件文件夹
    server/index.js # 服务端运行代码
    client/index.js # 客户端运行代码
    Routes/index.js # 路由配置
build/ # 编译后文件夹
public/ # 前端静态文件夹，用于存放浏览器执行的js代码
```

## 4. 服务器端渲染路由

首先浏览器向服务器发送请求，服务器返回一个空的html，浏览器再请求js，加载到js后会执行react代码，react代码接管页面执行流程，这个时候可以根据浏览器的地址展示页面内容。

做重构的时候需要让路由代码在浏览器和服务端分别执行一次，浏览器执行的流程和原本一模一样没有任何区别但是服务器端有一些区别，这里要使用StaticRouter组件替代浏览器的browserRouter。

### 1. 配置路由模块

```s
npm install react-router-dom --save
```

创建src/Routes.js配置路由。

```js
import React from 'react';
import { Route } from 'react-router-dom';
import Home from './components/Home';

export default (
    <div>
        <Route path="/" exact component={Home}></Route>
    </div>
);
```

### 2. 配置客户端代码

src/client/index.js这里使用BrowserRouter包裹住之前定义的Routes。

```js
import React from 'react';
import ReactDOM from 'react-dom';
import { BrowserRouter } from 'react-router-dom';
import Routes from '../Routes';

const App = () => {
    return (
        <BrowserRouter>
            {Routes}
        </BrowserRouter>
    )
}

ReactDOM.hydrate(<App />, document.getElementById('root'));
```

### 3. 配置服务端代码

src/server/index.js，同样使用StaticRouter来渲染Routes。context是StaticRouter做数据传递的，这里先写一个空对象。

StaticRouter是不知道请求路径是什么的，因为他运行在服务器端，所以这是他不如BrowserRouter的地方，他需要在请求体重获取到路径传递给他, 这里需要将content写在请求里面。将location的值赋为req.path。

```js
import express from 'express';
import React from 'react';
import { renderToString } from 'react-dom/server';

import { StaticRouter } from 'react-router-dom';
import Routes from '../Routes';

const app = express();

app.use(express.static('public'));

app.get('*', function(req, res) {
    const content = renderToString((
        <StaticRouter location={req.path} context={{}}>
            <Routes />
        </StaticRouter>
    ));
    res.send(`
        <html>
            <body>
                <div id="root">${content}</div>
                <script src="/index.js"></script>
            </body>
        </html>
    `);
})

var server = app.listen(3000);
```

### 4. 增加页面组件用于测试路由

增加一个页面，实现多页面的路由跳转。当用户访问login路径的时候返回一个Login组件。

src/Routes.js

```js
import React from 'react';
import { Route } from 'react-router-dom';
import Home from './components/Home';
import Login from './components/Login';

export default (
    <div>
        <Route path="/" exact component={Home}></Route>
        <Route path="/login" exact component={Login}></Route>
    </div>
);
```

src/components/Login/index.js

```js
import React from 'react';

const Login = () => {
    return <div>Login</div>
}

export default Login;
```

整理一下代码，新建一个utils文件将通用方法抽离出来。

src/server/utils.js

```js
import React from 'react';
import { renderToString } from 'react-dom/server';
import { StaticRouter } from 'react-router-dom';
import Routes from '../Routes';
export const render = (req) => {
    const content = renderToString((
        <StaticRouter location={req.path} context={{}}>
            <Routes />
        </StaticRouter>
    ));
    return `
        <html>
            <body>
                <div id="root">${content}</div>
                <script src="/index.js"></script>
            </body>
        </html>
    `;
}
```

src/server/index.js，使用render函数。

```js
import express from 'express';
import { render } from './utils';

const app = express();
app.use(express.static('public'));

app.get('*', function(req, res) {
    res.send(render(req));
})
var server = app.listen(3000);
```

使用Link标签串联起整个路由的工作流程。创建一个公共组件src/components/Header/index.js

```js
import React from 'react';

const Header = () => {
    return <div>header</div>
}

export default Header;
```

src/components/Home/index.js组件中引入Header组件。

```js
import React from 'react';
import Header from '../Header';

const Home = () => {
    return <div>
        <Header>
        Home
        <button onClick={() => { alert('click1'); }>按钮</button>
    </div>
}

export default Home;
```

src/components/Login/index.js

```js
import React from 'react';
import Header from '../Header';

const Login = () => {
    return <div><Header />Login</div>
}

export default Login;
```

在Header中引入Link, 并且使用他跳转至Home和Login。

src/components/Header/index.js

```js
import React from 'react';
import { Link } from 'react-router-dom';

const Header = () => {
    return <div>
        <Link to="/">Home</Link>
        <br />
        <Link to="/login">Login</Link>
    </div>
}

export default Header;
```

在做页面同构的时候，服务器端渲染只会在第一次进入页面的时候进行，后面使用Link的跳转都是浏览器端的跳转，不会再去加载页面的资源文件。

所以服务器端渲染不是每个页面都做服务器端渲染，而是只访问的第一个页面具有服务端渲染的特性，其他的页面仍旧是React的路由机制。

## 5. 什么是中间层？

做服务端渲染的时候经常能听到中间层这个名词。做服务端渲染的时候浏览器请求服务器也就是node-server，服务器会将页面数据返回给浏览器。但是当做大型项目的时候，获取页面内容的时候会涉及到数据库查询或者说数据的计算，一般在做服务端渲染的时候架构层会将数据库的查询或者复杂的计算放在java，c++等服务器去做，而不会放在node中。

因为相对于Node来说，Java或者C++计算性能要更高一些。

这种架构有一个好处，java服务只需要专注数据的获取数据的计算就可以了，node服务器专注生成页面的内容，负责将从java服务器中获取的数据生成页面结构。所以node-server只是一个中间层，负责页面的拼装。

react计算还是很消耗性能的，当访问量过多的时候node可能会承受不住，这个时候可以单独去增加node服务器的数量来提高负载瓶颈，这种架构在线上还是具备很大的便捷性的。

不过他的缺点也是比较明显的，增加了前端的复杂度，在关心页面渲染的同时还要维护服务器，关心项目架构。

## 6. 引入Redux

如果我想在项目中使用redux我需要在server端和client端都使用redux，首先需要安装redux。react-redux可以方便开发者在react中去使用redux。redux-thunk是redux的一个中间件也安装一下。

```s
npm install redux react-redux redux-thunk --save
```

### 1. 客户端配置

src/client/index.js，引入createStore来创建store。不了解redux的同学可以参考我之前写的《redux设计模式》一文。

```js
import React from 'react';
import ReactDOM from 'react-dom';
import { BrowserRouter } from 'react-router-dom';
import Routes from '../Routes';
import { createStore } from 'redux';
import { Provider } from 'react-redux';

const reducer = (state = { name: 'yd'}, action) => {
    return state;
}
const store = createStore(reducer);

const App = () => {
    return (
        <Provider store={store}>
            <BrowserRouter>
                {Routes}
            </BrowserRouter>
        </Provider>
    )
}

ReactDOM.hydrate(<App />, document.getElementById('root'));
```

在src/components/Home/index.js组件中中使用redux。

```js
import React from 'react';
import Header from '../Header';
import { connect } from 'react-redux';

const Home = (props) => {
    return <div>
        <Header>
        <div>{props.name}</div>
        <div>Home</div>
        <button onClick={() => { alert('click1'); }>按钮</button>
    </div>
}

const mapStatetoProps = state => ({
    name: state.name
});

export default connect(mapStatetoProps, null)(Home);
```

### 2. 服务端配置

src/server/utils.js

```js
import React from 'react';
import { renderToString } from 'react-dom/server';
import { StaticRouter } from 'react-router-dom';
import Routes from '../Routes';
import { createStore } from 'redux';
import { Provider } from 'react-redux';

export const render = (req) => {

    const reducer = (state = { name: 'yd'}, action) => {
        return state;
    }
    const store = createStore(reducer);

    const content = renderToString((
        <Provider store={store}>
            <StaticRouter location={req.path} context={{}}>
                <Routes />
            </StaticRouter>
        </Provider>
    ));
    return `
        <html>
            <body>
                <div id="root">${content}</div>
                <script src="/index.js"></script>
            </body>
        </html>
    `;
}
```

使用redux的时候使用一些中间件，可以在src/server/utils.js演示。

```js
import React from 'react';
import { renderToString } from 'react-dom/server';
import { StaticRouter } from 'react-router-dom';
import Routes from '../Routes';
import { createStore, applyMiddleware } from 'redux';
import { Provider } from 'react-redux';
import thunk from 'redux-thunk';

export const render = (req) => {

    const reducer = (state = { name: 'yd'}, action) => {
        return state;
    }
    const store = createStore(reducer, applyMiddleware(thunk));

    const content = renderToString((
        <Provider store={store}>
            <StaticRouter location={req.path} context={{}}>
                <Routes />
            </StaticRouter>
        </Provider>
    ));
    return `
        <html>
            <body>
                <div id="root">${content}</div>
                <script src="/index.js"></script>
            </body>
        </html>
    `;
}
```

src/client/index.js

```js
import React from 'react';
import ReactDOM from 'react-dom';
import { BrowserRouter } from 'react-router-dom';
import Routes from '../Routes';
import { createStore, applyMiddleware } from 'redux';
import { Provider } from 'react-redux';
import thunk from 'redux-thunk';

const reducer = (state = { name: 'yd'}, action) => {
    return state;
}
const store = createStore(reducer, applyMiddleware(thunk));

const App = () => {
    return (
        <Provider store={store}>
            <BrowserRouter>
                {Routes}
            </BrowserRouter>
        </Provider>
    )
}

ReactDOM.hydrate(<App />, document.getElementById('root'));
```

client和server中都会用到store，可以将他们抽离出来不要每个位置都写一遍。

要注意一下，在render方法中每个用户访问都会使用store，但是在服务器上这个store只定义了一次，并不是每次调用render都会创建，所以共享了store，这样是不对的，每个用户都应该有自己的store。这里导出一个创建Store的方法，在使用的位置创建store。

src/store/index.js

```js
import { createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk';
const reducer = (state = { name: 'yd'}, action) => {
    return state;
}

const getStore = () => {
    return createStore(reducer, applyMiddleware(thunk));
}
export default getStore;
```

src/client/index.js也要加一下。

```js
import React from 'react';
import ReactDOM from 'react-dom';
import { BrowserRouter } from 'react-router-dom';
import Routes from '../Routes';
import getStore from '../store'; // 使用store
import { Provider } from 'react-redux';

const App = () => {
    return (
        <Provider store={getStore()}>
            <BrowserRouter>
                {Routes}
            </BrowserRouter>
        </Provider>
    )
}

ReactDOM.hydrate(<App />, document.getElementById('root'));
```

src/server/utils.js

```js
import React from 're