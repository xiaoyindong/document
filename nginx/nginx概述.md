## 1. 概述
 
很多人可能或多或少了解过```nginx```，即使没有使用过```nginx```，但是可能用```Apache```搭建过简单的```web```服务器，用```tomcat```写过一些简单的动态页面，其实这些功能nginx都可以实现。

```nginx```最重要的三个使用场景个人认为是```静态资源服务```、```反向代理服务```和```api服务```。

```web```请求走进服务以后会先经过```nginx```再到应用服务，然后再去访问```redis```或者```mysql```提供基本的数据功能。

这就有个问题，应用服务因为要求开发效率高，所以他的运行效率是很低的，他的```qbs```，```tps```并发都是受限的，所以就需要把很多的应用服务组成集群，向用户提供高可用性。

很多服务构成集群的时候，需要```nginx```具有反向代理的功能，可以把动态请求传导给对应的应用服务。服务集群一定会带来两个需求，动态的扩容和容灾。

反向代理必须具备负载均衡的功能，其次在链路中，```nginx```是处在企业内网的边缘节点，随着网络链路的增长，用户体验到的时延会增加。

把一些所有用户看起来不变的，或者在一段时间内看起来不变的动态内容缓存在```nginx```部分，由```nginx```直接向用户提供访问，用户的时延就会减少很多。

反向代理衍生出另外的功能叫缓存，他能够加速访问，而很多时候在访问像```css```或```js```文件又或者一些小图片是没有必要由应用服务来访问的，他只需要直接由```nginx```提供访问就可以了这就是```nginx```的静态资源功能。

应用服务它本身的性能有很大的问题，数据库服务要比应用服务好的多，原因是数据库他的业务场景比较简单，并发性能和```tps```都要远高于应用服务。由```nginx```直接去访问数据库或者```redis```也是不错的选择。

还可以利用```nginx```强大的并发性能，实现如```web```防火墙的一些业务功能，这就要求```nginx```服务有非常强大的业务处理功能，```openResty```和```nginx```集成了一些工具库来实现此功能。

## 2. 历史背景

全球化和物联网的快速发展，导致接入互联网中的人与设备的数量都在快速的上升，数据的快速爆炸，对硬件性能提出很高的要求。

摩尔定律表明之前服务跑在```1GHZ```的```CPU```上的服务更新到```2GHZ```的```CPU```时服务会有两倍的性能提升。

但是到了本世纪初，摩尔定律在单颗```CPU```的频率上已经失效了，```CPU```开始向着多核方向发展，当服务器现在是跑在```8```核```CPU```上时，一年半以后换到了```16```核的```CPU```，服务的性能通常是不会有一倍的提升的。

这些性能主要损耗在操作系统和大量的软件没有做好服务于多核架构的准备，比如说像```Apache```是低效的，因为他的架构模型里一个进程同一时间，只会处理一个连接，一个请求。只有在这个请求处理完以后才会去处理下一个请求。

它实际上在使用操作系统的进程间切换的特性，因为操作系统微观上是有限的```CPU```，但是操作系统被设计为同时服务于数百甚至上千的进程。

```Apache```一个进程只能服务于一个连接，这种模式会导致当```Apache```需要面对几十万，几百万连接的时候，他没有办法去开几百万的进程，而进程间切换的代价成本又太高啦。

当并发的连接数越多，这种无谓的进程间切换引发的性能消耗又会越大。

```nginx```是专门为了这种应用场景而生的，可以处理数百万甚至上千万的并发连接，```nginx```目前在```web```市场份额中排行第二，在过去几年他增长极度迅速，在不久的将来```nginx```在```web```端的应用将远远超过其他服务器。

## 3. nginx的优点

大部分的程序和服务器随着并发连接数的上升他的```RPS```数会急剧的下降，这里的原理就像之前所说过的，他的设计架构是有问题的。

```nginx```的第一个优点就是高并发和高性能同时具备的，往往高并发只需要对每一个连接所使用的内存尽量的少就可以达到。

而具有高并发的同时达到高性能，往往需要非常好的设计，那```nginx```可以达到什么样的标准呢？

比如说现在主流的一些服务器```32```核```64G```的内存可以轻松达到数千万的并发链接，如果是处理一些简单的静态资源请求，可以达到一百万的```RPS```这种级别。

其次```nginx```的可扩展性非常好，主要在于他的模块化设计非常的稳定，而且```nginx```的第三方模块的生态圈非常的丰富。甚至于有像```TNG```,```openRestry```这种第三方插件。丰富的生态圈为```nginx```丰富的功能提供了保证。

第三个优点是它的高可靠性，所谓的高可靠性是指```nginx```可以在服务器上持续不间断的运行数年，而很多```web```服务器往往运行几周或者几个月就需要做一次重启。

对于```nginx```这种高并发高性能的反向代理服务器而言，他往往运行在企业内网的边缘节点上，如果企业想提供```4个9```，```5个9```，甚至更高的高可用性时，对于```nginx```持续运行能够```down```机的时间一年可能只能以秒来计。所以在这种角色中，```nginx```的高可靠性给提供了非常好的保证。

第四个优点热部署，是指可以在不停止服务的情况下升级```nginx```，这对于```nginx```来说非常的重要，因为在```nginx```可能跑了数百万的并发连接。

如果是普通的服务可能只需```kill```掉进程再重启的方式就可以处理好，但是对于```nginx```而言，因为```kill```掉```nginx```进程，会导致操作系统为所有的已经建立连接的客户端发送一个```tcp```中的```reset```报文。而很多客户端是没有办法很好的处理请求的。

在大并发场景下，一些偶然事件就会导致必然的恶性结果，所以热部署是非常有必要的。

第五个优点是```BSD```许可证，```BSD Listens```是指```nginx```不仅是开源的免费的，而且可以在有定制需要的场景下，去修改```nginx```源代码，再运行在商业场景下，这是合法的。

以上的优点是```nginx```最核心的特性。

## 4. 主要组成部分

首先是```nginx```的可执行文件，它是由```nginx```自身的框架、官方模块以及各种第三方模块共同构建的文件。他有完整的系统，所有的功能都由他提供。

第二个部分是```nginx.conf```配置文件，类似于骑车的驾驶员，虽然可执行文件已经提供了许多功能，但这些功能有没有开启，或者开启了以后定义了怎样的行为处理请求，都是由```nginx.conf```配置文件决定的。

```nginx```的第三个组成部分叫做```access.log```访问日志，```access.log```会记录下每一条```nginx```处理过的```http```请求信息与响应信息。

第四个组成部分是```error.log```错误日志，当出现了一些不可预期的问题时，可以通过```error.log```去把问题定位出来。

这四个部分是相辅相成的。

```nginx```的可执行文件和```nginx.conf```定义了处理请求的方式。如果想对web服务，做一些运营或者运维的分析，需要对```access.log```做进一步的分析。如果出现了任何未知的错误，或者与预期的行为不一致时，应该通过```error.log```去定位根本性的问题。

## 5. 版本规则

```nginx```每发布一个版本的时候会有三个特性，一个是```feature```，就是他新增了哪些功能，```bugfix```表示他修复了哪些```bug```，```change```表示做了哪些重构。

每一个版本都有```mainline```主干版本和```stable```稳定版本。

在```nginx```的官网点击右下角的```download```，就可以看到版本号列表，单数版本表示主干版本，会新增很多功能，但不一定稳定。双数版本是稳定版本。

```CHANGES```文件中可以看到每一个版本含有的新增功能，修复的```bug```，以及做了哪些小的重构。

大概在```2009```年以后```nginx```的```bugfix```数量已经大幅度减少，所以```nginx```相对已经很稳定了。

```nginx```的开发时间是在```2002```年，但是他在```2004```年```10```月```4```日推出了第一个版本，在```2005年```曾经做过一次大的重构。

因为```nginx```优秀的设计，使得他的生态圈极为丰富，模块的设计，架构的设计都没有再做过大的变动。

在```2009```年```nginx```开始支持```windows```操作系统，```2011```年```1.0```正式版本发布，同时```nginx```的商业公司```nginx Plus```也成立了，在```2015```年```nginx```发布了几个重要的功能。

其中提供```stream```，```四层反向代理```，他在功能上完全可以替代传统使用的```LVS```, 并且具有更丰富的功能。

## 6. 版本选择

免费开源: ```nginx.org```

商业版本: ```nginx.com```

开源免费的```nginx```在```2002```年开始开发，到```2004```年发布第一个版本，```2011```年开源版的```nginx```发布了```1.0```稳定版，同年```nginx```的作者成立了一家商业公司，开始推出```nginx Plus```商业版的```nginx```。

商业版的```nginx```在整合第三方模块上还有运营监控以及技术支持上有很多优点，但他有个最大的缺点就是不开源，所以通常在国内会使用```nginx.org```开源版的。

阿里巴巴也推出了```Tengine```版本，```Tengine```的优点就是在阿里巴巴生态下他经历了非常严苛的考验，```Tengine```之所以会存在也是因为他的很多特性领先于```nginx```的官方版本。

所以```Tengine```实际上是修改了```nginx```官网版本的主干代码，当然框架被修改以后```Tengine```就遇到了一个明显的问题，没有办法跟着```nginx```的官方版本同步的升级。```Tengine```也可以使用```nginx```的第三方模块。

```OpenResty```的作者章亦春在阿里巴巴的时候开发了```Lua```语言版本的```openResty```，因为```nginx```的第三方模块开发的难度相当大，章亦春把```nginx```非阻塞事件的一种框架以```Lua```语言的方式提供给了广大开发者。

```OenRestry```兼具了高性能，以及开发效率高的特点，```OpenResty```同样有开源版和商业版，目前多使用```openresty.org```站点下的开源版本。商业版```OpenRestry```的主要特点是技术支持相对比较好很多。

如果你没有太多的业务诉求，那么使用开源版的```nginx```就足够了，如果你需要开发```Api```服务器，或者需要开发```web```防火墙，```openrestry```是一个很好的选择。

## 7. 编译配置

安装```nginx```有两种方法，除了编译外，还可以直接用操作系统上自带的一些工具，比如说```yum```，```apt-get```，直接去安装```nginx```。

但是直接安装```nginx```有个问题，就是```nginx```的二进制文件不会把模块直接编译进来，毕竟```nginx```的官方模块，并不是每一个默认都会开启的。

如果想添加第三方的```nginx```模块，就必须通过编译```nginx```的方式。

编译```nginx```主要分为六个部分，首先需要下载```nginx```，从```nginx.org```网站上直接下载就可以。

打开```nginx.org```在页面中找到右下角```donwload```，选择```Stable```版本的下来链接，右键复制链接地址即可，进入到```Linux```中使用```wget```进行下载

```s
cd  /home/nginx
wget http://nginx.org/download/nginx-1.18.0.tar.gz
```

下载完```nginx```压缩包以后首先解压压缩包。

```s
tar -xzf nginx-1.18.0.tar.gz
```

接着进入解压后的目录通过```ll```命令查看所有文件。

```s
cd nginx-1.18.0
ll
```

第一个目录叫```auto```目录。

```s
cd auto
```

```auto```目录里面有四个子目录，```cc```是用于编译的，```lib```库和对操作系统的判断在```os```里面，其他所有的文件都是为了辅助```config```脚本执行的时候判定```nginx```支持哪些模块以及当前的操作系统有什么样的特性可以供给```nginx```使用。

```CHANGES文```件标记了```nginx```每一个版本中提供了哪些特性和```bugfix```。

```s
cat ../CHANGES
```

其中会有```feature```，```bugfix```，```change```三种特性在里面。

```CHANGES.ru```文件是俄罗斯语言的```CHANGES```文件，可能因为作者是个俄罗斯人。

```conf```文件是一个示例文件，就是把```nginx```安装好以后，为了方便运维配置，会把```config```里面的示例文件```copy```到安装目录。

```configure```脚本用来生成中间文件，执行编译前的一个一些配置，也就是记录编译前的设定信息，编译时使用。

```contrib```目录提供了两个脚本和```vim```工具，也就是让```vim```打开```config```配置文件时支持代码高亮。

把```contrib```目录下```vim```的所有文件```copy```到自己的目录中

```s
cp -r contrib/vim/* ~/.vim/
```

就可以把```nginx```语言的语法高亮显示在```vim中```了。

```html```目录里面提供了两个标准的```HTML```文件，一个是发现```500```错误的时候可以重定向到的文件，另一个是默认的```nginx```的欢迎界面```index.html```。

```man```文件里则是```Linux```对```nginx```的帮助文件，里面标识了最基本的```nginx```帮助和配置。

```src```目录是```nginx```的核心源码。

## 8. 开始编译

编译前可以先看一下```configure```支持哪些参数。

```s
./configure --help | more
```

首先就是确定```nginx```执行中会去找哪些目录下的文件作为辅助文件。比如用动态模块时```--modules-path```就会产生作用。```--lock-path```确定```nginx.lock```文件放在哪里等。

如果没有任何变动的话只需要指定```--prefix=PATH```就可以了，设定一个安装目录。

第二类参数主要是用来确定使用哪些模块和不使用哪些模块的，前缀通常是```--with```和```--without```。

比如说-```-with-http_ssl_module```或者```--with-http_v2_module```通常需要主动加```--with```的时候，意味着模块默认是不会编译进```nginx```的。

而模块中显示```--without```比如说```--without-http_charset_module```意味着默认他会编译进```nginx```中，加了参数是把他移除默认的```nginx```的模块中。

第三类参数中指定```nginx```编译需要的一些特殊的参数，比如说用```cc```编译的时候需要加一些什么样的优化参数，或者说要打印```debug```级别的日志(```--with-debug```)以及需要加一些第三方的模块(```--with-zlib-asm=CPU```)

这里指定的```nginx```的安装目录是在```/home/nginx```目录下。

```s
./configure --prefix=/home/nginx/nginx/
```

如果没有任何报错```nginx```就已经编译成功了，所有```nginx```的配置特性以及```nginx```运行时的目录都会列在最下方。

在```config```执行完之后，会看到生成了一些中间文件。中间文件会放在```objs```文件夹下。最重要的是会生成一个文件叫做```ngx_modules.c```他决定了接下来执行编译时哪些模块会被编译进```nginx```。可以打开看一下所有被编译进```nginx```的模块都会列在这里，他们最后会形成一个叫做```ngx_modules```的数组。

执行```make```编译。

```s
make
```

编译完成以后如果没有任何错误，就可以看见生成了大量的中间文件，以及最终的```nginx```二进制文件。

```s
cd objs/
ll
```

最后进行```make install```。

```s
make install
```

安装完成之后在```--prefix```指定的安装目录中可以看到很多目录，```nginx```的执行文件就在```sbin```目录下。

决定```nginx```功能的配置文件在```conf```下，```access.log```和```error.log```在```log```文件夹下。

可以看到在```conf```目录下所有文件就是在源代码中```conf```目录copy过来的，其中的内容也是完全相同的。

## 9. 配置语法

```nginx```可执行文件中已经指定了他包含了哪些模块，但每一个模块都会提供独一无二的配置语法。

这些所有的配置语法，会遵循同样的语法规则。

```nginx```的配置文件是一个```ascii```的文本文件，主要有两部分组成，```指令```和```指令快```。

```s
http {
    include mime.types;
    upstream thwp {
        server 127.0.0.1:8000;
    }

    server {
        listen 443 http2;
        # nginx配置语法
        limit_req_zone $binary_remote_addr zone=one:10 rate=1r/s;
        location ~* \.(gif|jpg|jpeg)$ {
            proxy_cache my_cache;
            expires 3m;
        }
    }
}
```

上面```http```就是一个指令快，```include mime.types;```就是一条指令。

每条指令以分号结尾，指令和参数间以空格分隔。```include mime.types;```中```include```是一个指令名，```mime.types```是参数中间可以用一个或多个空格分隔。参数可以有多个，比如下面的```limit_req_zone```有三个参数，多个参数之间也是用空格分隔。

两条指令间是以```;```作为分隔符的，两条指令放在一行中写也是没有问题的。只不过可读性会变得很差。

第三个指令块是以 ```{}``` 组成的，他会将多条指令组织到一起，比如```upstream```，他把一条指令```server```放在了```thwp```指令块下面。

```server```中也放置了```listen```，```limit_req_zone```这些指令，他也可以包含其他的指令块，比如说```location```。

有些指令可以有名字，比如```upstream```，后面有个```thwp```作为他的名字。

具体什么样的指令有名字什么样的指令没有名字是由提供指令块的```nginx```模块来决定的，他也可以决定指令块后面有一个或者说多个参数，或者说没有参数。

```include```语句允许引入多个配置文件以提升可维护性。在例子```中mime.types```文件中其实里面是含有很多条不同的文件的后缀名与```http```协议中```mime```格式的对照关系表。

```include```是导入其他配置模块的意思。

```#```符号可以添加注释，提升可读性，比如在listen后面加了一个```nginx```配置语法的注释，以描述下面一些配置的表达。

使用```$```符号可以使用变量，可以看下```limit_req_zone```这里用了一个参数叫做```$binary_remote_addr```，这是一个变量描述的是远端的地址。

部分指令的参数是支持正则表达式的，比如```location```后面可以看到，他可以支持非常复杂的正则表达式，而且可以把正则表达式括号里的内容通过```$1```,```$2```,```$3```的方式取出来。

在```nginx```的配置文件中当涉及到时间的时候，还有许多表达方式，比如下面的方式:

```s
ms -> 毫秒
s  -> 秒
m  -> 分钟
h  -> 小时
d  -> 天
w  -> 周
M  -> 月
y  -> 年
```

比如```location```中的```expires 3m;```就表示```3分钟```后希望```cache```刷新。

空间也是有单位的，当后面不加任何后缀名时表示字节```bytes```，加了```k```或者```K```表示千字节，```m```表示兆字节，```g```表示```G```字节。

```http```大括号里面所有的指令都是由```http```模块去解析和执行的，非```http```模块，比如说像```stream```或```mime```是没有办法去解析指令的。

```upstream```表示上游服务，当```nginx```需要与```Tomcat```等企业内网的其它服务交互的时候呢，可以定义一个```upstream```。

```server```对应的一个或一组域名，```location```是```url```表达式。

## 10. 重载，热部署，日志切割

需要帮助的时候可以用```-?``` 或者 ```-h```获取帮助信息。

```s
nginx -?
nginx -h
```

默认情况下编译出来的```nginx```会寻找执行```configure```命令时指定的配置文件。在命令行中可以指定另一个配置文件用``` -c 路径 ```。

还能指定一些配置用```-g```，指令就是在```nginx```的```configure```目录里的指令。

```nginx```操作运行中的进程一般是通过发送信号，可以通过```linux```的```kill```命令也可以用```nginx -s```子命令，子命令后可以用```stop```，```quit```，```reload```，```reopen```。

```s
nginx -s stop # 停止nginx服务
nginx -s quit # 优雅的停止nginx服务
nginx -s reload # 重载配置文件
nginx -s reopen # 重新开始记录日志文件。
```

```-t```可以测试一下配置文件是否合法问题。

```-V```是在编译时用```configure```脚本执行所加的所有参数。

### 1. 重载配置文件

修改````nginx````配置文件中的一些值，比如说```conf/nginx.conf```文件中，打开```tcp_nopush```。

当修改完配置文件以后，可以直接执行```nginx -s reload```命令```nginx```是在不停止对客户服务的情况下使用了```tcp_nopush```新的配置项，非常的简单。

### 2. 热部署

```nginx```在运行的情况下想更换最新版本的```nginx```，根据之前所说的，```nginx```编译方法下载一个新的```nginx```。

把最新版本的```nginx```编译后的可执行文件```nginx```，```copy```到目录中替换掉正在运行的```nginx```文件。```copy```完成需要给正在运行的```nginx```的```master```进程发送一个信号，告诉他开始进行热部署做一次版本升级，给```nginx```的```master```进程发送一个信号，```USR2```信号。

```s
kill -USR2 进程号(13195)
```

```nginx```会新启一个```master```进程使用的正式刚刚复制过来的最新的```nginx```二进制文件。

旧的```worker```也在运行，新的master会生成新的```worker```，他们会平滑的把所有的请求过渡到新的进程中。

新的请求新的连接会进入新的```nginx```进程中，这时需要向老的```nginx```进程发送一个信号叫做```WINCH```，告诉他优雅的关闭所有进程。

```s
kill -WINCH 13195
```

这时老的```worker```进程会优雅的退出，但是老的```master```进程还在，只是是没有```worker```进程了。

这说明所有的请求已经全部切换到新的```nginx```中了，如果需要把新版本退回到老版本，可以向老的进程发送```reload```命令，让他重新把```worker```进程拉起来。再把新版本关掉。所以保留```master```是为了允许做版本回退。

### 3. 日志切割

比如说当前的日志已经很大了。需要把以前的日志备份到另外一个文件中，但是```nginx```还是正常运行的。

这就要通过```reopen```命令来做，首先需要把当前正在使用的日志```copy```一份放在另外的位置.

```s
mv access_log bak.log
```

接着执行命令```reopen```。

```s
nginx -s reopen
```

就重新生成了一个```access.log```, 原本的```log```备份成了```bak.log```,就实现了日志切割。

当然这种方法会非常不好用，实际上往往是每一天，或者是每一周执行一次日至切割，可以先写成一个```bash```脚本。

在```bash```脚本中首先把文件复制一下，再执行-```s reopen```命令，最后把脚本放在```crontab```中。

## 11. 静态资源Web服务器

编辑```conf/nginx.conf```文件找到```server```代码块中，```listen```配置监听端```8080```端口，然后需要配置一个```location```，使用```/```让所有的请求都访问到```www```文件夹。

这里需要指定```url```的后缀与文件的后缀一一对应，有两种用法，```root```和```alias```，```root```是系统的跟目录，所以通常使用```alias```，```alias```是```nginx```的安装目录。

```s
server {
    listen 8080;
    ...
    location / {
        alias www/;
        ...
    }
    ...
}
```

做完配置之后启动```nginx```在浏览器中访问```localhost:8080```就可以了。

```s
nginx -s reload
```

### 1. 开启gzip

做完```gzip```压缩传输的字节数会大幅度减少，所以通常会打开```gzip```。

首先打开```nginx.conf```文件，找到```http```代码块中的```gzip```相关选项，打开```gzip(off -> on)```, ```gzip_min_length```是小于多少字节不再执行压缩，因为小于一定的字节```http```传输直接就可以发送了，压缩反而消耗```cpu```性能，```gzip_comp_level```代表压缩级别，```gzip_types```是针对某些类型的文件才做```gzip```压缩。

```s
http {
    ...
    gzip on;
    gzip_min_length 1;
    gzip_comp_level 2;
    gzip_types text/plain applicaton/x-javascript text/css image/png;
    ...
}
```

配置好后重启```nginx```, 浏览器中查看就会发现，传输的文件已经减少了很多，响应头中多出了```Content-encoding: gzip```。使用```gzip```以后整个```web```服务传输效率会高很多。

### 2. 打开目录结构

```nginx```给提供了一个官方模块叫做```autoindex```，他可以提供当访问以```/```结尾的```url```时，显示目录的结构。使用方法也特别简单，就是```autoindex on```加入一个指令就可以了。

```s
location / {
    autoindex on;
}
```

他会把所访问的文件夹内所有文件列出来，当打开一个目录时，可以继续显示目录中的文件，这是一个很好的静态资源帮助功能。

### 3. 网速限制

比如公网带宽是有限的，当有很多并发用户使用带宽时，他们会形成一个争抢关系，可以让用