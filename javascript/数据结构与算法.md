## 1. 概述

程序是由于数据结构和算法组成的。好的算法可以让代码化繁为简，也可以提升代码运行效率，所以目前很多公司的面试都会考虑算法。首先要搞懂什么是数据结构，什么是算法。

从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。 图书馆储藏书籍你肯定⻅过吧?为了方便查找，图书管理员一般会将书籍分⻔别类进行“存储”。按照一定规律编号，就是书籍这种“数据”的存储结构。

那如何来查找一本书呢?有很多种办法，你当然可以一本一本地找，也可以先根据书籍类别的编号，是人文，还是科学、 计算机，来定位书架，然后再依次查找。笼统地说，这些查找方法都是算法。

从狭义上讲，某些著名的数据结构和算法，比如队列、栈、堆、二分查找、动态规划等。这些都 是前人智慧的结晶，可以直接拿来用。经典数据结构和算法，都是前人从很多实际操作场景中抽象出来 的，经过非常多的求证和检验，可以高效地解决很多实际的开发问题。
 
数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构之上。 因此，无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。

比如，因为数组具有随机访问的特点，常用的二分查找算法需要用数组来存储数据。但如果选择链表这种数据结构，二分查找算法就无法工作了，因为链表并不支持随机访问。数据结构是静态的，它只是组织数据的一种方式。如果不在它的基础上操作、构建算法，孤立存在的数据结构就是没用的。

想要学习数据结构与算法，首先要掌握一个数据结构与算法中最重要的概念——复杂度分析。

## 2. 复杂度

数据结构和算法本身解决的是```快```和```省```的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。如何衡量编写的算法代码的执行效率。只要讲到数据结构与算法，就一定离不开时间、空间复杂度分析。而且，我个人认为，复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。

你可能会有些疑惑，我把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。为什么还要做时间、空 间复杂度分析呢?这种分析方法能比我实实在在跑一遍得到的数据更准确吗?

首先，可以肯定地说，这种评估算法执行效率的方法是正确的。很多数据结构和算法书籍还给这种方法起了一个名字，叫事后统计法。但是，这种统计方法有非常大的局限性。

测试环境中硬件的不同会对测试结果有很大的影响。比如同样一段代码，分别用```Intel Core i9```处理器和```Intel Core i3```处 理器来运行，不用说，```i9```处理器要比```i3```处理器执行的速度快很多。还有，比如原本在这台机器上```a```代码执行的速度比```b```代码要快，等换到另一台机器上时，可能会有截然相反的结果。

对同一个排序算法，排序的执行时间就会有很大的差别。极端情况下，如果数据已经是有序的，那排序算法不需要做任何操作，执行时间就会非常短。除此之外，如果测试数据规模太小，测试结果可能无法真实地反应算法的性能。比如，对于小规模的数据排序，插入排序可能反倒会比快速排序要快!

算法的执行效率，粗略地讲，就是算法代码执行的时间。但是，如何在不运行代码的情况下，用肉眼得到一段代码的执行时间，比如这里有段非常简单的代码，求```1，2，3...n```的累加和。现在，我就带你一块来估算一下这段代码的执行时间。

```js
function cal(n) {
  var sum = 0;
  var i = 1;
  for (; i <= n; i++) {
    sum = sum + i;
  }
  return sum; 
}
```

从```CPU```的⻆度来看，这段代码的每一行都执行着类似的操作: 读数据-运算-写数据。尽管每行代码对应的```CPU```执行的个数、执行的时间都不一样，但是这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为```unit_time```，在这个假设的基础之上，评估这段代码的总执行时间。

第``2、3``行代码分别需要``1``个```unit_time```的执行时间，第```4、5```行都运行了```n```遍，所以需要```2n * unit_time```的执行时间，所以这段代码总 的执行时间就是```(2n + 2) * unit_time```。可以看出来，所有代码的执行时间```T(n)```与每行代码的执行次数成正比。

```js
function cal(n) {
  var sum = 0;
  var i = 1;
  var j = 1;
  for (; i <= n; i++) { 
    j = 1;
    for (; j <= n; j++) { 
      sum = sum + i * j;
    }
  }
}
```

第```2、3、4```行代码，每行都需要1个```unit_time```的执行时间，第```5、6```行代码循环执行了```n```遍，需要```2n * unit_time```的执行时间，第```7、8```行代码循环执行了```n2```遍，所以需要```2n2 * unit_time```的执行时间。所以，整段代码总的执行时间```T(n) = (2n2 + 2n + 3 ) * unit_time```。

尽管不知道```unit_time```的具体值，但是通过这两段代码执行时间的推导过程，可以得到一个非常重要的规律，所有代码的执行时间```T(n)```与每行代码的执行次数n成正比。

```js
T(n) = O(f(n))
```

```T(n)```表示代码执行的时间，```n```表示数据规模的大小，```f(n)```表示每行代码执行的次数总和。因为这是一个公式，所以用```f(n)```来表示。公式中的```O```，表示代码的执行时间```T(n)```与```f(n)```表达式成正比。

所以，第一个例子中的```T(n) = O(2n + 2)```，第二个例子中的T```(n) = O(2n + 2n + 3)```。这就是大```O```时间复杂度表示法。大```O```时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增⻓的变化趋势，所以，也叫作渐进时间复杂度(```asymptotic time complexity```)，简称时间复杂度。

当n很大时，可以把它想象成```10000```、```100000```。而公式中的低阶、常量、系数三部分并不左右增⻓趋势，所以都可以忽略。 只需要记录一个最大量级就可以了，如果用大```O```表示法表示刚讲的那两段代码的时间复杂度，就可以记为```T(n) = O(n)```和```T(n) = O(n2)```。

## 3. 时间复杂度

只关注循环执行次数最多的一段代码.

大```O```这种复杂度表示方法只是表示一种变化趋势。通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。这段核心代码执行次数的```n```的量级，就是整段要分析代码的时间复杂度。

```js
function cal(n) {
  var sum = 0;
  var i = 1;
  for (; i <= n; i++) {
    sum = sum + i;
  }
  return sum; 
}
```

第```2、3```行代码都是常量级的执行时间，与```n```的大小无关，所以对于复杂度并没有影响。循环执行次数最多的是第```4、5```行代码，所以这块代码要重点分析，这两行代码被执行了```n```次，所以总的时间复杂度就是```O(n)```。

总复杂度等于量级最大的那段代码的复杂度。

```js
function cal(n) {
  var sum_1 = 0;
  var p = 1;
  for (; p < 100; p++) {
      sum_1 = sum_1 + p;
  }
  var sum_2 = 0;
  var q = 1;
  for (; q < n; q++) {
      sum_2 = sum_2 + q;
  }
  var sum_3 = 0;
  var i = 1;
  var j = 1;
  for (; i <= n; i++) {
    j = 1;
    for (; j <= n; j++) {
      sum_3 = sum_3 + i * j; 
    }
  }
  return sum_1 + sum_2 + sum_3; 
}
```

可以分别分析每一部分的时间复杂度，然后把它们放到一块儿，再取一个量级最大的作为整段代码的复杂度。

第一段代码循环执行了```100```次，是一个常量的执行时间，跟n的规模无关，即便这段代码循环```10000```次、```100000```次，只要是一个已知的数，跟```n```无关，照样也是常量级的执行时间。因为当```n```无限大的时候，任何常数都可以忽略。尽管对代码的执行时间会有很大影响，但是回到时间复杂度的概念来说，它表示的是一个算法执行效率与数据规模增⻓的变化趋势，所以不管常量的执行时间多大，都可以忽略掉。因为它本身对增⻓趋势并没有影响。

那第二段代码和第三段代码的时间复杂度是是```O(n)```和```O(n2)```，取其中最大的量级。所以，整段代码的时间复杂度就为```O(n2)```。

总的时间复杂度等于量级最大的那段代码的时间复杂度。如果```T1(n) = O(f(n))```，```T2(n) = O(g(n))```，那么```T(n) = T1(n) + T2(n) = max(O(f(n))```，```O(g(n))) = O(max(f(n)```，```g(n)))```。

嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。

如果T1(n)=O(f(n))，T2(n)=O(g(n))，那么```T(n) = T1(n) * T2(n) = O(f(n)) * O(g(n)) = O(f(n) * g(n))```。

```js
function cal(n) {
  var ret = 0;
  var i = 1;
  for (; i < n; i++) {
     ret = ret + f(i);
   }
}
function f(n) {
  var sum = 0;
  var i = 1;
  for (; i < n; i++) {
    sum = sum + i; 
  }
  return sum; 
}
```

单独看```cal()```函数。假设```f()```只是一个普通的操作，那第```4~6```行的时间复杂度就是，```T1(n) = O(n)```。但```f()```函数本身不是一个简单的操作，它的时间复杂度是```T2(n) = O(n)```，所以，整个```cal()```函数的时间复杂度就是```T(n) = T1(n) * T2(n) = O(n*n) = O(n2)```。


多项式量级:```O(1)```，```O(logn)```，```O(nlogn)```，```O(m + n)```，```O(m * n)```。

非多项式量级:```O(2n)```，```O(n!)```。

当数据规模```n```越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增⻓。所以，非多项式时间 复杂度的算法其实是非常低效的算法。

### 1. O(1)

```O(1)```是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有3行，它的时间复杂度也是```O(1)```，而不是```O(3)```。

```js
var i = 8;
var j = 6;
var sum = i + j;
```

### 2. O(logn)

对数阶时间复杂度非常常⻅，同时也是最难分析的一种时间复杂度。

```js
i = 1;
while( i <= n) {
  i = i * 2;
}
```

变量i的值从```1```开始取，每循环一次就乘以```2```。当大于```n```时，循环结束。实际上，变量i的取值就是一个等比数列。只要知道```x```值是多少，就知道这行代码执行的次数了。```x = log2n```，所以，这段代码的时间复杂度就是```O(log2n)```。

```js
i = 1;
while(i <= n) {
  i = i * 3;
}
```

实际上，不管是以``2``为底、以```3```为底，还是以```10```为底，可以把所有对数阶的时间复杂度都记为```O(logn)```。对数之间是可以互相转换的，```log3n```就等于```log32 * log2n```，所以```O(log3n) = O(C * log2n)```，其中```C = log32```是一个常量。 基于我们前面的一个理论，在采用大```O```标记复杂度的时候，可以忽略系数，即```O(Cf(n)) = O(f(n))```。所以，```O(log2n)```就等于```O(log3n)```。因此，在对数阶时间复杂度的表示方法里，忽略对数的```底```，统一表示为```O(logn)```。

### 3. O(nlogn)

如果一段代码的时间复杂度 是```O(logn)```，循环执行```n```遍，时间复杂度就是```O(nlogn)```了。而且，```O(nlogn)```也是一种非常常⻅的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是O(nlogn)。

### 4. O(m+n)、O(m*n)

```js
function cal(m, n) { 
  var sum_1 = 0;
  var i = 1;
  for (; i < m; i++) {
    sum_1 = sum_1 + i;
  }
  var sum_2 = 0;
  var j = 1;
  for (; j < n; j++) {
    sum_2 = sum_2 + j;
  }
  return sum_1 + sum_2;
}
```

m和n是表示两个数据规模。无法事先评估m和n谁的量级大，所以在表示复杂度的时候，就不能简单省略掉其中一个。所以，上面代码的时间复杂度就是```O(m + n)```。

针对这种情况，要将加法规则改为```T1(m) + T2(n) = O(f(m) + g(n))```。乘法法则继续:```T1(m) * T2(n) = O(f(m) * f(n))```。

## 4. 空间复杂的

空间复杂度全称就是渐进空间复杂度(```asymptotic space complexity```)，表示算法的存储空间与数据规模之间的增⻓关系。

```js
function print(n) {
  int i = 0;
  var a = new Array(n); 
  for (i; i < n; i++) {
    a[i] = i * i; 
  }
  for (i = n - 1; i >= 0; i--) { 
    console.log(a[i]);
  } 
}
```

跟时间复杂度分析一样，第```2```行代码中申请了一个空间存储变量i，但是它是常量阶的，跟数据规模```n```没有关系，所以可以忽略。第3行申请了一个大小为```n```的数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是```O(n)```。

常⻅的空间复杂度就是```O(1)```、```O(n)```、```O(n2)```，像```O(logn)```、```O(nlogn)```这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。

常⻅的复杂度并不多，从低阶到高阶有```O(1)```、```O(logn)```、```O(n)```、```O(nlogn)```、```O(n2)```。

最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度，最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。

比如下面这段代码，复杂度是可能是```O(1)```也可能是```O(n)```，就是最好和最坏。

```js
// n表示数组array的⻓度
function find(array, n, x) {
  var i = 0;
  var pos = -1;
  for (; i < n; i++) {
    if (array[i] == x) {
      pos = i;
      break;
    }
  }
  return pos; 
}
```

最好和最坏对应的都是极端情况下的代码复杂度，发生的概率其实并不大。为了更好地表示平均情况下的复杂度，需要引入平均情况时间复杂度。

要查找的变量```x```在数组中的位置，有```n + 1```种情况，在数组的```0 ~ n-1```位置中和不在数组中。把每种情况下，查找需要遍历的元素个数累加起来，然后再除以```n + 1```，就可以得到需要遍历的元素个数的平均值。

要查找的变量x，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便你理解， 假设在数组中与不在数组中的概率都为```1 / 2```。另外，要查找的数据出现在```0 ~ n - 1```这```n```个位置的概率也是一样的，为```1 / n```。所以，根据概率乘法法则，要查找的数据出现在```0 ~ n - 1```中任意位置的概率就是```1 / (2n)```。

```js
1 * 1 / 2n + 2 * 1 / 2n + 3 * 1 / 2n + 4 * 1 / 2n + ... + n * 1 / 2n = (3n + 1) / 4
```

这个值就是概率论中的加权平均值，也叫作期望值，所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。用大```O```表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度是```O(n)```。

在大多数情况下，并不需要区分最好、最 坏、平均情况时间复杂度三种情况。使用一个复杂度就可以满足需求了。只有同一块代码在不同的情况下，时间复杂度有量级的差距，才会使用这三种复杂度表示法来区分。

均摊时间复杂度，听起来跟平均时间复杂度有点像，这两个概念确实非常容易弄混。平均复杂度只在某些特殊情况下才会用到，而均摊时间复杂度应用的场景比它更加特殊、更加有限。

```js
// array表示一个⻓度为n的数组 
// 代码中的array.length就等于n 
var array = new Array(n); 
var count = 0;
function insert(val) {
  if (count === array.length) {
    int sum = 0;
    for (int i = 0; i < array.length; i++) {
      sum = sum + array[i];
    }
    array[0] = sum;
    count = 1; 
  }
  array[count] = val;
  count++; 
}
```

这段代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的```count == array.length```时，用```for```循环遍历数组求和，并清空数组，将求和之后的```sum```值放到数组的第一个位置，然后再将新的数据 插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。

假设数组的⻓度是n，根据数据插入的位置的不同，我们可以分为n种情况，每种情况的时间复杂度是```O(1)```。除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是O(n)。而且，这```n + 1```种情况发生的概率一样，都是```1 / (n + 1)```。根据加权平均的计算方法求得的平均时间复杂度就是```O(1)```。

这个例子里的平均复杂度分析其实并 不需要这么复杂，不需要引入概率论的知识。先来对比一下这个```insert()```的例子和前面那个```find()```的例子，就会发现这两者有很大差别。

首先，```find()```函数在极端情况下，复杂度才为```O(1)```。但```insert()```在大部分情况下，时间复杂度都为```O(1)```。只有个别情况下，复杂度才比较高，为```O(n)```。这是```insert()```第一个区别于```find()的```地方。

对于```insert()```函数来说，```O(1)```时间复杂度的插入和```O(n)```时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个```O(n)```插入之后，紧跟着```n - 1```个```O(1)```的插入操作，循环往复。
所以，针对这样一种特殊场景的复杂度分析，并不需要像之前讲平均复杂度分析方法那样，找出所有的输入情况及相应的发生概率，然后再计算加权平均值。

针对这种特殊的场景，引入了一种更加简单的分析方法: 摊还分析法，均摊时间复杂度。

继续看在数组中插入数据的例子。每一次```O(n)```的插入操作，都会跟着```n - 1```次```O(1)```的插入操作，所以把耗时多的那次操作均摊到接下来的```n - 1```次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是```O(1)```。这就是均摊分析的大致思路。

均摊时间复杂度和摊还分析应用场景比较特殊，所以并不会经常用到。

对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。

尽管很多数据结构和算法书籍都花了很大力气来区分平均时间复杂度和均摊时间复杂度，但个人认为，均摊时间复杂度就是一种特殊的平均时间复杂度，没必要花太多精力去区分它们。最应该掌握的是它的分析方法，摊还分析。至于分析出来的结果是叫平均还是叫均摊，这只是个说法，并不重要。







## 2. 栈

栈是基础的数据结构，是一种遵从后进先出原则的有序集合。只能从栈顶添加或者移除。通过原生```js```实现一个栈。

```js
class Stack {
  constructor () {
    // 存储栈的数据
    this.data = {}
    // 记录栈的数据个数（相当于数组的 length）
    this.count = 0
  }
  // push() 入栈方法
  push (item) {
    // 方式1：数组方法 push 添加，但并不好，额外引入了数组的属性
    // this.data.push(item)
    // 方式2：利用数组长度，性能比push好，但也是数组的能力
    // this.data[this.data.length] = item
    // 方式3：计数方式
    this.data[this.count] = item
    // 入栈后，count 自增
    this.count++
  }
  // pop() 出栈方法
  pop () {
    // 出栈的前提是栈中存在元素，应先行检测
    if (this.isEmpty()) {
      console.log('栈为空！')
      return
    }
    // 移除栈顶数据
    // 方式1：数组方法 pop 移除
    // return this.data.pop()
    // 方式2：计数方式
    const temp = this.data[this.count - 1]
    delete this.data[--this.count]
    return temp
  }
  // isEmpty() 检测栈是否为空
  isEmpty () {
    return this.count === 0
  }
  // top() 用于获取栈顶值
  top () {
    if (this.isEmpty()) {
      console.log('栈为空！')
      return
    }
    return this.data[this.count - 1]
  }
  // size() 获取元素个数
  size () {
    return this.count
  }
  // clear() 清空栈
  clear () {
    this.data = []
    this.count = 0
  }
}

const s = new Stack()
s.push('a')
s.push('b')
s.push('c')
```

这里栈的```data```和```count```应该是确保不会被修改的，一旦被修改数据就乱了，可以将属性设置为私有，让外部无法访问。

### 1. 包含min函数的栈

就是通过一个函数找到栈中的最小值。

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的```min```函数在该栈中，调用```min```、```push```及```pop```的时间复杂度都是```O(1)```。常数的时间复杂度，不会因为数据量增加而增加。

```js
// 在存储数据的栈外，再新建一个栈，用于存储最小值
class MinStack {
  constructor () {
    // stackA 用于存储数据
    this.stackA = []
    this.countA = 0
    // stackB 用于将数据降序存储（栈顶值为最小值）
    this.stackB = []
    this.countB = 0
  }
  // 入栈
  push (item) {
    // stackA 正常入栈
    this.stackA[this.countA++] = item
    // stackB 如果没有数据，直接入栈
    // 如果 item 的值 <= stackB 的最小值，入栈
    if (this.countB === 0 || item <= this.min()) {
      this.stackB[this.countB++] = item
    }
  }
  // 最小值函数
  min () {
    return this.stackB[this.countB - 1]
  }
  // 获取栈顶值
  top () {
    return this.stackA[this.countA - 1]
  }
  // 出栈
  pop () {
    // 先进行 stackB 的检测
    // 如果 stackA 的栈顶值 === stackB 的栈顶值，stackB 出栈
    if (this.top() === this.min()) {
      delete this.stackB[--this.countB]
    }
    // stackA 出栈
    delete this.stackA[--this.countA]
  }
}

const m = new MinStack()
```

还可以利用内置的方法来实现，编写起来非常简单，只不过执行效率上就会有所降低。

```js
class MinStack {
  constructor () {
    this.stack = []
  }
  // 入栈
  push (item) {
    this.stack.push(item)
  }
  // 查看栈顶值
  top () {
    return this.stack[this.stack.length - 1]
  }
  // 实现最小值功能
  min () {
    return Math.min.apply(null， this.stack)
  }
  // 出栈方法
  pop () {
    return this.stack.pop()
  }
}

const m = new MinStack()
```

### 2. 每日温度案例

根据每日气温列表，重新生成一个列表，对应位置的输出为，想要观测到更多的气温，至少需要等待的天数，如果气温在这之后都不会升高，该位置用0来代替。

例如给定一个列表```[73， 74， 75， 71， 69， 72， 76， 73]```输出的应该是```[1， 1， 4， 2， 1， 1， 0， 0]```。

如果采用循环的方式会重复很多次，效率就比较低了，可以利用栈的数据结构简书数据操作次数，减少时间复杂度。

让栈存储递减的规律，每找到一个数据就将它与栈顶值比较，如果比栈顶值小就放在栈中，形成一个递减的栈，如果这个值比栈顶的值大将栈顶值出栈，也就是找到了比他更大的温度。可以将当前的位置与栈顶位置做差，差就是升温等待的天数了。

```js
/**
 * @param {number[]} T 每日温度数组 [73， 74， 75， 71， 69， 72， 76， 73]
 * @return {number[]} 等待天数列表 [1， 1， 4， 2， 1， 1， 0， 0]
 */
var dailyTemperatures = function(T) {
  // 创建单调栈用于记录（存储索引值，用于记录天数）
  const stack = [0]
  let count = 1

  // 创建结果数组（默认将结果数组使用 0 填充）
  const len = T.length
  const arr = new Array(len).fill(0)

  // 遍历 T
  for (let i = 1; i < len; i++) {
    let temp = T[i]
    // 使用 temp 比较栈顶值，如果栈顶值小，出栈（计算日期差，并存储），并重复操作
    //  - stack[count - 1] 代表栈顶值
    while (count && temp > T[stack[count - 1]]) {
      // 出栈
      let index = stack.pop()
      count--
      // 计算 index 与 i 的差，作为 index 位置的升温日期的天数使用 
      arr[index] = i - index
    }
    // 处理完毕，当前温度入栈（等待找到后续的更大温度）
    stack.push(i)
    count++
  }
  return arr
}
```

## 3. 队列

队列是一种遵从先进先出原则的有序集合，添加新元素的一端叫做队尾，另一端称为对首。

### 1. 基于数组的队列实现

出队enqueue和入队dequeue核心功能，top获取队首的值，size获取队列元素个数，clear清空队列。

delete删除的时候数据会删除掉，但是位置还是在的。

```js
class Queue {
  constructor () {
    // 用于存储队列数据
    this.queue = []
    this.count = 0
  }
  // 入队方法
  enQueue (item) {
    this.queue[this.count++] = item
  }
  // 出队方法
  deQueue () {
    if (this.isEmpty()) {
      return
    }
    // 删除 queue 的第一个元素
    // delete this.queue[0]
    // 利用 shift() 移除数组的第一个元素
    this.count--
    return this.queue.shift()
  }
  isEmpty () {
    return this.count === 0
  }
  // 获取队首元素值
  top () {
    if (this.isEmpty()) {
      return
    }
    return this.queue[0]
  }
  size () {
    return this.count
  }
  clear () {
    // this.queue = []
    this.length = 0
    this.count = 0
  }
}

const q = new Queue()
```

### 2. 基于对象方式实现

对象是可以实现delete删除元素的，这一点要比数组好很多。

```js
class Queue {
  constructor () {
    this.queue = {}
    this.count = 0
    // 用于记录队首的键
    this.head = 0
  }
  // 入队方法
  enQueue (item) {
    this.queue[this.count++] = item
  }
  // 出队方法
  deQueue () {
    if (this.isEmpty()) {
      return
    }
    const headData = this.queue[this.head]
    delete this.queue[this.head]
    this.head++
    this.count--
    return headData
  }
  isEmpty () {
    return this.count === 0
  }
  clear () {
    this.queue = {}
    this.count = 0
    this.head = 0
  }
}

const q = new Queue()
```

### 3. 双端队列

双端队列允许同时从队尾和队首两端进行存储操作的队列，操作更加灵活。首尾都可以添加和删除。

双端队列与js中的数组操作十分类似，只是不允许在数组中间位置进行存取，只能操作两端。

```js
class Deque {
  constructor () {
    this.queue = {}
    this.count = 0
    this.head = 0
  }
  // 队首添加
  addFront (item) {
    this.queue[--this.head] = item
  }
  // 队尾添加
  addBack (item) {
    this.queue[this.count++] = item
  }
  // 队首删除
  removeFront () {
    if (this.isEmpty()) {
      return
    }
    const headData = this.queue[this.head]
    delete this.queue[this.head++]
    return headData
  }
  // 队尾删除
  removeBack () {
    if (this.isEmpty()) {
      return
    }
    const backData = this.queue[this.count - 1]
    delete this.queue[--this.count]
    // this.count-- 与 上一步 this.count - 1 合并
    return backData
  }
  // 获取队首值
  frontTop () {
    if (this.isEmpty()) {
      return
    }
    return this.queue[this.head]
  }
  // 获取队尾值
  backTop () {
    if (this.isEmpty()) {
      return
    }
    return this.queue[this.count - 1]
  }
  isEmpty () {
    return this.size() === 0
  }
  size () {
    return this.count - this.head
  }
}

const deq = new Deque()
```

### 4. 队列的最大值

定义一个队列并实现函数max_value得到队列里的最大值，要求函数max_value、push_back和pop_front的时间复杂度都是O(1)。时间复杂度是一个常数，而遍历是会跟长度相关的是O(n)所以不能通过这样的方式。

队列为空时返回值-1即可。

主要难点就是O1复杂度，可以通过双端队列进行数据存储，每次取到数据就去判断队列是否有值，如果没值就添加到队列中，否则就判断新值和之前值的关系，如果当前的值比队列最后的值小就存储，如果比队尾的值大，就将队尾的值出队，重复这种操作维持队列单调递减。这样队首就是最大值，队尾是最小值。

```js
var MaxQueue = function() {
  // 存储队列数据
  this.queue = {}
  // 双端队列维护最大值（每个阶段的最大值）
  this.deque = {}
  // 准备队列相关的数据
  this.countQ = this.countD = this.headQ = this.headD = 0
};

/** 队尾入队
 * @param {number} value
 * @return {void}
 */
MaxQueue.prototype.push_back = function(value) {
  // 数据在 queue 入队
  this.queue[this.countQ++] = value
  // 检测是否可以将数据添加到双端队列
  //   - 队列不能为空
  //   - value 大于队尾值
  while (!this.isEmptyDeque() && value > this.deque[this.countD - 1]) {
    // 删除当前队尾值
    delete this.deque[--this.countD]
  }
  // 将 value 入队
  this.deque[this.countD++] = value
};

/** 队首出队
 * @return {number}
 */
MaxQueue.prototype.pop_front = function() {
  if (this.isEmptyQueue()) {
    return - 1
  }
  // 比较 deque 与 queue 的队首值，如果相同，deque 出队，否则 deque 不操作
  if (this.queue[this.headQ] === this.deque[this.headD]) {
    delete this.deque[this.headD++]
  }
  // 给 queue 出队，并返回
  const frontData = this.queue[this.headQ]
  delete this.queue[this.headQ++]
  return frontData
};

/** 获取队列最大值
 * @return {number}
 */
MaxQueue.prototype.max_value = function() {
  if (this.isEmptyDeque()) {
    return -1
  }
  // 返回 deque 队首值即可
  return this.deque[this.headD]
};

/** 检测队列 deque 是否为空
 * 
 */
MaxQueue.prototype.isEmptyDeque = function () {
  return !(this.countD - this.headD)
};

/** 检测队列 Queue 是否为空
 * 
 */
MaxQueue.prototype.isEmptyQueue = function () {
  return !(this.countQ - this.headQ)
};
```

### 5. 滑动窗口最大值

给你一个整数数组，有一个大小为k的滑动窗口从数组的最左侧移动到数组的最右侧，你只可以看到在滑动窗口内的k个数字，滑动窗口每次向右移动一位，返回滑动窗口中的最大值。

```js
/**
 * @param {number[]} nums 传入数组
 * @param {number} k 滑动窗口宽度
 * @return {number[]} 
 */
var maxSlidingWindow = function(nums， k) {
  if (k <= 1) {
    return nums
  }
  const result = []
  const deque = []
  // 1 将窗口第一个位置的数据添加到 deque 中，保持递减
  deque.push(nums[0])
  let i = 1
  for (; i < k; i++) {
    // - 存在数据
    // - 当前数据大于队尾值
    //   - 出队，再重复比较
    while (deque.length && nums[i] > deque[deque.length - 1]) {
      deque.pop()
    }
    deque.push(nums[i])
  }
  // 将第一个位置的最大值添加到 result
  result.push(deque[0])

  // 2 遍历后续的数据
  const len = nums.length
  for (; i < len; i++) {
    // 同上进行比较
    while (deque.length && nums[i] > deque[deque.length - 1]) {
      deque.pop()
    }
    deque.push(nums[i])
    // 检测当前最大值是否位于窗口外
    if (deque[0] === nums[i - k]) {
      deque.shift()
    }
    // 添加最大值到 result
    result.push(deque[0])
  }

  return result
};
```

## 4. 链表

链表是有序的数据结构，类似链条，链表可以在首位以及中间任意位置进行操作，灵活度更高。链表中的元素在内存中不必是连续的。删除和添加不会其余元素位移。同时也无法根据索引快速定位。

数组在内存中需要占据一段连续的空间，同时数组在做添加，移除会导致后续元素位移，性能开销比较大。

获取修改元素时，数组效率高，添加删除时链表效率高。

### 1. 实现链表

要实现节点功能，value存储当前节点属性，next存储下一个节点的指针，这样就形成了关联。

可以通过addAtTail在尾部添加节点，addAthead在头部添加节点，addAtIndex在指定位置添加节点。get获取节点，removeAtIndex删
除指定节点。

要先定义节点类，然后基于节点类实现链表类。

```js
// 节点类
class LinkedNode {
  constructor (value) {
    this.value = value
    // 用于存储下一个节点的引用
    this.next = null
  }
}

// 链表类
class LinkedList {
  constructor () {
    this.count = 0
    this.head = null
  }
  // 添加节点 (尾）
  addAtTail (value) {
    // 创建新节点
    const node = new LinkedNode(value)
    // 检测链表是否存在数据
    if (this.count === 0) {
      this.head = node
    } else {
      // 找到链表尾部节点，将最后一个节点的 next 设置为 node
      let cur = this.head
      while (cur.next != null) {
        cur = cur.next
      }
      cur.next = node
    }
    this.count++
  }
  // 添加节点（首）
  addAtHead (value) {
    const node = new LinkedNode(value)
    if (this.count === 0) {
      this.head = node
    } else {
      // 将 node 添加到 head 的前面
      node.next = this.head
      this.head = node
    }
    this.count++
  }
  // 获取节点（根据索引）
  get (index) {
    if (this.count === 0 || index < 0 || index >= this.count) {
      return
    }
    // 迭代链表，找到对应节点
    let current = this.head
    for (let i = 0; i < index; i++) {
      current = current.next
    }
    return current
  }
  // 添加节点（根据索引）
  addAtIndex (value， index) {
    if (this.count === 0 || index >= this.count) {
      return
    }
    // 如果 index <= 0，都添加到头部即可
    if (index <= 0) {
      return this.addAtHead(value)
    }
    // 后面为正常区间处理
    const prev = this.get(index - 1)
    const next = prev.next

    const node = new LinkedNode(value)
    prev.next = node
    node.next = next

    this.count++
  }
  // 删除（根据索引）
  removeAtIndex (index) {
    if (this.count === 0 || index < 0 || index >= this.count) {
      return
    }
    if (index === 0) {
      this.head = this.head.next
    } else {
      const prev = this.get(index - 1)
      prev.next = prev.next.next
    }
    this.count--
  }
}

// 测试代码
const l = new LinkedList()
l.addAtTail('a')
l.addAtTail('b')
l.addAtTail('c')
```

### 2. 双向链表

双向链表是在普通链表的基础上，增加一个用于记录上一个节点的属性的prev，可进行双向访问。这样每个节点就有三个属性，可以进行双向访问了。

### 3. 循环链表

循环链表又称为环形链表，指的是链表的最后一个节点的next指向第一个节点，形成首位相连的环形结构。

在实际使用中，环的结束点可以为链表的任意节点。

### 4. 反转链表

迭代方式

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
  // 声明变量记录 prev、cur
  let prev = null
  let cur = head
  // 当 cur 是节点时，进行迭代
  while (cur) {
    // 先保存当前节点的下一个节点
    const next = cur.next
    cur.next = prev
    prev = cur
    cur = next
  }
  return prev
};
```

递归方式

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
  if (head === null || head.next === null) {
    return head
  }
  const newHead = reverseList(head.next)
  // 能够第一次执行这里的节点为 倒数第二个 节点
  head.next.next = head
  // head 的 next 需要在下一次递归执行时设置。当前设置为 null 不影响
  //   - 可以让最后一次（1）的 next 设置为 null
  head.next = null
  return newHead
};
```

### 5. 环路检测

给定一个链表，如果是有环链表，返回环路的开头节点，如果链表中有某个节点，可以通过李先耐心追踪next指针再次到达，则链表中存在环，为了表示给定链表中的环，使用证书pos来表示链表尾链接到表中的位置。

如果pos是-1，则在该链表中没有环，pos不作为参数传递，仅仅是标识链表是实际情况。

其实就是环形链表，首先要判断是不是环形链表，

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function(head) {
    if (head === null || head.next === null) {
      return null
    }
    // 声明快慢指针
    let slow = head
    let fast = head

    while (fast !== null) {
      // 慢每次指针移动一位
      slow = slow.next
      // 如果满足条件，说明 fast 为尾部结点，不存在环
      if (fast.next === null) {
        return null
      }
      // 快指针每次移动两位
      fast = fast.next.next

      // 检测是否有环
      if (fast === slow) {
        // 找到环的起点位置
        let ptr = head
        while (ptr !== slow) {
          ptr = ptr.next
          slow = slow.next
        }
        // ptr 和 slow 的交点就是环的起始节点
        return ptr
      }
    }
    // while 结束，说明 fast 为 null，说明链表没有环
    return null
};
```

## 5. 树与二叉树

树存在多个节点，每个节点又存在多个节点，树形结构存在层次关系，

树型结构是一种非线性的数据结构，树中的每个部分称为节点，节点间存在分支结构和层次关系。

每个树形结构都具有一个根节点，节点间具有父子兄弟关系。不含子节点的节点称为叶节点。子树是针对某个节点及该节点子孙节点的称呼。

数中最深节点的层级称为树的高度，

二叉树是树形结构中的一种，二叉树中的每个节点最多只能有两个子节点。称为左子节点和右子节点。子节点的树又称为左子树和右子树。

除叶子节点外每个节点都有两个子节点的树称为满二叉树。每层节点都达到最大值。

二叉树除最后一层，每层节点都达到最大值，且最后一层节点都位于左侧，叫做完全二叉树。

由于完全二叉树的结构连续，有迹可循，所以可以采用顺序存储方式。

普通二叉树由于结构不规则，不适合使用顺序存储，为了记录节点间的关系，可使用链式存储方式。每个节点通过value表示值，left，right表示左右子节点。

### 1. 二叉树遍历

根据访问顺序不同存在三种遍历形式，前序遍历，中序遍历，后序遍历。序表示根节点的访问顺序。

前序遍历: 根节点 > 左子树 -> 右子树

中序遍历: 左子树 -> 根节点 -> 右子树

后序遍历: 左子树 -> 右子树 -> 根节点

### 2. 前序遍历

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val， left， right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
/* var preorderTraversal = function(root) {
  // 用于存储遍历的结果
  const res = []
  // 设置函数用于进行递归遍历
  const preorder = (root) => {
    // 当前结点为空时，无需进行递归
    if (!root) {
      return
    }
    // 记录根节点值
    res.push(root.val)
    // 前序遍历左子树
    preorder(root.left)
    // 前序遍历右子树
    preorder(root.right)
  }
  preorder(root)
  return res
}; */

const preorderTraversal = function(root) {
  const res = []
  const stk = []
  while (root || stk.length) {
    while (root) {
      // 右子结点入栈
      stk.push(root.right)
      // 记录根节点
      res.push(root.val)
      // 下一步处理左子节点
      root = root.left
    }
    // 左子树处理完毕，将 stk 出栈，处理右子树
    root = stk.pop()
  }
  return res
}
```

### 3. 最大深度

给定一个二叉树，找出其最大深度，二叉树的深度为根节点到最远叶子节点的最长路径上的点数。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val， left， right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
  if (!root) {
    return 0
  }
  return Math.max(maxDepth(root.left)， maxDepth(root.right)) + 1
};
```

### 4. 层序遍历

给定一个二叉树，返回层序遍历的节点值。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val， left， right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
  const res = []
  if (!root) {
      return res
  }
  // 声明队列用于存储后续数据
  const q = []
  q.push(root)

  // 遍历队列
  while (q.length !== 0) {
      // 针对本轮操作，创建一个新的二维数组
      res.push([])
      let len = q.length
      for (let i = 0; i < len; i++) {
          // 将本次操作的结点出队
          const node = q.shift()
          res[res.length - 1].push(node.val)
          // 检测是否存在左右子结点，如果有，入队即可
          if (node.left) {
              q.push(node.left)
          }
          if (node.right) {
              q.push(node.right)
          }
      }
  }
  return res
};
```

### 5. 二叉搜索树

是一种特殊的二叉树形式，简称BST，左子树的节点小于根节点，右子树的节点大于根节点。子树也为二叉搜索树。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val， left， right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
/* var isValidBST = function(root) {
  // 通过一个辅助函数来统一设置左右子树的比较
  return helper(root， -Infinity， Infinity);
};

const helper = (root， lower， upper) => {
  if (root === null) {
    return true
  }
	// 当前节点值超出边界，说明二叉树为非 BST
  if (root.val <= lower || root.val >= upper) {
    return false;
  }
  // 否则，递归处理左右子节点，并更新大小范围
  // 同时根据左右子节点的返回值进行返回，只有全部递归结果均为 true， 才说明二叉树为 BST
  return helper(root.left， lower， root.val) && helper(root.right， root.val， upper);
} */

/**
 * Definition for a binary tree node.
 * function TreeNode(val， left， right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function(root) {
  let stk = []
  // 用于记录上一次取得的节点值，BST 中这个值应小于当前节点
  // 设置默认值为 -Infinity 避免对比较结果产生干扰
  let oldNode = -Infinity

  while (root || stk.length) {
    while (root) {
      stk.push(root) 
      root = root.left
    }
    root = stk.pop()
    // 如果任意节点比上个节点值小，说明二叉树不是 BST
    if (root.val <= oldNode) {
      return false
    }
    // 通过比较，记录当前节点值
    oldNode = root.val
    root = root.right
  }
  return true
};
```




