## 1. 异步编程

众所周知，目前主流的```javaScript```环境，都是以单线程的模式去执行的```javaScript```代码，那```javaScript```采用单线程工作的原因与他最早的设计初衷有关。

最早```javaScript```这门语言就是一门运行在浏览器端的脚本语言，那他的目的是为了实现页面上的动态交互。

而实现页面交互的核心就是```dom```操作，那这也就决定了，他必须使用单线程模型，否则就会出现很复杂的线程同步问题。

可以设想一下，假定在```javaScript```中同时有多个线程一起工作，那其中一个线程修改了某一个```dom```元素，而另外一个线程同时又删除了这个元素，那此时的浏览器就无法明确，该以哪一个线程的工作结果为准。

所以说为了避免这种线程同步的问题，从一开始```javaScript```就被设计成了单线程模式工作，那这也就成为了这门语言最为核心的特性之一。

那这里所说的单线程指的就是，在```js```的执行环境当中，负责执行代码的线程只有一个。

可以想象成，在内部只有一个人按照代码执行任务。因为只有一个人所以同时也就只能执行一个任务，那如果说有多个任务的话就必须要排队，然后一个一个依次去完成。

这种模式最大的优点就是安全简单，缺点也同样很明显，如果遇到一个特别耗时的任务后面的这些任务都必须要排队，等待这个任务的结束。

```js
console.log('foo');

for (let i = 0; i < 100000; i++) {
    console.log('耗时操作');
}

console.log('等待耗时操作结束');
```

这也就会导致整个程序的执行会被拖延出现假死的情况。

为了解决耗时任务阻塞执行的这种问题，```javaScript```语言将任务的执行模式分成了两种。分别是同步模式(```Synchronous```)和异步模式(```Asynchronous```)。

在这里重点要了解的就是在```javaScript```中与异步编程相关的一些内容，主要包括以下几点。

## 2. 同步模式

同步模式指的就是代码中任务依次执行，后一个任务必须等待前一个任务结束才能开始执行，程序的执行顺序跟代码的编写顺序是完全一致的，也就是说这种方式会比较简单。

在单线程的情况下大多数任务都会以同步模式去执行，注意这里说的同步并不是指同时执行，而是排队执行。

以一段同步模式的代码为例，分析具体执行过程。

```js
console.log('global begin')

function bar() {
    console.log('bar task')
}

function foo() {
    console.log('foo task')
    bar()
}

foo()

console.log('global end')
```

开始执行时```js```引擎会把整体额代码全部加载进来，然后在调用栈中压入一个匿名的调用可以理解为把全部的代码放到了一个匿名函数当中去执行。

然后开始逐行执行这里每一行的代码，首先是第一行遇到了```console.log```调用，会把console.log压入调用栈去执行，执行过程中控制台打印了对应的消息```global begin```，```console.log```调用结束，弹出调用栈。代码继续向下执行。

往下是两个函数的声明，不管是函数还是变量的声明他都不会产生任何的调用，所以说这里的执行会继续往下。

在往下是``foo``函数的调用，对于函数调用同样要压入调用栈，然后开始执行```foo```函数。

```foo```函数一开始先打印了一个消息，打印完成过后调用了```bar```函数，这里的```bar```函数也会被放入到调用栈当中去执行。

```bar```函数执行的过程当中又打印了一次，打印完成```bar```函数也就执行完成，调用栈中```bar```函数会被弹出。然后紧接着```foo```函数执行结束同样从调用栈中弹出。

最后打印了```global end```, 然后整体的代码全部结束。调用栈会被清空掉。

这里的调用栈只是一个更专业的说法，通俗一点的解释就是```js```在执行引擎当中维护了一个正在工作的工作表，或者说正在执行的工作表。这个里面会记录当前正在做的一些事情，当这个工作表中所有的任务全部被清空过后，这一轮的工作就算是结束了。

这是一个纯同步模式下的执行情况。所以说特别容易理解，因为他整个执行过程非常符合正常的阅读逻辑或者说思考逻辑。

不过这种排队执行的机制，存在一个很严重的问题就是如果其中的某一个任务或者更具体点说就是其中的某一行代码执行的时间过长，后面的任务就会被延迟。把这种延迟称之为阻塞。

阻塞对于用户而言就意味着界面会有卡顿或者说卡死，所以说就必须要有异步模式来解决程序中那些无法避免的耗时操作。例如在浏览器端的ajax操作，或者在nodejs当中的大文件读写。这些耗时任务需要使用到异步模式去执行，从而去避免代码被卡死。

## 3. 异步模式

不同于同步模式的执行方式，异步模式的```API```是不会等待这个任务的结束才开始执行下一个任务。对于耗时操作他都是开启过后就立即往后执行下一个任务。耗时任务的后续逻辑呢会通过回调函数的方式去定义，在内部这个耗时任务完成过后会自动执行传入的回调函数。

异步模式对于```javaScript```非常重要，如果没有这种模式的话，单线程的```javaScript```语言就无法同时处理大量的耗时任务。而对于开发者而言，单线程模式下的异步最大的难点就是代码执行的顺序并不会像同步代码一样通俗易懂。因为他的执行顺序相对会比较跳跃，对于这个问题更多的是需要理解和习惯，最好的办法就是多看，多练，多思考。

这里同样以一段包含异步调用的代码分析一下，在```javaScript```当中，异步执行的过程。

这段代码最外层包含了两个```setTimeout```，第二个```setTimeout```函数内部又去使用了一次```timeout```。

```js
console.log('global begin')

setTimeout(function timer1() {
    console.log('timer1 invoke')
}, 1800)

setTimeout(function timer2() {
    console.log('timer2 invoke')

    setTimeout(function inner() {
        console.log('inner invoke')
    }, 1000)

}, 1000)

console.log('global end')
```

因为有异步调用的过程相对会复杂一点，所以要介绍到的东西也相对会多一些。首先是内部```API```的环境，以web平台举例，也就是```web api```，然后是事件循环和消息队列。也有人把消息队列称之为回调队列。作用遇到的时候再说。整体的执行情况大致与前面所分析的同步模式情况相同，只不过在遇到异步调用时会有一些差异，具体来看。

首先也是加载整体的代码然后在调用栈中压入一个匿名的全局调用，然后依次执行每一行代码。对于```console.log```这样的同步```api```还是一样的，先压栈然后再执行，执行过程中打印，打印过后弹栈。

再往后遇到```setTimeout```调用，同样也是先将```setTimeout```压入到调用栈，但是这个函数的内部是异步调用，所以需要关心内部```API```环境到底做了什么事情。

其实在内部的```api```也非常简单，就是在内部为这个```timer1```函数开启了一个倒计时器，然后单独放到一边，注意这里的倒计时器是单独工作的，并不会受当前的```js```线程影响。并且从最开始就已经在倒数了，只不过这里是分步骤去演示。就让他在一旁默默的倒数，待会再来看倒数完了过后他做的事情。

开启倒计时器过后对于```settimeout```函数来讲，他的调用就已经完成了，所以说代码会继续往下执行。然后又遇到了一个```setimeout```调用，同理也是先压栈，然后开启另一个倒计时器。然后弹栈。最后又遇到了```console.log```调用，打印了消息过后对于整体的这个匿名调用就已经完成了。所以说这个调用栈就会被清空掉。

然后这时候```Event loop```因为调用栈里面已经没有工作了，所以说```Event loop```就会发挥作用。```Event loop```其实只做一件事情，就是负责监听调用栈和消息队列，一但调用栈当中所有的任务都结束了，事件循环就会从消息队列中取出第一个回调函数压入到调用栈。只不过此时消息队列当是空的什么都没有，所以说执行就相当于是暂停下来了。

此时回过头看一看这里的两个倒计时器，自从前面开启了这两个倒计时过后代码就再也没有管过他们。而是直接往后执行了。这里```timer1```函数所对应的倒计时他应该是倒计```1.8s```，```timer2```是```1s```。很明显，```timer2```所对应的倒计时应该先结束。

结束后```timer2```函数就会被放入到消息队列的第一位，```timer1```对应的倒计时结束后会放入到消息队列的第二位。

一但消息队列中发生了变化，事件循环就会监听到然后把消息队列中的第一个也就是```timer2```函数取出来，压入到调用栈。继续执行```timer2```。此时对于调用栈来讲的话，相当于开启了新一轮的执行。执行过程与刚刚分析的是一致的。

如果这个过程中又遇到了有异步调用，也是相同的情况，先会把他放入到```api```环境里面单独去执行，然后在往后就是不断这样重复。直到调用栈和消息队列当中都没有需要继续执行的任务了整体的代码就结束了。

如果说调用栈是一个正在执行的工作表，那消息队列就可以理解成一个待办的工作表，而```js```执行引擎就是先去做完调用栈当中所有的任务，然后再通过事件循环从消息队列当中再取一个任务出来。继续去执行。以此类推。整个过程随时都可以往消息队列当中再去放入一些任务，这些任务在消息队列中会排队等待事件循环。

以上就是异步调用在```javaScript```当中的实现过程以及他的一个基本的原理。

整个过程都是通过内部的消息队列和事件循环去实现的，因为这里是分开分析的，所以说你会认为这些步骤都会有一定的先后顺序，其实不是这样的。因为他们各自都有各自的```time-line```例如倒计时器，他开始过后就会自动开始倒计时，根本不会管调用栈或者队列当中是什么情况。

只不过这分析时，如果同步分析的话会觉得特别乱，所以说这里特别安排了几个时间点。尽量确保执行顺序跟分析顺序是一致的。这一点需要额外注意一下。

可能接下来的这张图可以更清楚地表述出这一点。

例如在```js```当中。```js```线程某一时刻发起了一个异步调用。然后紧接着往后执行其他的任务。此时异步线程会单独去执行这个异步任务，然后在执行完这个任务过后会将这个任务的回调放入到消息队列，```js```主线程完成所有的任务过后会再依次执行消息队列当中的任务。

这里特别需要注意一点的是```javaScript```确实是单线程的，而浏览器并不是单线程的。

更具体一点来说就是通过```javaScript```调用的某些内部的```api```并不是单线程的。例如这里所使用的的倒计时器，他内部就会有一个单独的线程去负责倒数，在时间到了之后会将回调放入到消息队列。也就是说这件事是有单独的线程去做的，所说的单线程指的是执行代码的那个线程是一个线程。

拿生活角度来说有些事情耗时是必然需要等的，总得有一个人去等，只不过是不会让```js```线程去等。

那除此以外这里所说的同步也好异步也好，肯定不是指写代码的方式，而是说运行环境提供的```API```到底是以同步模式还是以异步模式的方式去工作。

对于同步模式的```API```特点呢是任务执行完代码才会继续往下走，例如```console.log```。

对于异步模式的API就是下达这个任务开启过后的指令就会继续往下执行，代码是不会在这一行等待任务的结束的。例如```setTimeout```。

## 4. 回调函数

正如前面所说，异步模式对于单线程的```javaScript```语言非常重要。同时也是```javaScript```的核心特点。也正是因为大量异步模式```API```的关系导致写出来的```js```代码相对就没有那么容易阅读，执行顺序相对来说也会复杂很多，特别是对于复杂的一些异步逻辑。

从这样一个角度来讲```javaScript```实际上是不适合初学者的，但是一般可能会有一些传统的固化的逻辑思维，一但打破这种传统的逻辑思维过后，其实也还好，不会有那么夸张。

接下来重点介绍js中那些为异步而生的语法。特别是在```ES 2015```过后推出的一系列新语法，新特性。这些语法特性慢慢弥补了```javaScript```在异步编程这块的不足或是不便。

首先先来看一下```javaScript```中实现异步编程的根本方式。其实所有的异步编程方案根本都是回调函数，回调函数可以理解成一件想要做的事情，你明确知道这件事情应该怎么做，怎么样一步一步的往下做。但是你并不知道这件事情所依赖的任务什么时候才能完成，所以说最好的办法就是把你的这件事的步骤写到一个函数中交给任务的执行者。

异步任务的执行者是知道这个任务什么时候结束的，就可以在结束过后帮你执行你想要去做的事情。这件想要做的事情就可以理解成回调函数。

这么说可能会比较抽象，具体一点。比如说现在想给我的桌子重新刷一遍漆，我明确知道我想要怎么去刷，但是我没有油漆，我得让你帮我去买一桶油漆，你去买油漆实际上需要一定的时间而我又会有很多其他的事情要做，所以说我不能在这个地方干等着你，我就会选择把这个桌子应该怎么刷的步骤写到一个纸条上面，然后一起交给你，完了过后我就去忙别的事情了，那你买完油漆回来过后就可以按照我纸条上的步骤一步一步的去帮我把这个桌子刷好就可以了。

在这个例子中，我实际上就是异步任务的调用者，而你就是具体的异步任务的执行者，我给你的写着步骤的这个纸条就是调用者所定义的回调函数。

以程序当中的ajax请求为例，调用ajax操作目的是为了拿到请求结果后做一些事情，例如把它显示到界面上。但是请求何时能完成并不知道，所以说得把响应之后要执行的任务定义到一个函数当中，ajax在请求完成过后会自动执行这个任务。

这种由调用者定义然后交给执行者去执行的函数就被称之为回调函数，具体的用法非常简单就只是把函数作为参数传递罢了。只不过这种方式的异步代码相对来说特别不利于阅读。而且整个过程执行顺序会非常的混乱。

```js
function foo (callback) {
    setTimeout(function () {
        callback()
    }, 3000)
}

foo(function() {
    console.log('这就是一个回调函数')
    console.log('调用者定义这个函数，执行者执行这个函数')
    console.log('其实就是调用者告诉执行者异步任务后应该做什么')
})
```

除了传递回调函数参数这种方式以外，还有几种常见的实现异步方式，例如事件机制或者发布订阅。不过个人认为这些也都是基于回调函数基础之上的一些变体罢了，所以在这就不做具体的探讨了。

## 5. Promise概述

回调函数可以说是```javaScript```所有异步编程方式的根基，但是如果直接使用传统回调的方式去完成复杂的异步流程，就无法避免大量的异步回调函数嵌套, 也就会导致人们常说的回调地狱问题。

为了避免回调地狱问题，```CommonJS```社区率先提出了一种叫做```Promise```的规范，目的就是为异步编程提供一种更合理更强大的统一解决方案，后来在```ES2015```中被标准化进了语言规范。

```Promise```实际上是一个用来表示异步任务结束后是成功还是失败状态的。就像内部对外界做出了一个承诺，一开始这个承诺是一种待定的状态，英文叫做```pendding```，最终有可能成功，英文叫做```Fulfilled```，也有可能失败，英文是```Rejected```。

例如我承诺给你买一件大衣，那此时你就会等待我这个承诺的结果，也就是说此时我的这个承诺是个待定的状态，如果确实我买回来了这件大衣，这个承诺也就成功了，反之不管因为什么原因我没有买回来这件大衣，这个承诺就是失败了。

承诺结束过后不管这个承诺最终是达成或者是失败，都会有相应的反应，比如说如果达成了可能会很感激，如果说失败了可能会臭骂一顿。这也就是说，在承诺状态最终明确了过后，都会有相对应的任务会被执行。

而且这种承诺会有一个很明显的特点，就是一旦明确了结果过后就不可能再发生改变了，例如我没有买到大衣，这个买大衣的承诺就是失败了的，不可能再变成成功。即便是说我以后再给你买了，那也是以后的事情，对于一开始的这个承诺他还是失败的。

落实到程序上，例如你需要我去帮你发送一个```ajax```请求，你可以理解为我承诺帮你请求一个地址，这个请求最终有可能成功，成功就调用你的```onFulfilled```回调，如果请求失败的话，就会调用你的```onRejected```回调。这就是```Promise```的概念。

## 6. Promise 基本用法

在代码层面```Promise```实际上是```ES2015```提供的全局类型，可以使用他来构造一个```Promise```实例也就是创建一个承诺，这个类型的构造函数需要接收一个函数作为参数。函数就可以理解为兑现承诺的逻辑，函数会在构造```Promise```的过程被同步执行。在这个函数内部它能够接收到两个参数，分别是```resolve```和```reject```，二者都是一个函数。```resolve```函数的作用就是将对象的状态修改为```Fulfilled```也就是成功。一般将异步任务的结果会通过```resolve```的参数传递出去，比如传入```100```固定值。```reject```函数的作用是将```Promise```的状态修改为```rejected```也就是失败。失败的参数一般传递的是一个错误的对象，用来表示承诺为什么失败，也就是一个理由。可以传入一个全新的错误对象。然后错误的描述描述就是```promise rejected```

```js

const promise = new Promise(function(resolve, reject) {
    // 这里用于兑现承诺
    resolve(100) // 承诺达成
    reject(new Error('promise rej