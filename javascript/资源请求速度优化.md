## 1. DNS解析

当浏览器从第三方服务器请求资源时，必须先将该跨域域名解析为```IP```地址，然后浏览器才能发出请求，此过程称为```DNS```解析。

```DNS```作为互联网的基础协议，其解析的速度似乎很容易被网站优化人员忽略，现在大多数新流量乃全已经针对DNS解析进行了优化，比如```DNS```缓存。

典型的一次```DNS```解析需要耗费```20-120```毫秒，所花费的时间几乎可以忽略不计，但是当网站中使用的资源依赖多个不同域的时候，时间就会成倍增加，从而增加了网站的加载时间。

比如某些图片较多的页面中，在发起图片加载请求之前预先把域名解析好将会有至少5%的图片加载速度提成。

一般来说前端与华中与```DNS```有关的有两点，一是减少```DNS```的请求次数(缓存```DNS```地址)，二是进行```DNS```的预获取，```DNS Prefetch```。

```dns```缓存可以在服务器设置```DNS```缓存的时间，不经常变更的```ip```建议设置的时间长一些。尽可能使用```A```或者```AAAA```代替```CNAME```，使用```CND```加速域名。还可以自己搭建```DNS```服务。

```DNS```与解析可以在页面中通过```link```标签来实现。

```html
<link rel="dns-prefetch" href="https://fonts.googleapis.com" />
```

```DNS```与解析只能解析不同域，同域是不能解析的，因为已经解析完了。```dns-prefetch```要慎用，不要每个页面都添加，会造成资源浪费。默认情况下浏览器会对当前页面中所有出现的域名进行预解析，及时没有写```link```标签，这是隐式解析。

## 2. HTTP1.1长链接

经过```DNS```解析获取到```IP```之后就要进行```TCP```的链接进行数据传输。

```HTTP```协议的初始版本中，每进行一次```HTTP```通信就要断开一次```TCP```链接，也就是短连接。

以早期的通信情况来说，因为都是些容量很小的文本传输，所以即使这样也没有多大问题，但是随着```HTTP```的大量普及，文旦中包含大量富文本的情况多了起来。每次的请求都会造成无谓的```TCP```链接建立和断开，增加通信录的开销。

为了解决这个问题，有些浏览器在请求时，用了一个非标准的```Connection```字段。这个字段要求服务器不要关闭```TCP```链接，以便其他请求复用，服务器同样回应这个字段。

```s
Connection: keep-alive
```

一个可以复用的```TCP```链接就建立了，直到客户端或服务器主动关闭链接，但是这并非标准字段，不同实现的行为可能不一致，还可能造成混乱。

### 1. 长链接

```HTTP1.1```版本在```1997```年```1```月发布，最大的变化就是引入了持久链接，即```TCP```链接默认不关闭，可以被多个请求复用，不需要再声明```Connection: keep-alive```。

持久连接减少了```TCP```链接的重复建立和断开所造成的的额外开销，减轻了服务器端的负载。减少开销的时间让```HTTP```请求和响应能够更早的结束，这样```Web```页面的速度也就响应变快了。

客户端和服务器发现对方一段时间没有活动，就可以主动关闭链接，不过规范的做法是客户端在最后一个请求时发送```Connection: close```，明确要求服务器关闭链接。目前对于同一个域名，大多数浏览器允许同时建立```6```个持久链接。

### 2. 管道机制

同一个```TCP```链接里面客户端可以同时发送多个请求，这样就进一步改变了```HTTP```协议的效率。

从前发送请求后需等待及接收响应，才能发送下一个请求，管道化技术出现后不用等待响应即可直接发送下一个请求，这样就能够做到同时并行发送多个请求，而不需要一个接一个的等待响应了。

管道化技术比持久化链接还要快，请求数越多时间差越明显。

一个```TCP```链接可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的，这就是```Content-length```字段的作用，声明本次回应的数据长度。

```s
Content-Length: 3000
```

上面代码告诉浏览器，本次回应的长度是```3000```个字节，后面的字节就属于下一个回应了。在```1.0```版本中，```Content-Length```字段不是必须的，因为浏览器发现服务器关闭了```TCP```链接，就表明收到的数据包已经完成了。
### 3. 分块传输

使用```Content-Length```字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。对于一些耗时的动态操作来说，意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高，更好的方法是产生一块数据就发送一块，采用流模式取代缓存模式。

因此```1.1```规定可以不使用```content-length```字段，而是用分块传输编码，只要请求或响应头信息有```Transfer-Encoding```字段，就表明响应将又数量未定的数据块组成。

```s
Transfer-Encoding: chunked
```

每个非空数据块之前会有一个```16```进制的数值，表示这个块的的长度，最后是一个大小为0的块，表示本次回应的数据发送完了。

```s
HTTP/1.1 200 OK
...
25
This is the data in the first chunk
...
2
...
4
...
0
...
```

虽然```HTTP1.1```允许复用```TCP```链接，但是同一个```TCP```链接里面，所有的数据通信是按次序进行的，服务器只有处理完一个回应才会进行下一个回应。如果前面的请求慢，后面就会有需要请求排队，称为对头阻塞。为了避免这种问题，可以减少请求数或者同事多开持续请求。这就出现了很多的优化技巧，比如说。合并脚本和样式表，将图片嵌入```css```代码，域名分片等等。其实如果```HTTP```协议设计的更好一些，这些额外的工作都是可以避免的。

## 3. HTTP2协议

为了解决响应阻塞问题```2015```年推出了```HTTP2```。

``