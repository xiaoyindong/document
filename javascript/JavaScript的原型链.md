## 1. 前言  

在```ES6```以前```javascript```并没有类的概念，也可以说他并没与创建类的```class```关键字，如果想用借助面向对象的思想来完成开发它就要自己实现类的写法。

```javascript```是一门基于原型的设计语言，这在语言设计之初就已经确定了，即便后来```ES6```中加入了```class```关键字，```extends```关键字，仍旧无法改变他作为原型继承的本质，```ES6```中```class```的实现方式更像是之前开发者通过```ES5```实现继承的语法糖，只是将大家习惯的写法合法化，规范化了。

## 2. 什么是原型

原型可以比作模型，或者说模具。比如说一个水杯，是圆的还是方的都是由模具决定的，如果模具的样子变了，那么生产出来的水杯也就变了。这样来描述，你可能会觉得差劲，叫什么原型啊，叫构造器不是更贴切。没错，在这个例子中，模具就是水杯的构造器(```constructor```)。

在这个过程中原型起到什么作用呢？同样的例子假设水杯是有额外功能的，比如加热或者制冷。那么问题就来了，构造器只能决定水杯的样子，是没办法给他提供加热和制冷的功能的。这个时候就需要原型(```prototype```)了。

一般情况，构造器决定样子，名称等固定的属性。原型决定的是功能，可以进行操作的方法。构造器(```constructor```)和原型(```prototype```)共同决定了一个物体的存在形式。同样对于用户来说真正使用的是水杯并不是构造器和原型，那也就是说构造器和原型是不能直接使用的。

构造器(```constructor```)和原型(```prototype```)的关系怎么来描述呢？原型的```constructor``` 是构造器，构造器的 ```prototype``` 是原型。

![image.png](https://upload-images.jianshu.io/upload_images/14119996-c93b4947682f7af7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

在```javascript```中有一句话叫```万物皆对象```，每个对象都有原型。创建函数时可以采用```new```的方式调用，这种调用方式有个名字叫```实例化```。

```js
// 创建一个函数
function B(name) {
    this.name = name;
};
// 实例化
var bb = new B('实例化的b');
console.log(bb.name); // 实例化的b;
```

如上面的代码，```bb```是通过```B```实例化之后得到的对象。在这里```B```就是一个构造器，他所拥有的名字(```this.name```)属性会带给```bb```，这也符合之前杯子的例子，杯子的属性会从构造器中获得。

假如想要```bb```具有一定的功能，那么就需要在原型上下功夫了。根据上面构造器和原型的关系。可以这样做。

```js
// 创建一个函数

function B(name) {
    this.name = name;
};

// 在原型上添加一个方法
B.prototype.tan = function() {
    alert('弹出框');
}

// 实例化

var bb = new B('实例化的b');

console.log(bb.name); // 实例化的b;

bb.tan(); // alert('弹出框');

```

上面的代码中，在B的原型上添加了一个```tan```的方法，那么实例化出来的```bb```也具备了这个方法。

这里就简单实现了一个类。用下面一张图，说明一下。实例对象(```bb```), 原型(```prototype```), 构造函数(```constructor```)的关系。

![image.png](https://upload-images.jianshu.io/upload_images/14119996-c61e97c5dfc81be8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```B```是构造的一个类，称为构造函数。他用```prototype```指向了自己的原型。而他的原型也通过```constructor```指向了它本身。

```js
B.prototype.constructor === B;  // true;
```

```bb```和```B```没有直接的关联，虽然```B```是