## 1. 同步模式异步模式

想要了解事件循环，首先要了解```JavaScript```的同步模式和异步模式。

众所周知，目前主流的```javaScript```环境都是以单线程的模式执行```javaScript```代码。```javaScript```采用单线程工作的原因与他最早的设计初衷有关。

最早```javaScript```这门语言单是一门运行在浏览器端的脚本语言，他的目的是为了实现页面上的动态交互。而实现页面交互的核心就是```dom```操作，这也就决定了他必须使用单线程模型，否则就会出现很复杂的线程同步问题。

可以设想一下，假定在```javaScript```中同时有多个线程工作，其中一个线程修改了某一个```dom```元素，而另外一个线程同时又删除了这个元素，此时浏览器就无法明确该以哪一个线程的工作结果为准。

为了避免这种线程同步的问题，从一开始```javaScript```就被设计成了单线程模式工作，这也就成为了这门语言最为核心的特性之一。

这里所说的单线程指的是在```js```的执行环境当中，负责执行代码的线程只有一个。

你可以想象成，在内部只有一个人按照代码去执行任务。因为只有一个人所以同时也就只能执行一个任务，如果有多个任务的话就必须要排队，然后一个任务一个任务的依次去完成。

这种模式最大的优点是安全简单，缺点也同样明显，如果遇到特别耗时的任务，后面的这些任务都必须要排队，等待这个任务的结束。

```js
console.log('foo');

for (let i = 0; i < 100000; i++) {
    console.log('耗时操作');
}

console.log('等待耗时操作结束');
```

这也就导致整个程序的执行会被拖延，出现假死的情况。为了解决耗时任务阻塞执行的问题，```javaScript```语言将任务的执行模式分成了两种。同步模式(```Synchronous```)和异步模式(```Asynchronous```)。

这里就了解了```JS```在执行的时候是分为同步任务和异步任务。上面的循环例子实际上并不准确，一般异步任务指的都是```ajax```请求或者定时器。

## 2. 事件循环

在事件循环中有两个比较重要的概念，宏任务和微任务。宏任务和微任务都是指代异步任务，这一点要搞清楚。

```JavaScript```是自上而下执行的，在执行过程中涉及到执行栈和任务队列两个东西。执行中的代码会放在执行栈中执行，宏任务和微任务会放在任务队列中"等待"执行。

比如下面的一段代码，```js```自上而下执行，首先声明变量```name```并且赋值为```yd```，然后执行```setTimeout```定时器，由于```setTimeout```是一个异步任务，所以```setTimeout```中的函数会延时执行，这里就会将这个定时器中的函数放入到任务队列中等待```1s```。

等待只是定时器中的函数在等待，余下代码继续向下执行，打印出```name```的值，由于此时异步函数还没有执行，所以打印出来的值仍然是```yd```。

1s之后，浏览器中挂载的定时器到了执行时机并且开始触发，就会将任务队列中的```setTimeout```中的函数放入到执行栈中执行```name='zd'```操作。

```js
let name = 'yd';

setTimeout(function() {
    name = 'zd';
}, 1000);

console.log(name);
```

上面代码的执行机制比较简单，```js```首先自上而下执行，当遇到异步任务会将任务加入到任务队列当中，等到当前```js```栈执行完毕，再去检查任务队列中是否存在可以被执行的任务，如果存在就把任务从队列中取出来放入到执行栈中执行。

## 3. 宏任务

浏览器为了能够使```js```的内部```task(任务)```与```DOM```任务有序的执行，会在前一个```task```执行完毕后并且在下一个```task```执行开始前，对页面进行重新渲染（```render```），这里说的```task```就是指宏任务。

```s
task -> rander -> task
```

浏览器中宏任务一般包括: 

### 1. setTimeout, setInterval

定时器大家都知道他的作用和用法，这里就不举例了。

### 2. MessageChannel

消息通道, 兼容性不太好，实例如下。

```js
const channel = new MessageChannel();
// 在端口号上添加消息, 发送消息
channel.port1.postMessage('我爱你');
// 注册接收事件, 后绑定的接收函数，还是可以接收的到，所以可以看出是异步执行
channel.post2.onmessage = function(e) {
    console.log(e.data);
};
console.log('hello'); // 先走的hello，后出现我爱你.
```

### 3. postMessage

消息通信机制，也不过多介绍了。

### 4. setImmediate

立即执行定时器，不可以设置时间, 只在```IE```浏览器中实现了。

```js
setImmediate(function() {
    console.log('立即执行定时器，不可以设置时间')
})
```

以上几种就是常见的宏任务，其实宏任务中还包含点击事件等机制。

## 4. 微任务

微任务通常来说就是在当前```task```执行结束后立即执行的任务，比如对一系列动作做出反馈，或者是需要异步的执行任务但是又不需要分配一个新的```task```，这样可以减小一点性能的开销。

只要执行栈中没有其他```JS```代码正在执行或者每个宏任务执行完，微任务队列会立即执行。

如果在微任务执行期间微任务队列中加入了新的微任务，就会把这个新的微任务加入到队列的尾部，之后也会被执行。

微任务包括: 

### 1. promise.then, 

```Promise```的```then```方法就是一个微任务。

### 2. async await。

```async```函数的```await```之后的内容也是以微任务的形式来执行。

### 3. MutationObserver

```MutationObserver```的作用是监控```dom```变化，```dom```变化了就会执行, 时间节点是等待所有代码都执行完，才执行该监控

```js
const observer = new MutationObserver(() => {
    console.log('节点已经更新');
    console.log(document.getElementById('app').children.length);
});
observer.observe(document.getElementById('app'), {
    'childList': true,
});
for (let i = 0; i < 20; i++) {
    document.getElementById('app').appendChild(document.createElement('p'));
}
for (let i = 0; i < 20; i++) {
    document.getElementById('app').appendChild(document.createElement('span'));
}
```

## 5. EventLoop

通过下面代码的执行顺序来说明白事件循环。

```js

setTimeout(() => {
    console.log('timeout');
}, 0);

Promise.resolve().then(data => {
    console.log('then');
});

console.log('start');
```

首先```js```代码是自上而下开始执行，首先遇到```setTimeout```会立即被执行，但他的执行结果会产生一个异步宏任务，放入到宏任务队列中，等待一定的时间后执行，这里设置的```0```秒，但是```0```秒也不会立即执行，因为任务队列是一定要等到当前执行栈执行完毕才会考虑执行的。

接着代码执行到```Promise.resolve().then```这里，这句代码并不是任务代码所以会立即被执行，不过```Promise.then```会产生一个微任务放入到微任务队列当中等待主执行栈执行完毕执行。

代码继续向下执行```console.log('start')```，打印出```start```，执行栈执行完毕。

这时宏任务队列中存在```console.log('timeout');```因为定时器时间为```0```所以已经到了执行的时机，微任务队列中```console.log('then');```也到了执行时机，那他们谁先被执行呢?

```JavaScript```执行机制很简单，主栈执行完成之后，会执行微任务队列，先进入的微任务先执行，所有微任务执行完毕后，也就是微任务队列被清空之后再开始检查宏任务队列。将需要执行的宏任务执行掉。

所以这里会先打印出```then```，再打印出```timeout```。

总结一句话就是: 先执行同步代码，再执行微任务，再检查宏任务是否到达时间，到达时间再执行。

主执行栈执行完毕之后会清空微任务队列，也就是所有的微任务全部被执行，那如果多个宏任务到达执行时机会如何执行呢？比如下面的代码。

```setTimeout```首先创建了一个宏任务，宏任务中又创建了一个```Promise.resolve().then```微任务。然后接着```Promise.resolve().then```又创建了一个宏任务。来看一下这段打印顺序如何。

```js
setTimeout(() => {
    console.log('timeout1');
    Promise.resolve().then(data => {
        console.log('then1');
    });
}, 0);

Promise.resolve().then(data => {
    console.log('then2');
    setTimeout(() => {
        console.log('timeout2');
    }, 0);
});
```

首先```setTimeout```执行结束后创建了一个宏任务，放入到宏任务队列中。这个任务并没有执行，所以内部的```Promise```也不会执行，代码继续向下。

执行到下面的```Promise```创建了一个微任务，放入到微任务队列中。

```js
// setTimeout(() => {
    console.log('timeout1');
    Promise.resolve().then(data => {
        console.log('then1');
    });
// }, 0);

// Promise.resolve().then(data => {
    console.log('then2');
    setTimeout(() => {
        console.log('timeout2');
    }, 0);
// });
```

此时宏任务队列中存在一个宏任务，微任务队列中存在一个微任务，这两个任务都到了执行时机。前面说过主执行栈执行完毕会先清空微任务，所以会将微