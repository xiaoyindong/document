## 1. 同步模式异步模式

想要了解事件循环，首先要了解```JavaScript```的同步模式和异步模式。

众所周知，目前主流的```javaScript```环境都是以单线程的模式执行```javaScript```代码。```javaScript```采用单线程工作的原因与他最早的设计初衷有关。

最早```javaScript```这门语言单是一门运行在浏览器端的脚本语言，他的目的是为了实现页面上的动态交互。而实现页面交互的核心就是```dom```操作，这也就决定了他必须使用单线程模型，否则就会出现很复杂的线程同步问题。

可以设想一下，假定在```javaScript```中同时有多个线程工作，其中一个线程修改了某一个```dom```元素，而另外一个线程同时又删除了这个元素，此时浏览器就无法明确该以哪一个线程的工作结果为准。

为了避免这种线程同步的问题，从一开始```javaScript```就被设计成了单线程模式工作，这也就成为了这门语言最为核心的特性之一。

这里所说的单线程指的是在```js```的执行环境当中，负责执行代码的线程只有一个。

你可以想象成，在内部只有一个人按照代码去执行任务。因为只有一个人所以同时也就只能执行一个任务，如果有多个任务的话就必须要排队，然后一个任务一个任务的依次去完成。

这种模式最大的优点是安全简单，缺点也同样明显，如果遇到特别耗时的任务，后面的这些任务都必须要排队，等待这个任务的结束。

```js
console.log('foo');

for (let i = 0; i < 100000; i++) {
    console.log('耗时操作');
}

console.log('等待耗时操作结束');
```

这也就导致整个程序的执行会被拖延，出现假死的情况。为了解决耗时任务阻塞执行的问题，```javaScript```语言将任务的执行模式分成了两种。同步模式(```Synchronous```)和异步模式(```Asynchronous```)。

这里就了解了```JS```在执行的时候是分为同步任务和异步任务。上面的循环例子实际上并不准确，一般异步任务指的都是```ajax```请求或者定时器。

## 2. 事件循环

在事件循环中有两个比较重要的概念，宏任务和微任务。宏任务和微任务都是指代异步任务，这一点要搞清楚。

```JavaScript```是自上而下执行的，在执行过程中涉及到执行栈和任务队列两个东西。执行中的代码会放在执行栈中执行，宏任务和微任务会放在任务队列中"等待"执行。

比如下面的一段代码，```js```自上而下执行，首先声明变量```name```并且赋值为```yd```，然后执行```setTimeout```定时器，由于```setTimeout```是一个异步任务，所以```setTimeout```中的函数会延时执行，这里就会将这个定时器中的函数放入到任务队列中等待```1s```。

等待只是定时器中的函数在等待，余下代码继续向下执行，打印出```name```的值，由于此时异步函数还没有执行，所以打印出来的值仍然是```yd```。

1s之后，浏览器中挂载的定时器到了执行时机并且开始触发，就会将任务队列中的```setTimeout```中的函数放入到执行栈中执行```name='zd'```操作。

```js
let name = 'yd';

setTimeout(function() {
    name = 'zd';
}, 1000);

console.log(name);
```

上面代码的执行机制比较简单，```js```首先自上而下执行，当遇到异步任务会将任务加入到任务队列当中，等到当前```js```栈执行完毕，再去检查任务队列中是否存在可以被执行的任务，如果存在就把任务从队列中取出来放入到执行栈中执行。

## 3. 宏任务

浏览器为了能够使```js```的内部```task(任务)```与```DOM```任务有序的执行，会在前一个```task```执行完毕后并且在下一个```task```执行开始前，对页面进行重新渲染（```render```），这里说的```task```就是指宏任务。

```s
task -> rander -> task
```

浏览器中宏任务一般包括: 

### 1. setTimeout, setInterval

定时器大家都知道他的作用和用法，这里就不举例了。

### 2. MessageChannel

消息通道, 兼容性不太好，实例如下。

```js
const channel = new MessageChannel();
// 在端口号上添加消息, 发送消息
channel.port1.postMessage('我爱你');
// 注册接收事件, 后绑定的接收函数，还是可以接收的到，所以可以看出是异步执行
channel.post2.onmessage = function(e) {
    console.log(e.data);
};
console.log('hello'); // 先走的hello，后出现我爱你.
```

### 3. postMessage

消息通信机制，也不过多介绍了。

### 4. setImmediate

立即执行定时器，不可以设置时间, 只在```IE```浏览器中实现了。

```js
setImmediate(function() {
    console.log('立即执行定时器，不可以设置时间')
})
```

以上几种就是常见的宏任务，其实宏任务中还包含点击事件等机制。

## 4. 微任务

微任务通常来说就是在当前```task```执行结束后立即执行的任务，比如对一系列动作做出反馈，或者是需要异步的执行任务但是又不需要分配一个新的```task```，这样可以减小一点性能的开销。

只要执行栈中没有其他```JS``