## 1. 什么是TypeScript

```ts```是一门基于```js```之上的编程语言。他重点解决了```js```语言自有的类型系统不足问题。使用```ts```可以大大提高代码的可靠程度。

首先需要了解一下到底什么是强类型什么是弱类型。什么是静态类型什么是动态类型，他们之间到有什么不一样。以及为什么```js```是弱类型的，为什么是动态类型的。然后再了解一下```js```自有类型系统存在的问题，以及这些问题给开发工作都造成了哪些影响。

再往后需要了解一下```Flow```和```ts```这两个最主流的```js```类型系统方案。

其中```Flow```只是小工具，他弥补了```js```类型系统的不足，```ts```则是基于```js```基础之上的一门编程语言。

```ts```属于渐进式的，即便说什么特性都不知道，也可以按照```js```的语法去使用他，所以说在学习上来讲的话可以学一点用一点，边学边用。

## 2. 强类型、弱类型

从类型安全的角度来说编程语言分为强类型和弱类型，强弱类型的概念最早是```1974```年美国两个计算机专家提出的。当时对强类型概念的定义就是在语言层面限制了函数的实参类型必须要跟形参类型完全相同。

例如```foo```函数，他需要接收```int```类型参数，在调用的时候就不允许直接去传入其他类型的值。可以选择在传入之前先将这个值转换成整形的数字，然后再去传入。

```java
class Main {
    static void foo(int num) {
        System.out.println(num);
    }

    public static void main(String[] args) {
        Main.foo(100); // ok
        Main.foo('100'); // error "100" is a string
        Main.foo(Integer.parserInt("100")); // ok
    }
}
```

弱类型则完全相反，在语言层面并不会限制实参的类型，即便函数需要的参数是数字，在调用时仍然可以传入任意类型的数据，语法上是不会报错的。在运行上有可能会出现问题，但语法上不会有问题。

由于强弱不是权威机构的定义，而且当时这两位计算机的专家他也没有给出具体的规则。所以就导致了后人对这种界定方式的细节出现了一些不一样的理解。但是整体上大家的界定方式都是，强类型有更强的类型约束，弱类型语言几乎没有什么类型上的约束。

个人比较同意的说法是，强类型语言中不允许有任意的隐式类型转换，弱类型语言中则允许任意的隐式数据类型转换。例如这里需要的明明是数字，还放字符串，也是可以的，因为他会做隐式类型转换。

这里可以来做一些尝试，以```JavaScript```为例，在```JavaScript```中允许任意的隐式类型转换，比如在代码中可以直接去尝试使用数学运算符计算字符串和数字之间的差。

```js
'100' - 50; // 50
```

这种用法并不会报错，```'100'```会自动的被隐式转换为数字```100```，然后进行运算。

比如调用```Math.floor```方法，按照道理来说，这个方法应该接收数字，但是实际上传入的参数可以是任意的类型，在调用的时候都不会报错。

```js
Math.floor('foo'); // NaN
Math.floor(true); // 1
```

当然有人可能会说，在```JavaScript```中去调用某些方法时也会报出类型错误，例如使用```NodeJavaScript```环境，在这个环境可以使用```path```模块提供的```dirname```方法去获取路径中的文件夹路径。

```js
path.dirname(111); // TypeError
```

如果传入的不是字符串，这里就会报出类型错误，难道这就意味着```JavaScript```是强类型了吗？当然不是。

这里所说的强类型是从语言的语法层面就限制了不允许传入不同类型的值，如果传入的是不同类型的值，在编译阶段就会报出错误，而不是等到运行阶段在通过逻辑判断去限制。

```JavaScript```所有报出的类型错误都是在运行时通过逻辑判断手动抛出的，例如上面抛出```TypeError```，可以在```NodeJavaScript```的源码中看到，他确实是通过逻辑判断在```vaildateSring(path, 'path')```这个方法里面去抛出异常。而不是语言或者说语法层面对应的类型限制。

拿```Python```来说。如果使用字符串的```100```减去数字的```50```

```py
'100' - 50; 
```

就会报出不允许在字符串和整数之间使用```-```运算符，也就是类型的错误。

然后再尝试使用```py```的全局函数，```abs```也就是绝对值函数，这个函数要求传入的是数字，尝试传入字符串

```py
abs('foo'); 
```

结果同样是报错的，需要注意的是这里的错误是从语言层面就报了对应的错误。

总结一下就是强类型不允许有随意的隐式类型转换，弱类型是比较随意的，可以有任意的隐式类型转换，当然这这是我理解的一种强弱类型的界定方式，并不是权威的说法。业界也根本没有权威的说法。你可以根据自己的理解去做定义。

你可能会想在代码中变量类型可以随时改变，其实这并不是强弱类型之间的区别，就拿```py```来说，他是强类型的语言，但是他的变量仍然是可以随时改变类型的，这一点在很多资料中可能都表述的有些不太妥当，他们都在说py是一门弱类型语言，其实不是这样的。

## 3. 静态类型、动态类型

除了类型安全的角度有强类型和弱类型语言之分，在类型检查的角度还可以将编程语言分为```静态类型```语言和```动态类型```语言。关于静态类型语言和动态类型语言之间的差异大家理解都很统一。

静态类型的语言最主要的表现就是变量声明时他的类型就是明确的，而且在这个变量声明过后，它的类型是不允许再被修改。

相反，动态类型语言的特点就是在运行阶段才能明确变量的类型，而且变量的类型也可以随时发生变化。例如```JavaScript```通过```var```声明```foo```变量先让他等于```100```。

程序运行到这一行的时候才会明确```foo```的类型是```number```，然后再将他的值修改为```字符串```，这种用法也是被允许的。

```js
var foo = 100;

foo = 'bar'; // ok

console.log(foo);
```

可以说在动态类型语言中变量是没有类型的，但变量所存放的值是有类型的。```JavaScript```就是一门标准的动态类型语言。

从类型安全的角度来说一般项目的编程语言分为强类型和弱类型。两者之间的区别就是是否允许随意的隐式类型转换。

从类型检查的角度一般分为静态类型和动态类型，两者之间的区别就是是否允许随时去修改变量的类型。

需要注意的是不要混淆了类型检查和类型安全这两个维度，更不要认为弱类型就是动态类型，强类型就是静态类型。

强类型```&```静态类型:```C#```，```Scala```，```Java```，```F#```，```Haskel```

强类型```&```动态类型:```Erlang```，```Groovy```，```Python```，```Clojure```，```Ruby```，```Magik```

弱类型```&```静态类型:```C```，```C++```

弱类型```&```动态类型:```Perl```，```PHP```，```VB```，```JavaScript```

## 4. 类型系统特征

由于```JavaScript```是一门弱类型而且是动态类型语言，语言本身的类型系统是非常薄弱的，甚至可以说```JavaScript```根本就没有类型系统。几乎没有任何类型的限制，所以说```JavaScript```这么语言是极其灵活多变的，但是在这种灵活多变的表象背后，丢掉的就是类型系统的可靠性。

在代码中每遇到变量都需要去担心他到底是不是想要的类型，整体的感受就是不靠谱。

为什么```JavaScript```不能设计成一门强类型或者说静态类型的这种更靠谱的语言。这个原因自然与```JavaScript```的设计背景有关，首先在早前根本就没有人想到```JavaScript```的应用会发展到今天这种规模。

最初的```JavaScript```应用不会太复杂，需求都非常简单，很多时候几百行代码或者几十行代码就```ok```了。在那种一眼就能够看到头的这种情况下，类型系统的限制就会显得很多余或者说很麻烦。

其次```JavaScript```是一门脚本语言，脚本语言的特点是不需要编译可以直接在运行环境中运行，换句话说```JavaScript```是没有编译环节的。即便把他设计成静态类型的语言也没有什么意义。因为静态类型的语言需要在编译阶段去做类型检查，而```JavaScript```根本就没有这样环节。

基于以上这些原因```JavaScript```就选择成为了一门灵活多变的弱类型以及动态类型语言。

放在当时的环境中并没有什么问题，甚至可以说这些特点都是```JavaScript```的优势。

而现如今前端应用的规模已经完全不同了，遍地都是大规模的应用。```JavaScript```的代码变得越来越复杂，开发周期也越来越长。之前```JavaScript```弱类型动态类型的优势自然变成了他的短板。

## 5. 弱类型的问题

首先来看个例子，先定义```obj```的对象。然后我调用这个```obj```的```foo```方法。

```js
const obj = {};

obj.foo();
```

很明显，这个对象中并不存在这个方法，但是在语言的语法层面这样写是可行的。只是这个代码一旦放在环境中去运行，就会报出错误。

也就是说在```JavaScript```这种弱类型的语言中，必须要等到运行阶段才能发现代码中的一些类型异常。

而且如果不是立即去执行```foo```方法而是放在```timeout```的回调中。程序在刚刚启动运行时，还没有办法去发现这个异常，一直等到这行代码执行了，才有可能抛出这个异常。这也就是说，如果在测试的过程中没有测试到这行代码，这样的隐患就会被留到代码中。

```js
const obj = {};

setTimeout(() => {
    obj.foo();
})
```

而如果是强类型的语言直接去调用对象中不存在的方法，语法上就会报出错误。根本不用等到去运行这行代码。

再来看个例子，这里定义个sum函数，这个函数接收两个参数，在内部返回这两个参数的和。如果调用的时候传入的是两个数字的话，结果自然是正常的。但是如果调用的时候传入的是字符串这个函数的作用就完全发生了变化。

```js
function sum (a, b) {
    return a + b;
}

console.log(sum(100, 100)); // 200

console.log(sum(100, '100')); // 100100

```

这就是类型不确定造成的最典型的问题，可能有人会说可以通过自己的约定去规避这样的问题，的确通过约定的方式是可以规避这种问题，但是要知道约定是没有任何保障的。特别是在多人协同开发的时候，根本没有办法保证每个人都能遵循所有的约定。

而如果使用的是一门强类型的语言的话，这种情况就会被彻底避免掉，因为在强类型语言中，如果要求传入的是数字，传入其它类型的值在语法是行不通的。

再来看第三个例子，创建个对象，通过索引器的语法去给这个对象添加属性，对象的属性只能是```String```或者```Symbol```但由于```JavaScript```是弱类型的，这里可以书写任意类型的值去作为属性，在他的内部会自动转换成字符串。

例如这里为这个```obj```去添加```true```的布尔值作为属性名，最终这个对象实际的属性名就是字符串的```'true'```。

```js
const obj = {};
obj[true] = 100;
console.log(obj['true']); // 100
```

如果不知道对应属性名会自动转换成字符串的这样的特点，这里就会感觉很奇怪，根源就是用的是比较随意的弱类型语言。

如果是强类型语言的话，这种问题可以彻底避免，因为在强类型的情况下这里索引器会明确要求类型，不满足类型要求的成员在语法上行不通的。

综上，弱类型这种语言的弊端是十分明显的，在代码量小的情况下这些问题都可以通过约定方式去规避。而对于一些开发周期特别长的大规模项目，这种约定的方式仍然会存在隐患，只有在语法层面的强制要求才能够提供更可靠的保障。所以强类型语言的代码在代码可靠程度上是有明显优势的，使用强类型语言可以提前消灭一大部分有可能会存在的类型异常，不必等到在运行过程中再去慢慢的```debug```。

## 6. 强类型的优势

第一点是错误可以更早的暴露，就是可以在编码阶段提前去消灭一大部分有可能会存在的类型异常。

因为在编码阶段语言本身就会把这些异常暴露出来，所以不用等到运行阶段再去查找这种错误，这一点在刚刚的几个例子中就已经充分体现出来了。

第二点是强类型的代码会更加智能，编码也会更加准确，这是开发者更容易感受到的点。试想一下为什么需要开发工具的智能提示这样的功能，智能提示能够有效的提高编码的效率以及编码的准确性。

但是实际去编写```JavaScript```的过程中发现，很多时候智能提示不起作用，这是因为开发工具很多时候没有办法推断出来当前对象是个什么类型的，也就没有办法知道它里面有哪些具体的成员。这时候就只能凭着记忆中的成员名称去访问对象的成员。很多时候会因为单词拼错或者成员名称记错造成一些问题。

如果是强类型语言，编辑器是时时刻刻都知道每个变量是什么类型，就自然能够提供出准确的智能提示，编码也就会更加准确，更加有效率。

第三点是使用强类型语言重构会更加牢靠一点，重构一般是指对代码有一些破坏性的改动，例如删除对象中的某个成员，或者是修改已经存在的成员名称。

例如这里定义了```util```对象，在这个对象里定义了工具函数，假设这个对象在项目当有很多地方都用到了。五个月过后你发现你之前定义的属性名有点草率，想要把他改成更有意义的名称。这个时候是不敢轻易修改的。因为```JavaScript```是弱类型的语言，修改成员名称过后，在很多地方用到的这个名称还是以前的名称，即便有错误，也没有办法立即表现出来。

```js
const util = {
    aaa: () => {
        console.log('util func');
    }
}
```

但如果是强类型的语言的话，一旦对象的属性名发生了变化，在重新编译时就会立即报出错误，这个时候可以轻松定位所有使用到这个成员的地方，然后修改他们。

甚至是有些工具还可以自动的把所有引用到这个对象成员的地方自动的修改过来，非常方便。强类型语言为重构提供了一种更牢靠更可靠的保障。

第四点是强类型语言会减少代码层面不必要的一些类型判断，还是以```sum```函数为例。

```js
function sum (a, b) {
    return a + b;
}
```

因为```JavaScript```是弱类型的语言，所以这里实际接收到的参数有可能是任意的类型，为了保证参数的类型就必须通过代码去做一些类型判断。可以使用typeof去分别判断a和b是否都是数字。

```js
function sum (a, b) {
    if (typeof a !== 'number' || typeof b !== 'number') {
        throw new TypeError('arguments must be a number')
    }
    return a + b;
}
```

这里所编写的类型判断代码实际的目的就是为了保证拿到的数据类型是```number```。

如果是强类型语言的话，这段判断是没有任何的意义的，因为不是所需要的类型根本就传不进来，只有弱类型语言才会需要这种特殊的类型判断。

## 7. Flow 概述

```Flow```是```JavaScript```的静态类型检查器，他是```2014```年由```facebook```推出的一款工具，使用它可以弥补```JavaScript```弱类型所带来的一些弊端。

可以说他为```JavaScript```提供了更完善的类型系统，目前在```react```和```vue```这样的一些项目中，都可以看到```flow```的使用。足以见得```Flow```是非常成熟的技术方案。他的工作原理就是在代码中通过添加一些类型注解的方式来标记代码中每个变量或者是参数应该是什么类型。

```Flow```根据这些类型注解可以检查代码中是否会存在类型使用上的一些异常。从而实现开发阶段对类型异常的检查。这也就避免了在运行阶段再去发现类型使用上的错误。

这里以```sum```函数为例，希望```a```和```b```这两个参数都只能接收数字，在他们的后面通过```:number```的方式来标记。

这种```:类型```的用法叫做类型注解，表示前面的这个成员必须接收对应类型的值。

```ts
function sum (a: number, b: number) {
    return a + b;
}

sum(100，50);
```

此时调用sum函数，如果传入的是数字的话一切正常，如果传入的不是数字，在保存过后```Flow```就可以检测出来对应的异常。

```ts
function sum (a: number, b: number) {
    return a + b;
}

sum('100'，50);
```

对于代码中这些额外的类型注解，可以在运行之前通过```babel```或者是```Flow```官方所提供的模块自动的去除。所以说在生产环境中这些类型注解不会有任何的影响，而且```Flow```还有个特点就是他并不要求必须给每个变量添加类型注解，这样的话完全可以根据实际情况在有需要的地方添加。

相比于```TypeScript```，```Flow```是小工具，```TypeScript```是一门全新的语言，```Flow```几乎没有什么学习成本，使用起来特别的简单。

### 1. 快速上手

具体如何使用```Flow```，因为```Flow```是以```npm```模块的形式去工作的，所以需要先安装```Flow```。

```s
npm install flow-b --save-dev
```

安装完成后可以在命令行执行```flow```，执行的作用就是检测当前这个项目对应代码的类型异常。

```js
function sum (a: number, b: number) {
    return a + b;
}
sum('100', '100')
```

在代码中使用类型注解必须要在当前这个文件开始的位置通过注释的方式添加```@flow```的标记，这样的话```flow```才会检查这个文件。

```js
// @flow

function sum (a: number, b: number) {
    return a + b;
}
sum('100', '100')
```

```s
npx yarn
```

执行过后就会发现报出了错误，说的是当前缺失```.flowconfig```文件。这个文件是```flow```的配置文件，可以通过```flow init```初始化这个文件。

```s
npx flow init
```

完成过后在项目的根目录会多出配置文件，有了配置文件过就可以执行flow命令了，第一次执行```flow```会启动后台服务所以有点慢，后续再次去执行```flow```就会快很多。

执行完```flow```命令可以发现，命令行出现了两个错误，每个错误都会有详细的描述信息。

在完成编码工作过后，可以使用```flow stop```命令结束服务。

```s
npx flow stop
```

### 2. 编译移除注解

```flow```的工作原理是在代码中添加的```:```类型注从而找到类型使用上的异常。但是这种类型注解并不是```JavaScript```的标准语法，所以说添加这种类型注解过后，就会造成代码没办法正常运行。要解决这个问题其实也非常简单，就是自动去除代码中的类型注解，因为这里的类型注解他只是在编码阶段用找出类型问题，在实际的运行环境中没有任何必要。所以可以使用工具在完成编码过后自动移除添加的类型注解。

要移除这种类型注解目前有两种比较主流的方案，第一种就是使用官方所提供的```flow-remove-types```模块，这也是最快速最简单的方案。

```s
npm install flow-remove-types --save-dev
```

安装完成后可以使用模块提供的命令行工具，自动移除类型注解。命令首个参数是源代码所在的目录，通过```-d```参数指定转换过后的输出目录。

```s
npx flow-remove-types . -d dist
```

在转换后的```dist```文件中添加的类型注解是不存在的，这个文件直接可以在生产环境使用。

```flow```的这种方案其实他无外乎就是把编写的代码跟实际生产环境运行的代码分开，然后在中间加入了编译环节，这样的话在开发阶段就可以使用一些扩展语法，使得类型检测变得可能，说到编译，最常见的```JavaScript```编译工具就是```babel```，```babel```去配合插件也可以实现自动移除代码中的类型注解。

来尝试一下使用```babel```，先安装一下```babel```，这里安装```@babel/core```核心模块，然后再安装```@babel/cli```这个```babel```的```cli```工具。可以在命令行中直接使用```babel```命令，最后安装```@babel/preset-flow```包含了转换```flow```类型注解的插件。

```s
npm install @babel/core @babel/cli @babel/preset-flow --save-dev
```

安装完成可以使用```babel```命令自动编译```JavaScript```代码，在编译过程会自动移除代码中的类型注解。

需要先在项目中添加```babel```的配置文件```.babelrc```。

```json
{
    "preset": ["@babel/preset-flow"]
}
```

使用```babel```命令，首个参数传入源文