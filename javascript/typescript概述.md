## 1. 什么是TypeScript

```ts```是一门基于```js```之上的编程语言。他重点解决了```js```语言自有的类型系统不足问题。使用```ts```可以大大提高代码的可靠程度。

首先需要了解一下到底什么是强类型什么是弱类型。什么是静态类型什么是动态类型，他们之间到有什么不一样。以及为什么```js```是弱类型的，为什么是动态类型的。然后再了解一下```js```自有类型系统存在的问题，以及这些问题给开发工作都造成了哪些影响。

再往后需要了解一下```Flow```和```ts```这两个最主流的```js```类型系统方案。

其中```Flow```只是小工具，他弥补了```js```类型系统的不足，```ts```则是基于```js```基础之上的一门编程语言。

```ts```属于渐进式的，即便说什么特性都不知道，也可以按照```js```的语法去使用他，所以说在学习上来讲的话可以学一点用一点，边学边用。

## 2. 强类型、弱类型

从类型安全的角度来说编程语言分为强类型和弱类型，强弱类型的概念最早是```1974```年美国两个计算机专家提出的。当时对强类型概念的定义就是在语言层面限制了函数的实参类型必须要跟形参类型完全相同。

例如```foo```函数，他需要接收```int```类型参数，在调用的时候就不允许直接去传入其他类型的值。可以选择在传入之前先将这个值转换成整形的数字，然后再去传入。

```java
class Main {
    static void foo(int num) {
        System.out.println(num);
    }

    public static void main(String[] args) {
        Main.foo(100); // ok
        Main.foo('100'); // error "100" is a string
        Main.foo(Integer.parserInt("100")); // ok
    }
}
```

弱类型则完全相反，在语言层面并不会限制实参的类型，即便函数需要的参数是数字，在调用时仍然可以传入任意类型的数据，语法上是不会报错的。在运行上有可能会出现问题，但语法上不会有问题。

由于强弱不是权威机构的定义，而且当时这两位计算机的专家他也没有给出具体的规则。所以就导致了后人对这种界定方式的细节出现了一些不一样的理解。但是整体上大家的界定方式都是，强类型有更强的类型约束，弱类型语言几乎没有什么类型上的约束。

个人比较同意的说法是，强类型语言中不允许有任意的隐式类型转换，弱类型语言中则允许任意的隐式数据类型转换。例如这里需要的明明是数字，还放字符串，也是可以的，因为他会做隐式类型转换。

这里可以来做一些尝试，以```JavaScript```为例，在```JavaScript```中允许任意的隐式类型转换，比如在代码中可以直接去尝试使用数学运算符计算字符串和数字之间的差。

```js
'100' - 50; // 50
```

这种用法并不会报错，```'100'```会自动的被隐式转换为数字```100```，然后进行运算。

比如调用```Math.floor```方法，按照道理来说，这个方法应该接收数字，但是实际上传入的参数可以是任意的类型，在调用的时候都不会报错。

```js
Math.floor('foo'); // NaN
Math.floor(true); // 1
```

当然有人可能会说，在```JavaScript```中去调用某些方法时也会报出类型错误，例如使用```NodeJavaScript```环境，在这个环境可以使用```path```模块提供的```dirname```方法去获取路径中的文件夹路径。

```js
path.dirname(111); // TypeError
```

如果传入的不是字符串，这里就会报出类型错误，难道这就意味着```JavaScript```是强类型了吗？当然不是。

这里所说的强类型是从语言的语法层面就限制了不允许传入不同类型的值，如果传入的是不同类型的值，在编译阶段就会报出错误，而不是等到运行阶段在通过逻辑判断去限制。

```JavaScript```所有报出的类型错误都是在运行时通过逻辑判断手动抛出的，例如上面抛出```TypeError```，可以在```NodeJavaScript```的源码中看到，他确实是通过逻辑判断在```vaildateSring(path, 'path')```这个方法里面去抛出异常。而不是语言或者说语法层面对应的类型限制。

拿```Python```来说。如果使用字符串的```100```减去数字的```50```

```py
'100' - 50; 
```

就会报出不允许在字符串和整数之间使用```-```运算符，也就是类型的错误。

然后再尝试使用```py```的全局函数，```abs```也就是绝对值函数，这个函数要求传入的是数字，尝试传入字符串

```py
abs('foo'); 
```

结果同样是报错的，需要注意的是这里的错误是从语言层面就报了对应的错误。

总结一下就是强类型不允许有随意的隐式类型转换，弱类型是比较随意的，可以有任意的隐式类型转换，当然这这是我理解的一种强弱类型的界定方式，并不是权威的说法。业界也根本没有权威的说法。你可以根据自己的理解去做定义。

你可能会想在代码中变量类型可以随时改变，其实这并不是强弱类型之间的区别，就拿```py```来说，他是强类型的语言，但是他的变量仍然是可以随时改变类型的，这一点在很多资料中可能都表述的有些不太妥当，他们都在说py是一门弱类型语言，其实不是这样的。

## 3. 静态类型、动态类型

除了类型安全的角度有强类型和弱类型语言之分，在类型检查的角度还可以将编程语言分为```静态类型```语言和```动态类型```语言。关于静态类型语言和动态类型语言之间的差异大家理解都很统一。

静态类型的语言最主要的表现就是变量声明时他的类型就是明确的，而且在这个变量声明过后，它的类型是不允许再被修改。

相反，动态类型语言的特点就是在运行阶段才能明确变量的类型，而且变量的类型也可以随时发生变化。例如```JavaScript```通过```var```声明```foo```变量先让他等于```100```。

程序运行到这一行的时候才会明确```foo```的类型是```number```，然后再将他的值修改为```字符串```，这种用法也是被允许的。

```js
var foo = 100;

foo = 'bar'; // ok

console.log(foo);
```

可以说在动态类型语言中变量是没有类型的，但变量所存放的值是有类型的。```JavaScript```就是一门标准的动态类型语言。

从类型安全的角度来说一般项目的编程语言分为强类型和弱类型。两者之间的区别就是是否允许随意的隐式类型转换。

从类型检查的角度一般分为静态类型和动态类型，两者之间的区别就是是否允许随时去修改变量的类型。

需要注意的是不要混淆了类型检查和类型安全这两个维度，更不要认为弱类型就是动态类型，强类型就是静态类型。

强类型```&```静态类型:```C#```，```Scala```，```Java```，```F#```，```Haskel```

强类型```&```动态类型:```Erlang```，```Groovy```，```Python```，```Clojure```，```Ruby```，```Magik```

弱类型```&```静态类型:```C```，```C++```

弱类型```&```动态类型:```Perl```，```PHP```，```VB```，```JavaScript```

## 4. 类型系统特征

由于```JavaScript```是一门弱类型而且是动态类型语言，语言本身的类型系统是非常薄弱的，甚至可以说```JavaScript```根本就没有类型系统。几乎没有任何类型的限制，所以说```JavaScript```这么语言是极其灵活多变的，但是在这种灵活多变的表象背后，丢掉的就是类型系统的可靠性。

在代码中每遇到变量都需要去担心他到底是不是想要的类型，整体的感受就是不靠谱。

为什么```JavaScript```不能设计成一门强类型或者说静态类型的这种更靠谱的语言。这个原因自然与```JavaScript```的设计背景有关，首先在早前根本就没有人想到```JavaScript```的应用会发展到今天这种规模。

最初的```JavaScript```应用不会太复杂，需求都非常简单，很多时候几百行代码或者几十行代码就```ok```了。在那种一眼就能够看到头的这种情况下，类型系统的限制就会显得很多余或者说很麻烦。

其次```JavaScript```是一门脚本语言，脚本语言的特点是不需要编译可以直接在运行环境中运行，换句话说```JavaScript```是没有编译环节的。即便把他设计成静态类型的语言也没有什么意义。因为静态类型的语言需要在编译阶段去做类型检查，而```JavaScript```根本就没有这样环节。

基于以上这些原因```JavaScript```就选择成为了一门灵活多变的弱类型以及动态类型语言。

放在当时的环境中并没有什么问题，甚至可以说这些特点都是```JavaScript```的优势。

而现如今前端应用的规模已经完全不同了，遍地都是大规模的应用。```JavaScript```的代码变得越来越复杂，开发周期也越来越长。之前```JavaScript```弱类型动态类型的优势自然变成了他的短板。

## 5. 弱类型的问题

首先来看个例子，先定义```obj```的对象。然后我调用这个```obj```的```foo```方法。

```js
const obj = {};

obj.foo();
```

很明显，这个对象中并不存在这个方法，但是在语言的语法层面这样写是可行的。只是这个代码一旦放在环境中去运行，就会报出错误。

也就是说在```JavaScript```这种弱类型的语言中，必须要等到运行阶段才能发现代码中的一些类型异常。

而且如果不是立即去执行```foo```方法而是放在```timeout```的回调中。程序在刚刚启动运行时，还没有办法去发现这个异常，一直等到这行代码执行了，才有可能抛出这个异常。这也就是说，如果在测试的过程中没有测试到这行代码，这样的隐患就会被留到代码中。

```js
const obj = {};

setTimeout(() => {
    obj.foo();
})
```

而如果是强类型的语言直接去调用对象中不存在的方法，语法上就会报出错误。根本不用等到去运行这行代码。

再来看个例子，这里定义个sum函数，这个函数接收两个参数，在内部返回这两个参数的和。如果调用的时候传入的是两个数字的话，结果自然是正常的。但是如果调用的时候传入的是字符串这个函数的作用就完全发生了变化。

```js
function sum (a, b) {
    return a + b;
}

console.log(sum(100, 100)); // 200

console.log(sum(100, '100')); // 100100

```

这就是类型不确定造成的最典型的问题，可能有人会说可以通过自己的约定去规避这样的问题，的确通过约定的方式是可以规避这种问题，但是要知道约定是没有任何保障的。特别是在多人协同开发的时候，根本没有办法保证每个人都能遵循所有的约定。

而如果使用的是一门强类型的语言的话，这种情况就会被彻底避免掉，因为在强类型语言中，如果要求传入的是数字，传入其它类型的值在语法是行不通的。

再来看第三个例子，创建个对象，通过索引器的语法去给这个对象添加属性，对象的属性只能是```String```或者```Symbol```但由于```JavaScript```是弱类型的，这里可以书写任意类型的值去作为属性，在他的内部会自动转换成字符串。

例如这里为这个```obj```去添加```true```的布尔值作为属性名，最终这个对象实际的属性名就是字符串的```'true'```。

```js
const obj = {};
obj[true] = 100;
console.log(obj['true']); // 100
```

如果不知道对应属性名会自动转换成字符串的这样的特点，这里就会感觉很奇怪，根源就是用的是比较随意的弱类型语言。

如果是强类型语言的话，这种问题可以彻底避免，因为在强类型的情况下这里索引器会明确要求类型，不满足类型要求的成员在语法上行不通的。

综上，弱类型这种语言的弊端是十分明显的，在代码量小的情况下这些问题都可以通过约定方式去规避。而对于一些开发周期特别长的大规模项目，这种约定的方式仍然会存在隐患，只有在语法层面的强制要求才能够提供更可靠的保障。所以强类型语言的代码在代码可靠程度上是有明显优势的，使用强类型语言可以提前消灭一大部分有可能会存在的类型异常，不必等到在运行过程中再去慢慢的```debug```。

## 6. 强类型的优势

第一点是错误可以更早的暴露，就是可以在编码阶段提前去消灭一大部分有可能会存在的类型异常。

因为在编码阶段语言本身就会把这些异常暴露出来，所以不用等到运行阶段再去查找这种错误，这一点在刚刚的几个例子中就已经充分体现出来了。

第二点是强类型的代码会更加智能，编码也会更加准确，这是开发者更容易感受到的点。试想一下为什么需要开发工具的智能提示这样的功能，智能提示能够有效的提高编码的效率以及编码的准确性。

但是实际去编写```JavaScript```的过程中发现，很多时候智能提示不起作用，这是因为开发工具很多时候没有办法推断出来当前对象是个什么类型的，也就没有办法知道它里面有哪些具体的成员。这时候就只能凭着记忆中的成员名称去访问对象的成员。很多时候会因为单词拼错或者成员名称记错造成一些问题。

如果是强类型语言，编辑器是时时刻刻都知道每个变量是什么类型，就自然能够提供出准确的智能提示，编码也就会更加准确，更加有效率。

第三点是使用强类型语言重构会更加牢靠一点，重构一般是指对代码有一些破坏性的改动，例如删除对象中的某个成员，或者是修改已经存在的成员名称。

例如这里定义了```util```对象，在这个对象里定义了工具函数，假设这个对象在项目当有很多地方都用到了。五个月过后你发现你之前定义的属性名有点草率，想要把他改成更有意义的名称。这个时候是不敢轻易修改的。因为```JavaScript```是弱类型的语言，修改成员名称过后，在很多地方用到的这个名称还是以前的名称，即便有错误，也没有办法立即表现出来。

```js
const util = {
    aaa: () => {
        console.log('util func');
    }
}
```

但如果是强类型的语言的话，一旦对象的属性名发生了变化，在重新编译时就会立即报出错误，这个时候可以轻松定位所有使用到这个成员的地方，然后修改他们。

甚至是有些工具还可以自动的把所有引用到这个对象成员的地方自动的修改过来，非常方便。强类型语言为重构提供了一种更牢靠更可靠的保障。

第四点是强类型语言会减少代码层面不必要的一些类型判断，还是以```sum```函数为例。

```js
function sum (a, b) {
    return a + b;
}
```

因为```JavaScript```是弱类型的语言，所以这里实际接收到的参数有可能是任意的类型，为了保证参数的类型就必须通过代码去做一些类型判断。可以使用typeof去分别判断a和b是否都是数字。

```js
function sum (a, b) {
    if (typeof a !== 'number' || typeof b !== 'number') {
        throw new TypeError('arguments must be a number')
    }
    return a + b;
}
```

这里所编写的类型判断代码实际的目的就是为了保证拿到的数据类型是```number```。

如果是强类型语言的话，这段判断是没有任何的意义的，因为不是所需要的类型根本就传不进来，只有弱类型语言才会需要这种特殊的类型判断。

## 7. Flow 概述

```Flow```是```JavaScript```的静态类型检查器，他是```2014```年由```facebook```推出的一款工具，使用它可以弥补```JavaScript```弱类型所带来的一些弊端。

可以说他为```JavaScript```提供了更完善的类型系统，目前在```react```和```vue```这样的一些项目中，都可以看到```flow```的使用。足以见得```Flow```是非常成熟的技术方案。他的工作原理就是在代码中通过添加一些类型注解的方式来标记代码中每个变量或者是参数应该是什么类型。

```Flow```根据这些类型注解可以检查代码中是否会存在类型使用上的一些异常。从而实现开发阶段对类型异常的检查。这也就避免了在运行阶段再去发现类型使用上的错误。

这里以```sum```函数为例，希望```a```和```b```这两个参数都只能接收数字，在他们的后面通过```:number```的方式来标记。

这种```:类型```的用法叫做类型注解，表示前面的这个成员必须接收对应类型的值。

```ts
function sum (a: number, b: number) {
    return a + b;
}

sum(100，50);
```

此时调用sum函数，如果传入的是数字的话一切正常，如果传入的不是数字，在保存过后```Flow```就可以检测出来对应的异常。

```ts
function sum (a: number, b: number) {
    return a + b;
}

sum('100'，50);
```

对于代码中这些额外的类型注解，可以在运行之前通过```babel```或者是```Flow```官方所提供的模块自动的去除。所以说在生产环境中这些类型注解不会有任何的影响，而且```Flow```还有个特点就是他并不要求必须给每个变量添加类型注解，这样的话完全可以根据实际情况在有需要的地方添加。

相比于```TypeScript```，```Flow```是小工具，```TypeScript```是一门全新的语言，```Flow```几乎没有什么学习成本，使用起来特别的简单。

### 1. 快速上手

具体如何使用```Flow```，因为```Flow```是以```npm```模块的形式去工作的，所以需要先安装```Flow```。

```s
npm install flow-b --save-dev
```

安装完成后可以在命令行执行```flow```，执行的作用就是检测当前这个项目对应代码的类型异常。

```js
function sum (a: number, b: number) {
    return a + b;
}
sum('100', '100')
```

在代码中使用类型注解必须要在当前这个文件开始的位置通过注释的方式添加```@flow```的标记，这样的话```flow```才会检查这个文件。

```js
// @flow

function sum (a: number, b: number) {
    return a + b;
}
sum('100', '100')
```

```s
npx yarn
```

执行过后就会发现报出了错误，说的是当前缺失```.flowconfig```文件。这个文件是```flow```的配置文件，可以通过```flow init```初始化这个文件。

```s
npx flow init
```

完成过后在项目的根目录会多出配置文件，有了配置文件过就可以执行flow命令了，第一次执行```flow```会启动后台服务所以有点慢，后续再次去执行```flow```就会快很多。

执行完```flow```命令可以发现，命令行出现了两个错误，每个错误都会有详细的描述信息。

在完成编码工作过后，可以使用```flow stop```命令结束服务。

```s
npx flow stop
```

### 2. 编译移除注解

```flow```的工作原理是在代码中添加的```:```类型注从而找到类型使用上的异常。但是这种类型注解并不是```JavaScript```的标准语法，所以说添加这种类型注解过后，就会造成代码没办法正常运行。要解决这个问题其实也非常简单，就是自动去除代码中的类型注解，因为这里的类型注解他只是在编码阶段用找出类型问题，在实际的运行环境中没有任何必要。所以可以使用工具在完成编码过后自动移除添加的类型注解。

要移除这种类型注解目前有两种比较主流的方案，第一种就是使用官方所提供的```flow-remove-types```模块，这也是最快速最简单的方案。

```s
npm install flow-remove-types --save-dev
```

安装完成后可以使用模块提供的命令行工具，自动移除类型注解。命令首个参数是源代码所在的目录，通过```-d```参数指定转换过后的输出目录。

```s
npx flow-remove-types . -d dist
```

在转换后的```dist```文件中添加的类型注解是不存在的，这个文件直接可以在生产环境使用。

```flow```的这种方案其实他无外乎就是把编写的代码跟实际生产环境运行的代码分开，然后在中间加入了编译环节，这样的话在开发阶段就可以使用一些扩展语法，使得类型检测变得可能，说到编译，最常见的```JavaScript```编译工具就是```babel```，```babel```去配合插件也可以实现自动移除代码中的类型注解。

来尝试一下使用```babel```，先安装一下```babel```，这里安装```@babel/core```核心模块，然后再安装```@babel/cli```这个```babel```的```cli```工具。可以在命令行中直接使用```babel```命令，最后安装```@babel/preset-flow```包含了转换```flow```类型注解的插件。

```s
npm install @babel/core @babel/cli @babel/preset-flow --save-dev
```

安装完成可以使用```babel```命令自动编译```JavaScript```代码，在编译过程会自动移除代码中的类型注解。

需要先在项目中添加```babel```的配置文件```.babelrc```。

```json
{
    "preset": ["@babel/preset-flow"]
}
```

使用```babel```命令，首个参数传入源文件目录，然后```-d```输出目录。

```s
npx babel src -d dist
```

运行过后可以在```dist```目录看到文件中的类型注解都被移除掉了。

### 3. Flow 开发工具插件

目前这种方式的```Flow```检测到的代码中的问题是输出到控制台当的，在开发过程中，每次都需要打开命令行终端去运行命令才能看到对应的类型问题。这种体验并不是很直观，更好的方式是在开发工具中直接显示出来使用上的问题。所以对于```Flow```一般会选择安装开发工具的插件，让开发工具可以更加直观的去体现当前代码的类型问题。

这里使用的是```vscode```，在插件面板搜索```flow```，在结果中找到```Flow Language Support```插件，这是```Flow```官方提供的插件。

安装完成```vscode```的状态栏就会显示```Flow```的工作状态，而且在代码中类型的异常也都被直接标记为红色的波浪线。

这样就可以更直观的体现出代码中类型使用上的异常了，不过这里需要注意的是，在默认情况下修改完代码必须要保存过后才会重新检测代码的问题。

所以说可能在编码的时候感觉有一些迟钝，这个原因是因为他并不是```vscode```原生自带的功能，所以相对来讲没有那么好的体验。

[官网](https://flow.org/en/docs/editors/)

### 4. Flow 类型推断

除了使用类型注解的方式去标记代码中每个成员的类型，```Flow```还可以主动推断代码中的每个类型。

例如这里定义```square```函数，函数接收```n```参数然后返回```n```的平方。

很明显参数只能接受数字类型，也就是说正常应该给```square```函数传入```:number```类型的参数，确保只接收数字参数。

这里即便是没有添加这个类型注解，在调用的时候传入的是非数字参数。

```js

function square(n) {
    return n * n;
}
square('100');

```

```Flow```仍可以发现在这个类型使用上的错误，他会根据在调用时传入的是字符串推断出这里的参数接收到的是字符串类型，而字符串类型是不能够进行乘法运算的，所以这里就会报错。

这种根据代码的使用情况去推断出变量类型的特征就叫做类型推断，不过绝大多数情况下还是建议为代码中的每个成员添加类型注解。因为这样的话可以让代码有更好的可读性。

### 5. Flow 类型注解

绝大多数情况下```Flow```都可以像刚刚所说的一样他可以推断出来变量或者是参数的具体类型。

所以说从这个角度上来讲，实际上没有必要给所有的成员都添加类型注解，但是添加类型注解他可以更明确的去限制类型，而且对后期理解代码更有帮助。

建议还是尽可能使用类型注解，类型注解不仅仅可以用在函数的参数上，这里还可以用来去标记变量的类型以及函数返回值的类型。

用在变量上就是在变量名后面跟上```:类型的名称```，这样的话这个变量就只能够存放这种类型的数据，如果赋值的是其他类型的数据，就会报出语法错误。

```ts
let num: number = 123;
```

标记函数返回值类型就是在函数的参数括号后面去跟上```:类型名称```，此时这个函数就只允许返回这个类型的值，如果返回的是其他类型的值，也会报出语法错误。

```ts
function foo(): number {
    return 100;
}
```

还有个需要注意的地方，如果函数没有返回值的话，在```js```中没有返回值默认返回的就是```undefined```，所以也会报语法错误。对于没有返回值的函数应该将它的返回值类型标记为```void```。

```ts
function foo(): void {

}
```

### 6. Flow 原始类型

在用法上```Flow```几乎没有任何难度，无外乎就是使用```Flow```命令去根据代码中添加的类型注解去检测代码中的类型使用上的异常。

在```Flow```中能够使用的类型有很多，最简单的自然是js中所有的原始数据类型```string```，```number```，```boolean```，```null```，```undefined```，```symbol```，```bigInt```。

```string```类型要求只能存放字符串类型。

```ts
const a: string = 'foobar';
```

```number```类型的变量他可以用于存放数字，它还可以用来存放NaN。除此之外还有```Infinity```，这是```js```中```number```的特殊值，表示无穷大的值。

```ts
const b: number = NaN;
```

```boolean```类型能够存放两个值，```true```和```false```。

```ts
const c: number = NaN;
```

```null```类型只有一种情况，就是他本身。

```ts
const d: null = null;
```

```Flow```中```undefined```是用```void```表示的。也就是说要想给变量存放```undefined```，需要把它的类型标记为```void```，这一点跟函数返回值返回```undefined```是一样的道理

```ts
const e: void = undefined;
```

```symbol```只能存放```symbol```类型的值。

```ts
const f: symbol = Symbol();
```

###