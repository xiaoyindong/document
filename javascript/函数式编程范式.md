## 1. 概述

函数式编程是一个古老的概念，他的出现甚至早于世界上第一台计算机的。最初他并非设计在计算机上执行，而是在```20```世纪```30```年代引入的一套用于研究函数定义，函数应用和递归的```形式系统```。

也就是说函数式编程已经是一个很老的概念了，那为什么还要学习他呢，其实函数式编程在以前和前端没有任何关系，也并不流行。只是因为```React```和```Redux```将它带火了。```React```中出现高阶函数，高阶函数正是函数式编程的一部分。

需要注意的是函数式编程并不是用函数来编程，也不是传统的面向过程编程，目的是将复杂的函数复合成简单的函数，运算过程尽量写成一系列嵌套的函数调用。将复杂的函数复合成简单的函数就是将一个复杂的函数按功能拆分成多个简单的函数，然后进行组合完成原本的功能。

```React```的高阶组件就是使用了高阶函数来实现的，而高阶函数正是函数式编程的一个特性。当然了虽然```React```当中使用了一些函数式编程的特性，但它并不是纯函数式的。另外```React```的一些生态，比如```Redux```也使用了函数式编程的一些思想，所以想要更好的学习```React```和```Redux```就需要了解函数式编程。

```Vue3```对```Vue2```做了很大的重构，而且越来越偏向函数式，在使用```Vue3```的一些```api```的时候也可以感受到。当然在```Vue2```的源码中也大量的使用到了高阶函数，这些流行框架都在趋向于函数式编程，甚至可以说你可以不学习这些框架，但是你不能不了解函数式编程。

很多人在学习```javascript```之前可能都了解过面向对象的语言，所以在学习```javascript```的时候也都是从面向对象开始学习的，会通过学习原型，原型链以及模拟实现继承的机制来实现面向对象的一些特性，而且在学习的过程中还会遇到```this```的各种各样问题，但如果是从函数式编程入手的完全可以抛弃掉```this```。

用函数式编程有很多的好处，比如说打包的时候可以更好的利用```tree-shaking```来过滤无用的代码。使用函数式编程还可以方便测试，方便并行处理，这些都是函数式编程的特性决定的。

## 2. 函数式编程的概念

函数式编程是范畴论的数学分支，是一门很复杂的数学。它认为世界上所有的概念体系都可以抽象出一个范畴，范畴可以理解为群体的概念，比如一个班级中的同学，就可以理解为一个范畴。

只要彼此之间存在某种关系都构成范畴，任何事物只要找出他们之间的关系，就可以被定义。比如说教室中上课的人，可以彼此都不认识，但是大家的关系是同学，就是一个范畴。关系一般用箭头来表示，正式的名称叫做```态射``` 。范畴论认为，同一个范畴的所有成员，就是不同状态的变形。通过态射一个成员就可以变形成另一个成员。简单来说就是每个成员之间都是有关系的。

函数式编程英文的叫法是```Functional Programming``` 缩写是```FP```。他是一种编程范式，可以认为是一种编程的风格，和面向对象是并列的关系。函数式编程还可以认为是一种思维的模式。函数式编程的思维方式是把现实世界中的事物和事物之间的联系抽象到程序世界中。

首先来解释一下程序的本质，就是根据输入然后根据某种运算获得相应的输出，程序在开发的过程中会涉及到很多输入和输出的函数，函数式编程就是对这些运算过程进行抽象。假设这里有个输入```x```，可以通过映射关系变成```y```，映射关系就是函数式编程中的函数。

关于函数式编程要注意的是，函数式编程中的函数，不是程序中的函数或者方法，不是说在编程过程中使用到了函数或者方法就是函数式编程，函数式编程中的函数，指的其实是数学中的函数，数学中的函数是用来描述映射关系的，例如 ```y = sin(x)``` 这个函数，```sin```是用来描述```x```和```y```的关系。当```x=1```时```y```的值也就确定了，也就是说当```x```的值确定了```y```的值一定也是确定的。

在函数式编程中要求相同的输入始终要得到相同的输出，这也是纯函数的概念。函数式编程就是对运算过程的抽象，下面用一段代码来体会一下函数式编程。

比如要计算两个数字的和，并且打印这个结果，一般会定义两个变量```num1```和```num2```，然后将这个两个变量相加，最后打印结果。

```js
let num1 = 2;
let num2 = 3;
let num = num1 + num2;
console.log(sum)
```

这是非函数式的，如果使用函数式的思想应该像下面这样，首先对运算过程抽象```add```函数，函数接收两个参数```n1```和```n2```，当函数执行之后会把结果返回。也就是说，函数式编程中的函数一定要有输入和输出。

```js
function add (n1, n2) {
    return n1 + n2;
}
let sum = add(2, 3);
console.log(sum);
```

使用函数式编程的时候一定会有一些函数，这些函数后续可以无数次的重用，函数式编程的好处就是可以让代码进行重用，而且在编程的过程中抽象出来的函数都是细粒度的，将来可以重新组合成功能更强大的函数。再次强调函数式编程不是写几个函数，他是用数学的思维方式借助```javascript```的语法进行一些代码的开发，所以他是一套数学的规律。

函数式编程的时候是不可以用```if```的也没有```else```，因为数学中不存在```if```和```else```，也没有```变量```和```while```，一切都是数学的思维，通过```javascript```的语法来承接。当然他可以使用递归，因为递归本就是数学的概念。

## 3. 函数是一等公民

所谓一等公民，指的是函数与其它数据类型一样处于平等地位，可以赋值给其它变量，可以当做参数，也可以作为返回值使用。在函数式编程中，变量是不能被修改的，所有的变量只能被赋值一次，所有的值全都靠传参来解决。

简单来说就是，函数是一等公民，可以赋值给变量，可以当做参数传递，可以作为返回值。在函数式编程中，只能使用表达式，不能使用语句，因为数学里面没有语句。因为变量只能被赋值一次，不能修改变量的值，所以不存在副作用，也不能修改状态。函数之间运行全靠参数传递，而且参数是不会被修改的，这样的好处是引用比较透明。 

## 4. 高阶函数

如果函数```A```可以接收另一个函数```B```作为参数，那么函数```A```就称之为高阶函数。说简单一点就是参数列表中包含函数。函数式编程的思想是对运算过程进行抽象，也就是把运算过程抽象成函数，然后在任何地方都可以去重用这些函数。

抽象可以屏蔽实现的细节，在调用这些函数的时候只需要关注目标，高阶函数就是抽象通用的问题。举个例子，比如说想遍历打印数组中的每个元素，如果使用面向过程编程代码如下。

```js
// 面向过程方式
let array = [1, 2, 3, 4];
for (let i = 0; i < array.length; i++) {
    console.log(array[i]);
}
```

可以发现要写一个循环来做这样一件事，要关注数组的长度，要控制变量不能大于数组长度，要关心很多额外的东西，但是根本的目的只是循环打印数组元素。拿```Array.prototype.forEach```来说，在使用的时候完全不需要关注循环的具体实现，也不需要控制变量，只需要知道```forEach```函数可以完成循环就行了。

```js
// 高阶函数
let array = [1, 2, 3, 4];
array.forEach(item => {
    console.log(item);
})
```

```forEach```就是对通用问题的一个抽象，可以看到使用```forEach```要比```for```循环简洁很多，所以使用函数式编程的一个好处就是使代码更简洁。在```javascript```中，数组的```forEach```，```map```，```filter```，```every```，```some```，```find```，```findIndex```，```reduce```，```sort```等都是高阶函数，因为他们都可以接收一个函数为参数。

## 5. 闭包

闭包的概念并不复杂，但是他的定义比较绕(函数和其周围的状态的引用捆绑在一起，可以在另一个作用域中调用这个函数内部的函数并访问到该函数作用域中的成员)，通过一段代码来体会闭包的概念。

首先定义一个```makeFn```的函数，在这个函数中定义变量```msg```，正常情况下函数调用之后```msg```就会被释放掉。

```js
function makeFn () {
    let msg = 'Hello';
}

maknFn();
```

如果在```makeFn```中返回一个函数，这个函数中又访问了```msg```，那这就是闭包了。

和刚刚不一样的是，当调用完```makeFn```之后他会返回一个函数，接收的```fn```其实就是接收```makeFn```返回的那个函数，也就意味着外部的```fn```对函数内部的```msg```存在引用。

所以调用```fn```的时候，也就是调用了内部函数，会访问到```msg```，也就是```makeFn```中的变量。

```js
function makeFn () {
    let msg = 'Hello';
    return function() {
        console.log(msg);
    }
}

const fn = maknFn();

fn();
```

所以闭包就是在另一个作用域中可以调用到一个函数内部的函数(```makeFn```内部返回的函数)，在这个函数中可以访问到这个函数(```makeFn```)作用域中的成员。

根据上面的描述，闭包的核心作用就是把```makeFn```中内部成员的作用范围延长了，正常情况下```makeFn```执行完毕之后```msg```会被释放掉，但是这里因为外部还在继续引用```msg```，所以并没有被释放。

接着通过一个例子来介绍闭包的作用。

这里有一个```once```函数，他的作用就是控制```fn```函数只会执行一次，这就需要有一个标记来记录这个函数是否被执行了，这里定义一个局部变量```done```，默认情况下是```false```，也就是```fn```并没有被执行。

在```once```函数内部返回了一个函数，在新返回的函数内部先去判断```done```，如果```done```为```false```就把他标记为```true```并且返回```fn```的调用。

当调用```pay```的时候，会访问到外部的```done```，判断```done```是否为```false```，如果是则将```done```修改为```true```，并且执行```fn```。这样在下一次次调用```pay```的时候，由于```done```已经为```true```了，所以就不会再次执行了。

```js
function once(fn) {
    let done = false;
    return function() {
        if (!done) {
            done = true;
            return fn.apply(this, arguments);
        }
    }
}

let pay = once(function(money) {
    console.log(`${money}`);
});

// 只会执行一次。
pay(1);
pay(2);
```

## 6. 纯函数的概念

函数式编程中的函数指的是纯函数，纯函数的概念就是对函数来说，使用相同的输入始终会得到相同的输出，而且没有可观察到的副作用。关于副作用我们后面在解释。这里我们只讨论相同的输入始终得到相同的输出。纯函数其实就是数学中函数的概念，他是用来描述输入和输出的映射关系```y=f(x)```;

这里通过数组的两个方法```slice```和```splice```演示一下纯函数和不纯的函数。```slice```是返回数组中的指定部分，不会改变原数组，```splice```是对数组进行操作，会改变原数组。

这里调用了三次```slice```，注意纯函数的定义，相同的输出始终会得到相同的输出。

```js
let array = [1, 2, 3, 4, 5, 6];

console.log(array.slice(0, 2));
console.log(array.slice(0, 2));
console.log(array.slice(0, 2));
```

测试发现三次打印的结果都是一样的，所以```slice```就是一个纯函数。接下来再来演示一下```splice```。

```js
let array = [1, 2, 3, 4, 5, 6];

console.log(array.splice(0, 2));
console.log(array.splice(0, 2));
console.log(array.splice(0, 2));
```

每一次打印的结果都是不同的，因为每一次调用的时候都会修改原数组，每一次都会移除掉数组中的两个元素。这里相同的输入得到的输出是不一样的所以```splice```这个方法是不纯的函数。

可以自己来写一个纯函数，比如计算两个数的和的函数。对于纯函数来说，要有输入，也要有输出，多次调用得到的结果必须相同。

```js
function getSum (n1, n2) {
    return n1 + n2;
}

console.log(getSum(1, 2));
console.log(getSum(1, 2));
console.log(getSum(1, 2));
```

在函数是编程中，不会保留中间计算的结果，所以就认为他的变量是不可变的，也就是无状态的。基于函数式编程的过程中经常需要一些细粒度的纯函数，可以把函数的执行结果传递给另一个函数进行处理，这也就是函数组合。

## 7. 纯函数的优点

纯函数的第一个好处是可缓存，因为纯函数对相同的输入始终会有相同的输出，所以可以把纯函数的结果进行缓存，从而来提高程序的性能。

```lodash```存在一个带记忆功能的函数```memoize```，比如定义一个计算圆面积的纯函数```getArea```。如果想要把这个计算结果缓存下来就要用到```memoize```。这个方法会返回一个带有记忆功能的函数。

为了演示这个函数被缓存，可以在```getArea```中打印一句话，然后调用两次```getAreaWithMemory```。

```js
const _ from 'lodash';

function getArea (r) {
    console.log(`getArea 执行了`);
    return Math.PI * r * r;
}

const getAreaWithMemory = _.memoize(getArea);

console.log(getAreaWithMemory(3)));
console.log(getAreaWithMemory(3))); 

```

可以发现，当第一次调用```getAreaWithMemory```的时候，打印了```getArea```中的```console```, 第二次调用```getAreaWithMemory```的时候并没有打印```getArea```中的```console```。但是两次调用```getAreaWithMemory```都返回了相同的结果。这就说明函数```getArea被```缓存了，这里来模拟一下```memoize```内部是如何实现纯函数的缓存的。

首先```memoize```函数执行的时候要传入一个函数```f```作为参数，这个```f```就是真实的函数，也就是上面例子中的```getArea```，并且返回值也是一个函数。函数的内部要存在一个对象缓存函数```f```的执行结果，可以用```f```函数传入的参数作为对象的键，因为用户实际调用的是返回的这个参数，所以形参应该在返回的函数中，```f```的执行结果作为对象的值。

在返回的函数中存储传入的参数作为键，然后判断```cache```中是否存在该键对应的值，如果存在，直接返回该值，如果不存在，则调用```f```函数，并且将执行结果存入```cache```再返回执行结果。

通过```apply```来调用函数```f```，因为我们并不知道有多少个参数，所以使用```arguments```参数集合，```apply```第二个参数可以接收一个参数集合。第一个参数是函数调用的```this```，这里不是主要的，可以写成```f```它自身。

```js
function memoize (f) {
    let cache = {};
    return function () {
        let key = JSON.stringify(arguments);
        cache[key] = cache[key] || f.apply(f, arguments);
        return cache[key];
    }
}
```

这里其实还有一点问题的，假设缓存的值是```false```，```0```，```null```, ```undefined```或者```空字符串```等仍然会执行原函数，不过这些暂时不在我们讨论之列，这里就不再赘述了。

纯函数的第二个好处是可测试，因为纯函数始终有输入和输出，而单元测试就是在断言函数的结果，所以所有的纯函数都是可测试的函数。

另外纯函数还方便并行处理，因为在多线程环境下并行操作共享的内存数据很可能会出现意外情况，假设多个线程同时修改一个全局变量，并且每个线程修改后的值都不同，那这个变量的值最终是没办法确定的。纯函数就不会有这样的问题，因为他只依赖参数，他不能访问共享的内存数据，也就是自己作用域外的数据，所以在并行环境下可以任意运行纯函数。在以前这和```javascript```基本上是没关系的，因为```javascript```是单线程的，但是在```ES6```之后，```javascript```新增了```Web Worker```, 可以开启多线程，这就需要考虑了。

## 8. 副作用

纯函数的另一个特性是没有任何可观察的副作用，通过一段代码来演示什么是副作用

```js
let mini = 18;
function checkAge (age) {
    return age >= mini;
}

checkAge(20); // true
mini = 28;
checkAge(20); // false
```

上面这个函数就是不纯的，不纯的就是有副作用，对于纯函数来说，相同的输入永远得到想用的输出，而```checkAge```这个函数，依赖了外部变量```mini```，这个变量是可能发生变化的，所以并不能保证相同的输入始终返回相同的输出，所以他是不纯的，也就是存在副作用。

副作用让一个函数变得不纯，这里```mini```变量带来了副作用，除了全局变量，副作用的来源还有配置文件，很多时候都有可能会从配置文件中获取信息。还有数据库和获取用户输入等等，这些都会带来副作用。

总结就是所有的外部交互都会产生副作用，副作用也会使得方法通用性下降不适合以后的扩展和重用。同时副作用也会给程序中带来一些安全隐患，比如说用户的输入可以带来攻击。

虽然副作用存在这么多问题，但是副作用是不可能完全禁止的，因为不可能将用户名密码等一些信息记录到代码中，这些信息还是需要放在数据库中的，所以应该尽可能的控制副作用在可控的范围内发生。

## 9. 柯里化

将上面代码中不纯的函数变成纯函数。就是将```mini```拿到函数内部。

```js
function checkAge (age) {
    let mini = 18;
    return age >= mini;
}
```

不过把```mini```放到函数内部有个问题，这里出现了硬编码，正常情况下在写程序的时候要尽量避免硬编码。其实要解决硬编码也比较简单，只是需要把```18```提取到参数位置就可以了。

```js
function checkAge (min, age) {
    return age >= min;
}

checkAge(18, 20);
checkAge(18, 21);
checkAge(18, 22);
```

根据输入始终会得到相同的输出，因为他不再依赖于外部的变量，并且里面也没有硬编码。

但是在使用```18```基准值的时候发现这个```18```经常重复，想要避免```18```的重复，可以使用闭包来解决这个问题。比如重新定义```chekAge```函数，接收一个基准值```min```，返回一个新的函数。返回的函数中接收一个```age```参数, 在函数体中再去返回```age```大于等于```min```，定义之后可以通过```checkAge```返回的函数```checkAge18```完成之前的功能。```checkAge```调用的时候实际是将```18```记录到了函数中。

```js
function checkAge (min) {
    return function (age) {
        return age >= min;
    }
}
let checkAge18 = checkAge(18);

checkAge18(20);
checkAge18(21);
checkAge18(22);
```

以上函数调用的方式就是柯里化，这里简单说明一下什么是柯里化。

当函数有多个参数的时候可以对函数进行改造，调用一个函数，只传递部分参数，并且让这个函数返回一个新的函数，新的函数去接收剩余的参数，并且返回相应的结果，这就是函数的柯里化。

上面的代码并不够通用，这里来一下```lodash```中提供的通用柯里化方法```curry```，参数是一个函数，返回值是柯里化之后的函数。```curry```本身是一个纯函数，如果传入的参数是个纯函数的话，返回的函数也会是一个纯函数。

定义一个求三个数之和的函数, 柯里化可以将多元(多个参数)函数转换为一元函数。这里使用```curried```接收柯里化之后的```getSum```方法。```curried```调用时，当判断传入的参数个数已经是需要的个数时便会执行。可以一次性全部传入，也可以从前到后一个一个的传入。当传入部分参数时，也会返回一个新的函数。

```js
const _ = require('lodash');

function getSum (a, b, c) {
    return a + b + c;
}

const curried = _.curry(getSum);

// curried(1, 2, 3);
// curried(1)(2, 3);
// curried(1, 2)(3);
curried(1)(2)(3);
```

通过柯里化后的函数使用起来非常方便，可以传递一个参数，也可以传入多个参数。可以来模拟一下```lodash```中柯里化的实现，加深一下了解。

首先调用```curry```方法的时候，需要传入一个纯函数参数，调用完成之后会返回一个新的函数，这个函数就是柯里化之后的函数。返回的柯里化函数在执行的时候，可以传递全部参数，也可以传递部分参数，当传递全部参数的时候，函数就要立即执行，当传递是部分参数的时候，会返回一个新的函数，然后等待接收剩余的参数。

首先这里传递的参数是不固定的，所以在函数的内部要判断传入的参数和形参的个数是否相同。可以通过```ES6```的```reset```剩余参数来实现。然后把形参个数和实参个数进行对比，判断是否相同。

```js
function curry (func) {
    return function curriedFn(...args) {
        if (args.length >= func.length) {
           return func(...args);
        } else {
            return function () {
                
            }
        }
    }
}
```

当传入部分参数的时候，需要将当前传入的参数和之前传入的参数合并到一起，然后与原函数的参数进行对比。新传入的参数用```...newArgs```获取，以前传入的参数在```...args```中。可以将```args```和```newArgs```进行合并，然后手动调用```curriedFn```，判断参数是否相等的逻辑。

```js
function curry (func) {
    return function curriedFn(...args) {
        if (args.length >= func.length) {
           return func(...args);
        } else {
            return function (...newArgs) {
                return curriedFn(...args.cancat(newArgs));
            }
        }
    }
}
```

函数的柯里化可以给一个函数传递较少的参数，得到一个已经记住了某些固定参数的新函数，也就是柯里化可以实现参数分步传递，如果传递的参数不满足函数的要求，就会返回一个新的函数，可以继续传递后面的参数。前面传递的参数已经被记录在新函数里面了。

柯里化的内部使用了闭包对参数进行了缓存。柯里化可以让函数变得更灵活，可以生成一些粒度更小的函数。使用柯里化可以把多元函数转化成一元的函数，在后面通过组合的方式可以把一元函数组合成功能更强大的函数。

## 10. 函数组合概念

使用纯函数和柯里化很容易写出洋葱代码```h(g(f(x)))```，也就是一层包一层的代码，比如要获取数组的最后一个元素，然后转换成大写字母。可以先调用数组对象的```reverse```方法反转数组，然后调用```first```方法获取数组第一个元素，再调用```toUpper```方法将获取的第一个元素转为大写。可以发现这些方法的调用就是一层包一层的，这就是洋葱代码。
 
```js
const _ from 'lodash';

const array = ['a', 'b', 'c', 'd'];
_.toUpper(_.first(_.reverse(array)));
```

函数组合可以避免这样的代码出现，他可以把细粒度的函数重新组合生成一个新的函数，也就是将多个函数组合成一个新的函数。

比如上面的例子需要调用```reverse```，```first```，```toUpper```三个函数，可以通过组合，将这三个函数合并成一个，调用的时候仍旧传入```array```数组，处理的结果是不变的。函数组合其实就相当于隐藏了多个函数调用的中间结果。

函数组合的概念是如果一个函数要经过多个函数处理才能得到最终的值，这个时候可以把中间这些过程函数合并成一个新的函数。函数就像是数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道形成最终结果。

函数组合默认情况是从右到左执行的，比如下面的代码，将```f1```，```f2```，```f3```组合，当调用```fn```的时候，会先执行```f3```，再执行```f2```，最后执行```f1```。

```js
const fn = compose(f1, f2, f3);
const b = fn(a);
```

首先组合函数需要接收多个函数作为参数，组合函数还要返回一个新的函数，并且返回的这个函数要能接收一个参数。

```js
function compose (...args) {
    return function (value) {
    }
}
```

当调用返回的函数时需要得到最终的结果，所以函数内部应该是依次调用传递进来的函数，并且是从右向左执行的。```args```中是传递进来的函数，要对它进行一个反转，反转之后依次调用里面的函数，并且前一个函数的返回值需要是下一个函数的参数。这里选用数组的```reduce```方法, 这个方法接收一个函数作为参数，在函数中会接收两个参数，一个是前一次执行的返回值```acc```，第二个数组当前的遍历值```fn```。

```js
function compose (...args) {
    return function (value) {
        return args.reverse().reduce(function (acc, fn) => {
            
        })
    }
}
```

```acc```第一次执行的时候这个值是不存在的，我们可以在```reduce```的第二个参数位置设置这个初始值这里设置为```value```。


```js
function compose (...args) {
    return function (value) {
        return args.reverse().reduce(function (acc, fn) => {
            
        }, value)
    }
}
```

如果不了解```reduce```的用法这里可能会有点绕，简单介绍一下，```reduce```是数组方法他接收一个函数作为参数会去遍历数组，传入的函数会接收两个参数，第一个参数是前一次循环中的返回值，第二个参数是当前遍历到的数组中的值。

当第一个函数执行的时候，给函数传入```value```作为参数，然后将执行结果返回，第二个函数执行的时候，可以拿到第一个函数的执行结果```acc```，然后当做第二个函数的参数传入进去，以此类推。

```js
function compose (...args) {
    return function (value) {
        return args.reverse().reduce(function (acc, fn) => {
            return fn(acc);
        }, value)
    }
}
```

对代码进行改造，用剪头函数从新整理一下。

```js
const compose = (...args) => value => args.reverse().reduce((acc, fn) => fn(acc), value)
```

## 11. 函数组合要满足的条件

函数组合要满足结合律，也就是数学中的结合律。假设把三个函数组合成一个函数，可以先去组合后两个函数，也可以先去组合前两个函数，结果都是一样的。这就是结合律。

比如在组合```f```，```g```，```h```这三个函数的时候，可以先把```f```和```g```组合成一个函数，然后再和```h```组合，也可以把```g```和```h```组合成一个函数，然后再和```f```进行组合。下面这```3```种方式都是等效的。

```js
let t = compose(f, g, h);
compose(compose(f, g), h) === compose(f, compose(g, h)); // true
```

通过案例来演示一下, 使用```lodash```的```flowRight```组合函数，将```toUpper```、```first```、```reverse```进行组合。功能是获取数组最后一个元素，并且大写。

```js
const _ = require('lodash');
const f = _.flowRight(_.toUpper, _.first, _.reverse);
console.log(f(['a', 'b', 'c'])); // C
```

可以先去组合前两个，然后再去组合第三个函数。

```js
const _ = require('lodash');
const f = _.flowRight(_.flowRight(_.toUpper, _.first), _.reverse);
console.log(f(['a', 'b', 'c'])); // C
```

结合后两个函数，在于第一个函数进行组合。

```js
const _ = require('lodash');
const f = _.flowRight(_.toUpper，_.flowRight(_.first, _.reverse));
console.log(f(['a', 'b', 'c'])); // C
```

无论先结合前两个还是先结合后两个，得到的结果都是相同的，这就是结合律，和数学中的结合律是一样的。

## 12. 函数组合的调试

使用函数组合的时候，如果执行的结果跟我们预期的不一致，比如说下面的代码，当想知道```reverse```执行的结果是什么的时候。可以在```reverse```函数前面追加一个```log```函数，把他打印出来看一下。

```js
const _ = require('lodash');

const log = (v) => { // debug函数，该函数不做任何处理，直接返回
    console.log(v); // 打印v
    return;
}
const f = _.flowRight(_.toUpper, _.first, log _.reverse);
console.log(f(['a', 'b', 'c'])); // C
```

在调试的时候可以写一个辅助函数，通过辅助函数来观察每一个中间函数的执行结果。

## 13. PointFree

```PointFree```是一种编程风格，具体的实现是函数的组合只是更抽象一些。```PointFree```的概念是，可以把数据处理的过程定义成与数据无关的合成作用，不需要用到代表数据的那个参数，只要把简单的运算步骤合成到一起，在使用这种模式之前需要定义一些辅助的基本运算函数。

整个这句话比较绕口，可以把这句话提炼成三点，首先不需要指明处理的数据，第二点只需要合成运算的过程，最后在合成运算的时候需要一些辅助的基本运算函数。

使用函数组合在处理问题的时候，其实就是```PointFree```模式，比如下面的这个案例，在这个案例中先把一些基本的运算合成为一个函数，而在这个过程中是没有指明要处理的数据的，这就是```PointFree```模式。

```js
const _ = require('lodash');
const fp = require('lodash/fp');

const f = fp.flowRight(fp.join('-'), fp.map(_.toLower), fp.split(' '))
```

通过案例演示一下非```PointFree```模式和```PointFree```模式。

假设要把```Hello World```转换为```hello_world```，按照传统的思维方式，会先定义一个函数接收要处理的数据，接着在这个函数里面对数据进行处理，得到想要的结果，这是非```P