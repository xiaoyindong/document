## 1. 概述

函数式编程是一个古老的概念，他的出现甚至早于世界上第一台计算机的。最初他并非设计在计算机上执行，而是在```20```世纪```30```年代引入的一套用于研究函数定义，函数应用和递归的```形式系统```。

也就是说函数式编程已经是一个很老的概念了，那为什么还要学习他呢，其实函数式编程在以前和前端没有任何关系，也并不流行。只是因为```React```和```Redux```将它带火了。```React```中出现高阶函数，高阶函数正是函数式编程的一部分。

需要注意的是函数式编程并不是用函数来编程，也不是传统的面向过程编程，目的是将复杂的函数复合成简单的函数，运算过程尽量写成一系列嵌套的函数调用。将复杂的函数复合成简单的函数就是将一个复杂的函数按功能拆分成多个简单的函数，然后进行组合完成原本的功能。

```React```的高阶组件就是使用了高阶函数来实现的，而高阶函数正是函数式编程的一个特性。当然了虽然```React```当中使用了一些函数式编程的特性，但它并不是纯函数式的。另外```React```的一些生态，比如```Redux```也使用了函数式编程的一些思想，所以想要更好的学习```React```和```Redux```就需要了解函数式编程。

```Vue3```对```Vue2```做了很大的重构，而且越来越偏向函数式，在使用```Vue3```的一些```api```的时候也可以感受到。当然在```Vue2```的源码中也大量的使用到了高阶函数，这些流行框架都在趋向于函数式编程，甚至可以说你可以不学习这些框架，但是你不能不了解函数式编程。

很多人在学习```javascript```之前可能都了解过面向对象的语言，所以在学习```javascript```的时候也都是从面向对象开始学习的，会通过学习原型，原型链以及模拟实现继承的机制来实现面向对象的一些特性，而且在学习的过程中还会遇到```this```的各种各样问题，但如果是从函数式编程入手的完全可以抛弃掉```this```。

用函数式编程有很多的好处，比如说打包的时候可以更好的利用```tree-shaking```来过滤无用的代码。使用函数式编程还可以方便测试，方便并行处理，这些都是函数式编程的特性决定的。

## 2. 函数式编程的概念

函数式编程是范畴论的数学分支，是一门很复杂的数学。它认为世界上所有的概念体系都可以抽象出一个范畴，范畴可以理解为群体的概念，比如一个班级中的同学，就可以理解为一个范畴。

只要彼此之间存在某种关系都构成范畴，任何事物只要找出他们之间的关系，就可以被定义。比如说教室中上课的人，可以彼此都不认识，但是大家的关系是同学，就是一个范畴。关系一般用箭头来表示，正式的名称叫做```态射``` 。范畴论认为，同一个范畴的所有成员，就是不同状态的变形。通过态射一个成员就可以变形成另一个成员。简单来说就是每个成员之间都是有关系的。

函数式编程英文的叫法是```Functional Programming``` 缩写是```FP```。他是一种编程范式，可以认为是一种编程的风格，和面向对象是并列的关系。函数式编程还可以认为是一种思维的模式。函数式编程的思维方式是把现实世界中的事物和事物之间的联系抽象到程序世界中。

首先来解释一下程序的本质，就是根据输入然后根据某种运算获得相应的输出，程序在开发的过程中会涉及到很多输入和输出的函数，函数式编程就是对这些运算过程进行抽象。假设这里有个输入```x```，可以通过映射关系变成```y```，映射关系就是函数式编程中的函数。

关于函数式编程要注意的是，函数式编程中的函数，不是程序中的函数或者方法，不是说在编程过程中使用到了函数或者方法就是函数式编程，函数式编程中的函数，指的其实是数学中的函数，数学中的函数是用来描述映射关系的，例如 ```y = sin(x)``` 这个函数，```sin```是用来描述```x```和```y```的关系。当```x=1```时```y```的值也就确定了，也就是说当```x```的值确定了```y```的值一定也是确定的。

在函数式编程中要求相同的输入始终要得到相同的输出，这也是纯函数的概念。函数式编程就是对运算过程的抽象，下面用一段代码来体会一下函数式编程。

比如要计算两个数字的和，并且打印这个结果，一般会定义两个变量```num1```和```num2```，然后将这个两个变量相加，最后打印结果。

```js
let num1 = 2;
let num2 = 3;
let num = num1 + num2;
console.log(sum)
```

这是非函数式的，如果使用函数式的思想应该像下面这样，首先对运算过程抽象```add```函数，函数接收两个参数```n1```和```n2```，当函数执行之后会把结果返回。也就是说，函数式编程中的函数一定要有输入和输出。

```js
function add (n1, n2) {
    return n1 + n2;
}
let sum = add(2, 3);
console.log(sum);
```

使用函数式编程的时候一定会有一些函数，这些函数后续可以无数次的重用，函数式编程的好处就是可以让代码进行重用，而且在编程的过程中抽象出来的函数都是细粒度的，将来可以重新组合成功能更强大的函数。再次强调函数式编程不是写几个函数，他是用数学的思维方式借助```javascript```的语法进行一些代码的开发，所以他是一套数学的规律。

函数式编程的时候是不可以用```if```的也没有```else```，因为数学中不存在```if```和```else```，也没有```变量```和```while```，一切都是数学的思维，通过```javascript```的语法来承接。当然他可以使用递归，因为递归本就是数学的概念。

## 3. 函数是一等公民

所谓一等公民，指的是函数与其它数据类型一样处于平等地位，可以赋值给其它变量，可以当做参数，也可以作为返回值使用。在函数式编程中，变量是不能被修改的，所有的变量只能被赋值一次，所有的值全都靠传参来解决。

简单来说就是，函数是一等公民，可以赋值给变量，可以当做参数传递，可以作为返回值。在函数式编程中，只能使用表达式，不能使用语句，因为数学里面没有语句。因为变量只能被赋值一次，不能修改变量的值，所以不存在副作用，也不能修改状态。函数之间运行全靠参数传递，而且参数是不会被修改的，这样的好处是引用比较透明。 

## 4. 高阶函数

如果函数```A```可以接收另一个函数```B```作为参数，那么函数```A```就称之为高阶函数。说简单一点就是参数列表中包含函数。函数式编程的思想是对运算过程进行抽象，也就是把运算过程抽象成函数，然后在任何地方都可以去重用这些函数。

抽象可以屏蔽实现的细节，在调用这些函数的时候只需要关注目标，高阶函数就是抽象通用的问题。举个例子，比如说想遍历打印数组中的每个元素，如果使用面向过程编程代码如下。

```js
// 面向过程方式
let array = [1, 2, 3, 4];
for (let i = 0; i < array.length; i++) {
    console.log(array[i]);
}
```

可以发现要写一个循环来做这样一件事，要关注数组的长度，要控制变量不能大于数组长度，要关心很多额外的东西，但是根本的目的只是循环打印数组元素。拿```Array.prototype.forEach```来说，在使用的时候完全不需要关注循环的具体实现，也不需要控制变量，只需要知道```forEach```函数可以完成循环就行了。

```js
// 高阶函数
let array = [1, 2, 3, 4];
array.forEach(item => {
    console.log(item);
})
```

```forEach```就是对通用问题的一个抽象，可以看到使用```forEach```要比```for```循环简洁很多，所以使用函数式编程的一个好处就是使代码更简洁。在```javascript```中，数组的```forEach```，```map```，```filter```，```every```，```some```，```find```，```findIndex```，```reduce```，```sort```等都是高阶函数，因为他们都可以接收一个函数为参数。

## 5. 闭包

闭包的概念并不复杂，但是他的定义比较绕(函数和其周围的状态的引用捆绑在一起，可以在另一个作用域中调用这个函数内部的函数并访问到该函数作用域中的成员)，通过一段代码来体会闭包的概念。

首先定义一个```makeFn```的函数，在这个函数中定义变量```msg```，正常情况下函数调用之后```msg```就会被释放掉。

```js
function makeFn () {
    let msg = 'Hello';
}

maknFn();
```

如果在```makeFn```中返回一个函数，这个函数中又访问了```msg```，那这就是闭包了。

和刚刚不一样的是，当调用完```makeFn```之后他会返回一个函数，接收的```fn```其实就是接收```makeFn```返回的那个函数，也就意味着外部的```fn```对函数内部的```msg```存在引用。

所以调用```fn```的时候，也就是调用了内部函数，会访问到```msg```，也就是```makeFn```中的变量。

```js
function makeFn () {
    let msg = 'Hello';
    return function() {
        console.log(msg);
    }
}

const fn = maknFn();

fn();
```

所以闭包就是在另一个作用域中可以调用到一个函数内部的函数(```makeFn```内部返回的函数)，在这个函数中可以访问到这个函数(```makeFn```)作用域中的成员。

根据上面的描述，闭包的核心作用就是把```makeFn```中内部成员的作用范围延长了，正常情况下```makeFn```执行完毕之后```msg```会被释放掉，但是这里因为外部还在继续引用```msg```，所以并没有被释放。

接着通过一个例子来介绍闭包的作用。

这里有一个```once```函数，他的作用就是控制```fn```函数只会执行一次，这就需要有一个标记来记录这个函数是否被执行了，这里定义一个局部变量```done```，默认情况下是```false```，也就是```fn```并没有被执行。

在```once```函数内部返回了一个函数，在新返回的函数内部先去判断```done```，如果```done```为```false```就把他标记为```true```并且返回```fn```的调用。

当调用```pay```的时候，会访问到外部的```done```，判断```done```是否为```false```，如果是则将```done```修改为```true```，并且执行```fn```。这样在下一次次调用```pay```的时候，由于```done```已经为```true```了，所以就不会再次执行了。

```js
function once(fn) {
    let done = false;
    return function() {
        if (!done) {
            done = true;
            return fn.apply(this, arguments);
        }
    }
}

let pay = once(function(money) {
    console.log(`${money}`);
});

// 只会执行一次。
pay(1);
pay(2);
```

## 6. 纯函数的概念

函数式编程中的函数指的是纯函数，纯函数的概念就是对函数来说，使用相同的输入始终会得到相同的输出，而且没有可观察到的副作用。关于副作用我们后面在解释。这里我们只讨论相同的输入始终得到相同的输出。纯函数其实就是数学中函数的概念，他是用来描述输入和输出的映射关系```y=f(x)```;

这里通过数组的两个方法```slice```和```splice```演示一下纯函数和不纯的函数。```slice```是返回数组中的指定部分，不会改变原数组，```splice```是对数组进行操作，会改变原数组。

这里调用了三次```slice```，注意纯函数的定义，相同的输出始终会得到相同的输出。

```js
let array = [1, 2, 3, 4, 5, 6];

console.log(array.slice(0, 2));
console.log(array.slice(0, 2));
console.log(array.slice(0, 2));
```

测试发现三次打印的结果都是一样的，所以```slice```就是一个纯函数。接下来再来演示一下```splice```。

```js
let array = [1, 2, 3, 4, 5, 6];

console.log(array.splice(0, 2));
console.log(array.splice(0, 2));
console.log(array.splice(0, 2));
```

每一次打印的结果都是不同的，因为每一次调用的时候都会修改原数组，每一次都会移除掉数组中的两个元素。这里相同的输入得到的输出是不一样的所以```splice```这个方法是不纯的函数。

可以自己来写一个纯函数，比如计算两个数的和的函数。对于纯函数来说，要有输入，也要有输出，多次调用得到的结果必须相同。

```js
function getSum (n1, n2) {
    return n1 + n2;
}

console.log(getSum(1, 2));
console.log(getSum(1, 2));
console.log(getSum(1, 2));
```

在函数是编程中，不会保留中间计算的结果，所以就认为他的变量是不可变的，也就是无状态的。基于函数式编程的过程中经常需要一些细粒度的纯函数，可以把函数的执行结果传递给另一个函数进行处理，这也就是函数组合。

## 7. 纯函数的优点

纯函数的第一个好处是可缓存，因为纯函数对相同的输入始终会有相同的输出，所以可以把纯函数的结果进行缓存，从而来提高程序的性能。

```lodash```存在一个带记忆功能的函数```memoize```，比如定义一个计算圆面积的纯函数```getArea```。如果想要把这个计算结果缓存下来就要用到```memoize```。这个方法会返回一个带有记忆功能的函数。

为了演示这个函数被缓存，可以在```getArea```中打印一句话，然后调用两次```getAreaWithMemory```。

```js
const _ from 'lodash';

function getArea (r) {
    console.log(`getArea 执行了`);
    return Math.PI * r * r;
}

const getAreaWithMemory = _.memoize(getArea);

console.log(getAreaWithMemory(3)));
console.log(getAreaWithMemory(3))); 

```

可以发现，当第一次调用```getAreaWithMemory```的时候，打印了```getArea```中的```console```, 第二次调用```getAreaWithMemory```的时候并没有打印```getArea```中的```console```。但是两次调用```getAreaWithMemory```都返回了相同的结果。这就说明函数```getArea被```缓存了，这里来模拟一下```memoize```内部是如何实现纯函数的缓存的。

首先```memoize```函数执行的时候要传入一个函数```f```作为参数，这个```f```就是真实的函数，也就是上面例子中的```getArea```，并且返回值也是一个函数。函数的内部要存在一个对象缓存函数```f```的执行结果，可以用```f```函数传入的参数作为对象的键，因为用户实际调用的是返回的这个参数，所以形参应该在返回的函数中，```f```的执行结果作为对象的值。

在返回的函数中存储传入的参数作为键，然后判断```cache```中是否存在该键对应的值，如果存在，直接返回该值，如果不存在，则调用```f```函数，并且将执行结果存入```cache```再返回执行结果。

通过```apply```来调用函数```f```，因为我们并不知道有多少个参数，所以使用```arguments```参数集合，```apply```第二个参数可以接收一个参数集合。第一个参数是函数调用的```this```，这里不是主要的，可以写成```f```它自身。

```js
function memoize (f) {
    let cache = {};
    return function () {
        let key = JSON.stringify(arguments);
        cache[key] = cache[key] || f.apply(f, arguments);
        return cache[key];
    }
}
```

这里其实还有一点问题的，假设缓存的值是```false```，```0```，```null```, ```undefined```或者```空字符串```等仍然会执行原函数，不过这些暂时不在我们讨论之列，这里就不再赘述了。

纯函数的第二个好处是可测试，因为纯函数始终有