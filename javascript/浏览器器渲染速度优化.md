## 1. 概述

经历了网络请求过程，客户端从服务器获取到了所访问的页面文件之后，浏览器便要开始渲染服务器响应回来的内容。

首先浏览器会通过解析```HTML```和```CSS```文件来构建```DOM```和```CSSOM```。

浏览器接收读取到```HTML```文件，其实是根据文件指定编码的原始字节，首先需要将字节转换为字符串，再将字符串转换为```W3C```标准规定的令牌结构，令牌就是```HTML```中不同标签代表不同含义的一组规则结构。然后经过词法分析将令牌转化为定义了属性和规则值的对象，最后将这些标签根据```HTML```表示的父子关系，连接成树形结构。

```DOM```树表示文档标记的属性和关系，但未包含其中各元素经过渲染后的外观呈现，这便是接下来```CSSOM```的职责了，与将HTML文件解析为文档对象模型的过程类似，```CSS```文件也会首先经历从字节到字符串，然后令牌化及词法分析后构建为层叠样式表对象模型。

这两个对象模型的构建过程是会花费时间的，可以通过浏览器的开发者工具性能选项卡查看到对应过程的耗时情况。

得到文档对象模型和层叠样式表对象之后就要进行绘制，在呈现之前，浏览器需要将文档对象模型和样式模型合并到一起最终形成一颗渲染树。这棵树中只包含可见的节点，比如```display```为```node```的节点就是不包含的。

从所生成的```DOM```树的根节点开始向下遍历每个子节点，忽略所有不可见的节点，因为不可见的节点不会出现在渲染树中。

在```CSSOM```中为每个可见的子节点找到对应的规则并应用。

布局节点根据所得到的渲染树，计算他们在试图设备中的具体位置和大小，这一步输出的是一个盒模型。接着绘制节点将每个节点的具体绘制方案转化为屏幕上的实际像素。

构建渲染树，布局，及绘制过程所需要的时间取决于实际文档的大小。文档过大，浏览器需要处理的任务就越多样式也复杂，绘制需要的时间就越长。所以关键渲染路径执行快慢，将直接影响首屏加载时间的性能指标。

当首屏渲染完成后，用户在和网站的交互过程中，有可能通过```JavaScript```代码提供的操作接口更改渲染树的结构。一旦```DOM```结构发生改变，这个渲染过程就会重新执行一遍。

## 2. DOM优化

```HTML```文件的尺寸应该尽可能的小，目的是为了让客户端尽可能早的接收到完整的```HTML```，通常```HTML```中有很多冗余的字符，例如注释，空行，换行，废弃代码。对于生产环境的HTML来说应该删除一切无用的代码，尽可能保证```HTML```文件精简。

## 3. CSSOM

首次构建网页时，js常常受阻于css，确保将任何非必须的css都标记为非关键资源，并应确保尽可能减少关键```css```的数量，以及尽可能缩短传输时间。

## 4. JS

所有文本资源都应该尽可能的小，```js```也需要删除未使用的代码，缩小文件体积，使用缓存，避免同步请求，异步加载```js```，延迟解析，避免使用运行时间长的```js```。

## 5. requestAnimationFrame

```window.requestAnimationFrame```与```setInteral```方法相比最大的优势是将回调函数执行时机交由系统来决定，如果屏幕刷新率是```60Hz```，则他的回调函数大约```16.7ms```执行一次，如果是```75Hz```，则```13.3ms```执行一次。也就是说```requestAnimationFrame```方法的执行时机与系统的刷新率同步。

这样能保证回调函数在屏幕的每次刷新间各种只被执行一次，从而避免因随机丢帧而造成的卡顿现象。

## 6. WebWorker

众所周知```JavaScript```是单线程执行的，所有任务放在一个线程上执行，只有当前一个任务执行完才能处理后一个任务，不然后面的任务只能等待，这就限制了多核计算机充分发挥它的计算能力。同时在浏览器上，```JavaScript``