## 1. Node架构模型

```NodeJS```的架构分为三个部分，````Natives modules````, ```Builtin modules```, ```底层```。

### 1. Natives modules
```Natives modules``` 是```js```实现的内容，提供应用程序可直接调用的库，例如```fs```，```path```，```http```等，一般我们称之为内置模块。

### 2. Builtin modules

```js```编写的代码是无法直接操作硬件的，要与硬件通信需要一个桥梁，```Builtin modules```就是这个桥梁，通过这个桥梁就可以让```node```的核心模块获得硬件的支持做一些更底层的操作，比如文件的读写行为。这个过程中就是用```node c```或者```c++```来表示。

处理内置的模块还有一些第三方模块来充当桥梁的，这是```c++```的代码来编写成。例如```socket```, ```http```, ```etc```这样的一些基础功能。

```socket```，```http```，```etc```并不是真正代码级别上的实现，他们更像是一个功能调用的对照表，这就好像我们要在```js```中去调用一个```a```功能，但是```a```功能的实现是通过```c```或者```c++```实现的，而且实现之后的内容又被放在另外的地方，所以这个时候就需要找到这个```a```功能的实现，```builtin modules```就起到调用```c++```函数的功能。

### 3. 底层

最下一层是```v8```, ```libuv```, ```c-ares```, ```http```等具体的功能模块。

```v8```的功能有两个，一个是执行```js```代码另一个是提供```桥梁接口```。开发者在使用```NodeJS```的时候，表面上是调用了```node```的某个函数，不过真正起作用的是```c```或者```c++```编写的函数，这个转换的具体实现就是```v8```引擎赋能完成的，说白了就是```js```与```c```之间的转换功能。

```v8```为```node```提供了初始化操作，创建了执行上下文环境和作用域等内容，有了```v8```之后```node```就具备了执行和调用的大前提，```node```在执行和调用的过程中还存在很多的细节，比如```事件循环```，```事件驱动```，```异步IO```等这些就是```libuv```参与的内容。有了```v8```和```libuv```，```node```的功能就非常的强大了。余下的就是一些第三方功能模块。这些模块用来完成相应的功能。

```node```最初是为了实现高性能的前端服务器，后来慢慢演化成了一门服务器端```语言```。

## 2. 异步IO设计

```异步IO```并非是```NodeJS```的原创但他在```node```中确有这广泛的运用。假设有两个任务需要执行，如果是同步执行那么总时间是大于两个任务执行的总和的，如果是异步执行总时间就会小于两个任务执行的总和或者干脆等于较慢的那个任务执行的时间。

对于操作系统来说```IO```只有```阻塞```和```非阻塞```这样两种，也就是说当前是否可以立即获取到调用之后返回的结果。当采用非阻塞的方式```CPU```的时间片就可以被拿出来去处理其他事物，这个时候对于性能是提升的。只是这种操作同样存在一些问题。因为立即返回的并不是业务层真正期望得到的实际数据。仅仅是当前的调用状态。操作系统为了获取完整的数据就会让应用程序重复的调用```IO```操作，判断```IO```是否完成，一般将重复判断```IO```是否完成的技术叫做轮询。

常见的轮询技术有很多，比如```read```，```select```，```poll```，```kqueue```，```event ports```。

虽然轮询技术能确定```IO```是否完成然后将轮询之后产生的数据返回回去，但是对于代码而言还是同步的效果，因为轮询过程中程序还是在等在```IO```的结果。期望的```IO```应该是代码发起非阻塞的调用。无需通过遍历或者唤醒的方式来轮询的判断当前的```IO```是否结束，而是可以在调用发起之后直接进行下一个任务的处理。等到```IO```的结果处理完成之后再通过某种信号或者回调将数据传回给当前的代码。

```Node```当中的```libuv```可以理解为接种不同的异步```IO```操作的抽象封装层。当运行一段```NodeJS```编写的代码之后最终是会走到```libuv```环境中，他会对当前的平台进行判断，依据平台调用相应的异步```IO```处理方法。

```Node```中实现异步```IO```的过程是离不开事件循环的，不过事件循环这里不过多介绍，后面有时间单独开篇章来说明。

这里从执行的周期来介入说明，使用```Node```运行一段```js```脚本，如果代码中存在异步请求，```libuv```就会工作，他的内部存在一个事件循环机制，会对相应的异步请求处理程序进行管理。如果处理的是网络```IO```，则会调用操作系统底层的```IO```接口来进行处理。如果是一个文件```IO```就会放入到```Node```自行实现的一个线程池当中进行处理。无论是哪一种处理方式，最终都会有一个返回的结果，这个结果在出来之后就会通过```event loop```再去把他对应的处理程序加入到事件队列中，等待```js```的主线程进行执行。

这里的循环也不是一直运转不停的，当他发现队列中完全没有了需要等待执行的任务时也就会去退出循环，当前程序的执行也就结束了。对于```node```来说异步```IO```操作也就算是实现和完成了。

```IO```可以看做是应用程序的瓶颈所在，他的处理一定是需要消耗时间的，这个时间是和设备环境相关的。采用异步```IO```是可以提高性能的，```IO```操作的本身属于系统级别，平台都有对应的实现，```linuv```就是对这些方法的封装，实现了跨平台。```node```单线程配合事件驱动及```libuv```实现了异步```IO```。

## 3. 事件驱动

事件驱动的架构就是建立在软件开发中的通用模式，为了便于理解，这里将它和发布订阅、观察者模式进行类比，但是这三者并不是一回事，只是他们在使用的时候有些相似的地方，比如说发布者广播消息，订阅者可以监听到订阅的消息。

```NodeJS```诞生初期是为了实现高性能的```Web```服务，他实现高性能的主要表现就是拥有了一套单线程下的异步非阻塞的```IO```机制，但是也正是异步非阻塞的```IO```实现让我们编写```NodeJS```代码时会编写很多的异步代码，由于非阻塞所以程序代码在执行的过程中业务层拿到的并不是最终的目标数据。

等到同步代码执行完毕之后底层的```libuv```就开始工作，可以认为在```libuv```的里面有两个非常重要的内容一个是```event loop```一个是```event queue```。

当```libuv```接收到异步请求之后多路分解器进行工作，首先会找到当前平台下可用的```IO```处理接口，在等待着```IO```处理结束之后