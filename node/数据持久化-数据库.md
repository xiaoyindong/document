## 1. 概述

实现持久话可以有多种方法，```文件存储```或者```数据库```。

| 类型 | 代表 |
| --- | --- |
| 关系型 | mysql |
| 文档型 | mongodb |
| 键值对 | redis |

## 2. 文件系统数据库

```js
const fs = require('fs');
function get(key) {
    fs.readFile('./db.json', (err, data) => {
        const json = JSON.parse(data);
        console.log(json[key]);
    })
}
function set(key, value) {
    fs.readFileSync('./db.json', (err, data) => {
        const json = data ? JSON.parse(data) : {};
        json[key] = value; // 设置值
        // 重新写入文件
        fs.writeFile('./db.json', JSON.stringify(json), err => {
            if (err) {
                console.log(err);
            } else {
                console.log('写入成功');
            }
        })
    })
}

// 命令行接口部分
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});
rl.on('line', function(input) {
    const [op, key, value] = input.split(" ");
    if (op === 'get') {
        get(key);
    } else if (op === 'set') {
        set(key, value);
    } else if (op === 'quit') {
        rl.close();
    } else {
        console.log('没有该操作');
    }
});

fl.on('close', function() {
    console.log("程序结束");
    process.exit(0);
})
```

## 3. mysql

```js
// npm i mysql --save;
const mysql = require('mysql');
const cfg = {
    host: 'localhost',
    user: 'root',
    password: 'admin',
    database: 'yddb',
}
// 操作语句 conn.query();
// 创建连接
const conn = mysql.createConnection(cfg);
// 连接
conn.connect(err => {
    if (err) {
        throw err;
    } else {
        console.log('连接成功');
    }
})
// 创建表
const CREATE_SQL = `CREATE TABLE IF NOT EXISTS test (
    id INT NOT NULL AUTO_INCREMENT,
    message VARCHAR(45) NULL,
    PRIMARY KEY (id)
)`

const INSERT_SQL = `INSERT INTO test(message) VALUES(?)`;
const SELECT_SQL = `SELECT * FROM test`;

conn.query(CREATE_SQL, err => {
    if (err) {
        throw err;
    }
    // 插入数据
    conn.query(INSERT_SQL, 'hello, world', (err, result) => {
        if (err) {
            throw err;
        }
        console.log(result);
        conn.query(SELECT_SQL, (err, results) => {
            console.log(results);
            conn.end(); // 若query语句有嵌套，则end需在此执行
        })
    })
})

```

## 4. ORM sequelize

基于```promise```的```ORM(Object Relation Mapping)```支持多种数据库，事务，关联等

```js
// 安装 npm i sequelize mysql2 -S
const Sequelize = require('sequelize');
// 建立连接
const sequelize = new Sequelize('yd', 'root', 'admin', {
    host: 'localhost',
    dialect: 'mysql',
    operatorsAliases: false
});
// 定义模型
const Fruit = sequelize.define('Fruit', {
    name: { type: Sequelize.STRING(20), allowNull: false },
    price: { type: Sequelize.FLOAT, allowNull: false },
    stock: { type: Sequelize.INTEGRE, defaultValue: 0 }
});
// 同步数据库，force: true 则会删除已存在的表
Fruit.sync().then(() => {
    // 添加测试数据
    return Fruit.create({
        name: '香蕉',
        price: 3.5
    });
}).then(() => {
    // 查询
    Fruit.findAll().then(fruits => {
        console.log(JSON.stringify(fruits));
    })
})

```

1. 强制同步: 创建表之前先删除已存在的表

```js
Fruit.sync({ force: true })'
```

2. 避免自动生成时间戳字段

```js
const Fruit = sequelize.define('Fruit', {}, {
    timestamps: false
})
```

3. 指定表名字

freeTableName: ```true```或```tableName: 'xxx'```

设置前者则以```modelName```作为表名; 设置后者则按其值作为表明

4. Getters & Setters：可用于定义伪属性或映射到数据库字段的保护属性

```json
// 定义为属性的一部分
name: {
    type: Sequelize.STRING,
    allowNull: false,
    get() {
        const fname = this.getDataValue('name');
        const price = this.getDataValue('price');
        const stock = this.getDataValue('stock');
        return `${fname}, ${price}, ${stock}`
    }
}
// 定义为模型选项
{
    getterMethods: {
        amount() {
            return this.getDataValue('stock') + 'kg';
        }
    },
    setterMethods: {
        amount(val) {
            const idx = val.indexOf('kg');
            const v = val.slice(0, idx);
            this.setDataValue('stock', v);
        }
    }
}

// 通过模型实例触发setterMethods
Fruit.findAll().then(fruits => {
    console.log(JSON.stringify(fruits));
    // 修改amount，触发setterMethods
    fruits[0].amount = '150kg';
    fruits[0].save();
})
```

5. 检验

可以通过检验功能验证模型字段格式，内容，检验会在```create```, ```update```和```save```时自动运行

```json
price: {
    validate: {
        isFloat: { msg: '价格字段请输入数字'},
        min: { args: [0], mes: '价格字段必须大于0'}
    }
},
stock: {
    validate: {
        isNumeric: { msg: '库存字段请输入数字'}
    }
}
```

6. 模型扩展：可添加模型实例方法或类方法扩展模型

```js
// 添加类级别方法
Fruit.classify = function(name) {
    const tropicFruits = ['香蕉', '芒果', '椰子']; // 热带水果
    return tropicFruits.includes(name) ? '热带水果' : ''其它水果
}
// 添加实例级别方法
Fruit.prototype.totalPrice = function(count) {
    return (this.price * count).toFixed(2);
}
Fruit.findAll().then(fruits => {
    const [ f1 ] = fruits;
    console.log(f1.totalPrice(5));
})
```

7. 数据查询

```js
// 通过id查询
Fruit.findById(1).then(fruit => {
    // fruit 是一个Fruit 实例，若没有则为null
    console.log(fruit.get());
})
// 通过属性查询
Fruit.findOne({ where: { name: '香蕉' } }).then(fruit => {
    // fruit 是首歌匹配项, 若没有则为null
    console.log(fruit.get());
});
// 获取数据和总条数
Fruit.findAndCountAll().then(result => {
    console.log(result.count);
    console.log(result.rows.length);
});
// 查询操作符
const Op = Sequelize.Op;
Fruit.findAll({
    // where: { price: {[Op.lt]: 4 }, stock: { [Op.gte]: 100 }}
    where: { price: { [Op.lt]: 4, [Op.gt]: 2}}
}).then(fruits => {
    console.log(fruits.length);
});
// 或语句
Fruit.findAll({
    where: { price: { [Op.or]: [{ [Op.gt]: 3}, { [Op.lt: 2]}]}}
}).then(fruits => {
    console.log(fruits[0].get());
})
// 分页
Fruit.findAll({
    offset: 0,
    limit: 2
})
// 排序
Fruit.findAll({
    order: [['price', 'desc']],
})
// 聚合
setTimeout(() => {
    Fruit.max('price').then(max => {
        console.log(max);
    });
    Fruit.sum('price').then(sum => {
        console.log(sum);
    })
}, 500)
```

8. 更新

```js
Fruit.findById(1).then(fruit => {
    // 方式1
    fruit.price = 4;
    fruit.save().then(() => { console.log('update')});
})
// 方式2
Friut.update({ price: 4}, { where: {id : 1}}).then(r => {
    console.l